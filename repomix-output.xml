This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy-github-pages.yml
    publish.yml
  dependabot.yml
docs/
  pie_language/
    pie_examples.md
    pie_language_spec.md
    pie_type_reference.md
src/
  language_server/
    __test__/
      test_sidebar.pie
      test.pie
    client/
      src/
        extension.ts
        pie_command_handler.ts
        pie_output_provider.ts
    server/
      src/
        pie_hover_info.ts
        server.ts
    syntaxes/
      pie.tmLanguage.json
    language-configuration.json
    LICENSE
    package.json
    tsconfig.json
  pie_interpreter/
    __tests__/
      test_absurd.ts
      test_alpha.ts
      test_and.ts
      test_check_same_advanced.ts
      test_check_same_collections.ts
      test_check_same.ts
      test_ctor_debug.ts
      test_datatype_only.ts
      test_doEliminator_core.ts
      test_either.ts
      test_elimEqual.ts
      test_elimlist.ts
      test_exists.ts
      test_indices.ts
      test_lessThan.ts
      test_lsp.pie
      test_main.ts
      test_method_type.ts
      test_motive_type.ts
      test_parse_evaluate.ts
      test_parser.ts
      test_sort.ts
      test_subtype.ts
      test_tactics_example.ts
      test_tactics.ts
      test_telescope.ts
      test_temp.ts
      test_vec.ts
      tests.ts
    evaluator/
      evaluator.ts
      utils.ts
    parser/
      makers.ts
      parser.ts
    solver/
      main.ts
      todo_solver.browser.ts
      todo_solver.ts
    tactics/
      proofmanager.ts
      proofstate.ts
      tactics.ts
    typechecker/
      definedatatype.ts
      represent.ts
      synthesizer.ts
      utils.ts
    types/
      core.ts
      neutral.ts
      source.ts
      utils.ts
      value.ts
    unparser/
      pretty.ts
    utils/
      alphaeqv.ts
      context.ts
      environment.ts
      fresh.ts
      locations.ts
    index.ts
    main.ts
    PieEvaluator.ts
  scheme_parser/
    transpiler/
      lexer/
        index.ts
        lexer-error.ts
        lexer.ts
        scheme-lexer.ts
      parser/
        index.ts
        parser-error.ts
        parser.ts
        scheme-parser.ts
      types/
        nodes/
          scheme-node-types.ts
        tokens/
          __tests__/
            group.ts
          datum.ts
          group.ts
          index.ts
          token-type.ts
          token.ts
        constants.ts
        location.ts
      visitors/
        index.ts
        printer.ts
        redefiner.ts
        simplifier.ts
        transpiler.ts
        visitor.ts
      index.ts
    utils/
      encoder-visitor.ts
      estree-nodes.ts
      reverse_parser.ts
    compile-libs.ts
    core-math.ts
    index.ts
  standalone.ts
web/
  lsp/
    lsp-client-simple.js
    lsp-client-simple.ts
    pie_hover_info.ts
    pie-language-server-simple.worker.ts
    README.md
  proof-tree/
    CollapsibleTypeTree.ts
    ContextPanel.ts
    GoalPanel.ts
    ProofTreeVisualizer.ts
    SExpressionParser.ts
    types.ts
  app.bundle.js
  app.bundle.js.map
  app.js
  app.ts
  diagnostics-worker.js
  index.html
  styles.css
  worker-entry.ts
.env.example
.gitignore
.pnp.loader.mjs
.tool-versions
eslint.config.js
github-pages-index.html
jest.config.json
LICENSE
LLM_SETUP.md
package.json
README.md
rollup.config.js
tsconfig.json
tsconfig.standalone.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/dependabot.yml">
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for all configuration options:
# https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file

# Basic `dependabot.yml` file with
# minimum configuration for three package managers

version: 2
updates:
  # Enable version updates for npm
  - package-ecosystem: "npm"
    # Look for `package.json` and `lock` files in the `root` directory
    directory: "/"
    # Check the npm registry for updates every day (weekdays)
    schedule:
      interval: "daily"

  # Enable version updates for Docker
  - package-ecosystem: "docker"
    # Look for a `Dockerfile` in the `root` directory
    directory: "/"
    # Check for updates once a week
    schedule:
      interval: "weekly"

  # Enable version updates for GitHub Actions
  - package-ecosystem: "github-actions"
    # Workflow files stored in the default location of `.github/workflows`
    # You don't need to specify `/.github/workflows` for `directory`. You can use `directory: "/"`.
    directory: "/"
    schedule:
      interval: "weekly"
</file>

<file path="src/pie_interpreter/__tests__/test_alpha.ts">
import 'jest'

import { alphaEquiv } from '../utils/alphaeqv'
import * as C from '../types/core';

describe("alpha equivalence", () => {
  
  describe("Variable tests", () => {
    it("should check alpha equivalence of bound variables with different names", () => {
      const expr1 = new C.Pi('x', new C.Nat(), new C.VarName('x'));
      const expr2 = new C.Pi('y', new C.Nat(), new C.VarName('y'));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should check alpha equivalence of lambda expressions with different parameter names", () => {
      const expr1 = new C.Lambda('x', new C.VarName('x'));
      const expr2 = new C.Lambda('y', new C.VarName('y'));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should distinguish bound from free variables", () => {
      const expr1 = new C.Lambda('x', new C.VarName('x'));  // bound x
      const expr2 = new C.Lambda('y', new C.VarName('x'));  // free x
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });

    it("should check equivalence of same free variables", () => {
      const expr1 = new C.Lambda('x', new C.VarName('y'));  // free y
      const expr2 = new C.Lambda('z', new C.VarName('y'));  // free y
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should distinguish different free variables", () => {
      const expr1 = new C.Lambda('x', new C.VarName('y'));  // free y
      const expr2 = new C.Lambda('z', new C.VarName('w'));  // free w
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });
  });

  describe("Lambda expression tests", () => {
    it("should handle nested lambda expressions", () => {
      const expr1 = new C.Lambda('x', new C.Lambda('y', new C.VarName('x')));
      const expr2 = new C.Lambda('a', new C.Lambda('b', new C.VarName('a')));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should distinguish different variable references in nested lambdas", () => {
      const expr1 = new C.Lambda('x', new C.Lambda('y', new C.VarName('x')));
      const expr2 = new C.Lambda('a', new C.Lambda('b', new C.VarName('b')));
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });

    it("should handle shadowing correctly", () => {
      const expr1 = new C.Lambda('x', new C.Lambda('x', new C.VarName('x')));
      const expr2 = new C.Lambda('y', new C.Lambda('z', new C.VarName('z')));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });

  describe("Pi type tests", () => {
    it("should handle dependent function types", () => {
      // (Π (x Nat) (Π (y Nat) Nat)) - simple non-dependent case
      const expr1 = new C.Pi('x', new C.Nat(), new C.Pi('y', new C.Nat(), new C.VarName('x')));
      const expr2 = new C.Pi('a', new C.Nat(), new C.Pi('b', new C.Nat(), new C.VarName('a')));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should distinguish Pi types with different argument types", () => {
      const expr1 = new C.Pi('x', new C.Nat(), new C.VarName('x'));
      const expr2 = new C.Pi('x', new C.Atom(), new C.VarName('x'));
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });

    it("should handle Pi types with free variables in body", () => {
      const expr1 = new C.Pi('x', new C.Nat(), new C.VarName('z'));  // z is free
      const expr2 = new C.Pi('y', new C.Nat(), new C.VarName('z'));  // z is free
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should handle function types (non-dependent Pi)", () => {
      // (Π (x Nat) Atom) ≡ (Π (y Nat) Atom) - function type Nat -> Atom
      const expr1 = new C.Pi('x', new C.Nat(), new C.Atom());
      const expr2 = new C.Pi('y', new C.Nat(), new C.Atom());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });

  describe("Sigma type tests", () => {
    it("should handle dependent pair types", () => {
      // (Σ (x Nat) Atom) - pair where second component doesn't depend on first
      const expr1 = new C.Sigma('x', new C.Nat(), new C.Atom());
      const expr2 = new C.Sigma('y', new C.Nat(), new C.Atom());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should handle nested Sigma types", () => {
      // (Σ (x Nat) (Σ (y Atom) Trivial))
      const expr1 = new C.Sigma('x', new C.Nat(), new C.Sigma('y', new C.Atom(), new C.Trivial()));
      const expr2 = new C.Sigma('a', new C.Nat(), new C.Sigma('b', new C.Atom(), new C.Trivial()));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should handle Sigma types with free variables in body", () => {
      const expr1 = new C.Sigma('x', new C.Nat(), new C.VarName('T'));  // T is free type variable
      const expr2 = new C.Sigma('y', new C.Nat(), new C.VarName('T'));  // T is free type variable
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });
  describe("Application tests", () => {
    it("should handle simple applications", () => {
      const expr1 = new C.Application(new C.Lambda('x', new C.VarName('x')), new C.Zero());
      const expr2 = new C.Application(new C.Lambda('y', new C.VarName('y')), new C.Zero());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should distinguish different applications", () => {
      const expr1 = new C.Application(new C.Lambda('x', new C.VarName('x')), new C.Zero());
      const expr2 = new C.Application(new C.Lambda('y', new C.VarName('y')), new C.Add1(new C.Zero()));
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });

    it("should handle nested applications", () => {
      const expr1 = new C.Application(
        new C.Lambda('x', 
          new C.Application(new C.VarName('x'), new C.Zero())),
        new C.Lambda('y', 
          new C.Application(new C.VarName('y'), new C.Add1(new C.Zero())))
      );
      
      const expr2 = new C.Application(
        new C.Lambda('a', 
          new C.Application(new C.VarName('a'), new C.Zero())),
        new C.Lambda('b', 
          new C.Application(new C.VarName('b'), new C.Add1(new C.Zero())))
      );
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });

  describe("Natural number tests", () => {
    it("should handle zero", () => {
      expect(alphaEquiv(new C.Zero(), new C.Zero())).toBe(true);
    });

    it("should handle add1", () => {
      const expr1 = new C.Add1(new C.Zero());
      const expr2 = new C.Add1(new C.Zero());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should distinguish different natural numbers", () => {
      const expr1 = new C.Add1(new C.Zero());
      const expr2 = new C.Add1(new C.Add1(new C.Zero()));
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });
  });

  describe("Quote tests", () => {
    it("should handle atom quotes", () => {
      const expr1 = new C.Quote('hello');
      const expr2 = new C.Quote('hello');
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should distinguish different quotes", () => {
      const expr1 = new C.Quote('hello');
      const expr2 = new C.Quote('world');
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });
  });

  describe("Pair tests", () => {
    it("should handle cons expressions", () => {
      const expr1 = new C.Cons(new C.Zero(), new C.Quote('a'));
      const expr2 = new C.Cons(new C.Zero(), new C.Quote('a'));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should handle car and cdr", () => {
      const pair = new C.Cons(new C.Zero(), new C.Quote('a'));
      const expr1 = new C.Car(pair);
      const expr2 = new C.Car(pair);
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });

  describe("List tests", () => {
    it("should handle list types", () => {
      const expr1 = new C.List(new C.Nat());
      const expr2 = new C.List(new C.Nat());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should handle nil", () => {
      expect(alphaEquiv(new C.Nil(), new C.Nil())).toBe(true);
    });

    it("should handle list cons", () => {
      const expr1 = new C.ListCons(new C.Zero(), new C.Nil());
      const expr2 = new C.ListCons(new C.Zero(), new C.Nil());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });

  describe("Equality tests", () => {
    it("should handle equality types", () => {
      const expr1 = new C.Equal(new C.Nat(), new C.Zero(), new C.Zero());
      const expr2 = new C.Equal(new C.Nat(), new C.Add1(new C.Zero()), new C.Add1(new C.Zero()));
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });

    it("should handle same", () => {
      const expr1 = new C.Same(new C.Zero());
      const expr2 = new C.Same(new C.Add1(new C.Zero()));
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });

    it("should handle replace", () => {
      const target = new C.VarName('eq');
      const motive = new C.Lambda('x', new C.Universe());
      const base = new C.VarName('proof');
      
      const expr1 = new C.Replace(target, motive, base);
      const expr2 = new C.Replace(target, motive, base);
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });

  describe("Vector tests", () => {
    it("should handle vector types", () => {
      const expr1 = new C.Vec(new C.Nat(), new C.Zero());
      const expr2 = new C.Vec(new C.Nat(), new C.Zero());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should handle vecnil", () => {
      expect(alphaEquiv(new C.VecNil(), new C.VecNil())).toBe(true);
    });

    it("should handle vec::", () => {
      const expr1 = new C.VecCons(new C.Zero(), new C.VecNil());
      const expr2 = new C.VecCons(new C.Zero(), new C.VecNil());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });

  describe("Either tests", () => {
    it("should handle Either types", () => {
      const expr1 = new C.Either(new C.Nat(), new C.Atom());
      const expr2 = new C.Either(new C.Nat(), new C.Atom());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should handle left and right", () => {
      const expr1 = new C.Left(new C.Zero());
      const expr2 = new C.Left(new C.Zero());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
      
      const expr3 = new C.Right(new C.Quote('a'));
      const expr4 = new C.Right(new C.Quote('a'));
      
      expect(alphaEquiv(expr3, expr4)).toBe(true);
    });

    it("should distinguish left from right", () => {
      const expr1 = new C.Left(new C.Zero());
      const expr2 = new C.Right(new C.Zero());
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });
  });

  describe("The annotation tests", () => {
    it("should handle type annotations", () => {
      const expr1 = new C.The(new C.Nat(), new C.Zero());
      const expr2 = new C.The(new C.Nat(), new C.Zero());
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should handle the annotations with bound variables", () => {
      const expr1 = new C.Lambda('x', new C.The(new C.Nat(), new C.VarName('x')));
      const expr2 = new C.Lambda('y', new C.The(new C.Nat(), new C.VarName('y')));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });

  describe("Complex expression tests", () => {
    it("should handle complex nested expressions", () => {
      // (λ (f) (λ (x) (f x))) ≡ (λ (g) (λ (y) (g y)))
      const expr1 = new C.Lambda('f', 
        new C.Lambda('x', 
          new C.Application(new C.VarName('f'), new C.VarName('x'))));
      
      const expr2 = new C.Lambda('g', 
        new C.Lambda('y', 
          new C.Application(new C.VarName('g'), new C.VarName('y'))));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should handle dependent types with applications", () => {
      // (Π (A U) (Π (f (Π (x A) A)) (f zero))) - where zero is a term, not f applied to f
      const innerPi = new C.Pi('x', new C.VarName('A'), new C.VarName('A'));
      const expr1 = new C.Pi('A', new C.Universe(), 
        new C.Pi('f', innerPi,
          new C.Application(new C.VarName('f'), new C.Zero())));
      
      const innerPi2 = new C.Pi('y', new C.VarName('B'), new C.VarName('B'));
      const expr2 = new C.Pi('B', new C.Universe(), 
        new C.Pi('g', innerPi2,
          new C.Application(new C.VarName('g'), new C.Zero())));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });

    it("should distinguish structurally different expressions", () => {
      const expr1 = new C.Lambda('x', new C.Lambda('y', new C.VarName('x')));
      const expr2 = new C.Lambda('x', new C.VarName('x'));
      
      expect(alphaEquiv(expr1, expr2)).toBe(false);
    });
  });

  describe("Edge cases", () => {
    it("should handle empty expressions correctly", () => {
      expect(alphaEquiv(new C.Sole(), new C.Sole())).toBe(true);
    });

    it("should handle completely different expression types", () => {
      expect(alphaEquiv(new C.Nat(), new C.Lambda('x', new C.VarName('x')))).toBe(false);
    });

    it("should handle self-referencing expressions", () => {
      const expr1 = new C.Lambda('x', new C.VarName('x'));
      const expr2 = new C.Lambda('x', new C.VarName('x'));
      
      expect(alphaEquiv(expr1, expr2)).toBe(true);
    });
  });
});
</file>

<file path="src/pie_interpreter/__tests__/test_elimEqual.ts">
import 'jest'
import { evaluatePie } from '../main';

describe("elimEqual", () => {
    it("Basic", () => {
        const str = `
    (claim +
  (→ Nat Nat
    Nat))

(claim step-plus
  (→ Nat
    Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1 ) ))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus )))

(claim incr
(→ Nat
Nat))

(define incr
(λ (n)
(iter-Nat n
1
(+ 1))))

(claim incr=add1
(Π ((n Nat))
(= Nat (incr n) (add1 n))))

(claim base-incr=add1
(= Nat (incr zero) (add1 zero)))
(define base-incr=add1
(same (add1 zero)))

(claim mot-incr=add1
(→ Nat
U ))
(define mot-incr=add1
(λ (k)
(= Nat (incr k) (add1 k))))

(claim step-incr=add1
(Π ((n-1 Nat))
(→ (= Nat
(incr n-1)
(add1 n-1))
(= Nat
(add1
(incr n-1))
(add1
(add1 n-1))))))

(define step-incr=add1
  (λ (n-1)
    (λ (incr=add1n-1)
      (ind-= incr=add1n-1
        (λ (x)
          (λ (proof-incr-n-1=x)
            (= Nat (add1 (incr n-1)) (add1 x))))
        (same (add1 (incr n-1)))))))
        `;
        const output = evaluatePie(str);
        console.log(output);
    })

    it("Tactic", () => {
        const str = `
    (claim +
  (→ Nat Nat
    Nat))

(claim step-plus
  (→ Nat
    Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1 ) ))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus )))

(claim incr
(→ Nat
Nat))

(define incr
(λ (n)
(iter-Nat n
1
(+ 1))))

(claim incr=add1
(Π ((n Nat))
(= Nat (incr n) (add1 n))))

(claim base-incr=add1
(= Nat (incr zero) (add1 zero)))
(define base-incr=add1
(same (add1 zero)))

(claim mot-incr=add1
(→ Nat
U ))
(define mot-incr=add1
(λ (k)
(= Nat (incr k) (add1 k))))

(claim step-incr=add1
(Π ((n-1 Nat))
(→ (= Nat
(incr n-1)
(add1 n-1))
(= Nat
(add1
(incr n-1))
(add1
(add1 n-1))))))

(define-tactically step-incr=add1
    ((intro n-1)
     (intro incr=add1n-1)
     (elimEqual incr=add1n-1 (λ (x)
          (λ (proof-incr-n-1=x)
            (= Nat (add1 (incr n-1)) (add1 x)))))
     (exact (same (add1 (incr n-1))))))
        `;
        const output = evaluatePie(str);
        console.log(output);
    })

    
})
</file>

<file path="src/pie_interpreter/__tests__/test_exists.ts">
import 'jest';

import {evaluatePie} from '../main'

describe("demo", () => {
  it("Pie demo", () => {
    const src = 
`
(claim +
  (→ Nat Nat
    Nat))

(claim step-plus
  (→ Nat
    Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1 ) ))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus )))

(claim double
  (→ Nat
    Nat))

(define double
  (λ (n)
    (iter-Nat n
      0
      (+ 2))))

(claim Even
(→ Nat
U ))
(define Even
(λ (n)
(Σ ((half Nat))
(= Nat n (double half )))))

(claim zero-is-even
(Even 0))

(define-tactically zero-is-even
((exists 0 x)
 (exact (same 0))))

`
    const result = evaluatePie(src);
    console.log(result);})
  })
</file>

<file path="src/pie_interpreter/unparser/pretty.ts">
import { Core } from "../types/core";
import { Value } from "../types/value";
import { Source } from "../types/source";

/**
 * Pretty print the Normalized Expression tree to a string.
 */
export function prettyPrintCore(expr: Core): string {
  return expr.prettyPrint();
}

export function prettyPrintValue(expr: Value): string {
  return expr.prettyPrint();
}

export function prettyPrintSource(expr: Source): string {
  return expr.prettyPrint();
}
</file>

<file path="src/pie_interpreter/utils/fresh.ts">
// Replace normal digits with subscript digits and vice versa
const subscriptReplacements: Record<string, string> = {
  "0": "₀",
  "1": "₁",
  "2": "₂",
  "3": "₃",
  "4": "₄",
  "5": "₅",
  "6": "₆",
  "7": "₇",
  "8": "₈",
  "9": "₉"
}

const nonSubscripts: Record<string, string> = {
  "₀": "0",
  "₁": "1",
  "₂": "2",
  "₃": "3",
  "₄": "4",
  "₅": "5",
  "₆": "6",
  "₇": "7",
  "₈": "8",
  "₉": "9"
}

// Main freshen function
export function freshen(used: string[], x: string): string {
  if (used.some(usedName => usedName === x)) {
    const split = splitName(x);
    return freshenAux(used, split);
  }
  return x;
}


function freshenAux(used: string[], split: [string, number]): string {
  const joined = unsplitName(split);
  if (used.map(sym => sym.toString()).includes(joined.toString())) {
    return freshenAux(used, nextSplitName(split));
  }
  return joined;
}

// Check if a character is a subscript digit
function isSubscriptDigit(c: string): boolean {
  return Object.keys(nonSubscripts).includes(c);
}

// Replaces regular digits in the number with subscript digits
function numberToSubscriptString(n: number): string {
  const subscriptStr = n.toString().split("").map(digit => subscriptReplacements[digit] || digit).join("");
  return subscriptStr;
}

// Replaces subscript digits with regular digits
function subscriptToNumber(str: string): number {
  const replaced = str.split("").map(char => nonSubscripts[char] || char).join("");
  return parseInt(replaced, 10) || 1;
}

// Helper function to split the name (base name and subscript)
function splitNameAux(str: string, i: number): [string, number] {
  if (i < 0) {
    return [str, 0]; // Default case if no subscript is found
  }
  if (isSubscriptDigit(str[i])) {
    return splitNameAux(str, i - 1);
  }
  return [str.substring(0, i + 1), subscriptToNumber(str.substring(i + 1))];
}

// Increments the subscript part of a name
function nextSplitName(split: [string, number]): [string, number] {
  return [split[0], split[1] + 1];
}

// Splits the name into base name and subscript number
function splitName(name: string): [string, number] {

  // Call splitNameAux on the string representation
  const [base, num] = splitNameAux(name, name.length - 1);
  return [base, num];
}

// Joins the base name and subscript into a new name
function unsplitName([base, num]: [string, number]): string {

  // Convert number to subscript string
  const subscriptStr = numberToSubscriptString(num);
  return base + subscriptStr;
}
</file>

<file path="src/pie_interpreter/utils/locations.ts">
import { Position } from '../../scheme_parser/transpiler/types/location';

export class SourceLocation {
  constructor(
    public source: string,
    public startLine: number,
    public startColumn: number,
    public endLine: number,
    public endColumn: number,
  ) { }
}


export class Syntax {
  constructor(
    public start: Position,
    public end: Position,
    public source: string
  ) { }
}

export class Location {
  constructor(
    public syntax: Syntax,
    public forInfo: boolean
  ) { }

  public locationToSrcLoc(): SourceLocation {
    return new SourceLocation(
      this.syntax.source,
      this.syntax.start.line,
      this.syntax.start.column,
      this.syntax.end.line,
      this.syntax.end.column
    )
  }

  public toString(): string {
    return `${this.syntax.source}:${this.syntax.start.line}:${this.syntax.start.column}`;
  }
}

export function notForInfo(loc: Location): Location {
  return new Location(loc.syntax, false);
}
</file>

<file path="src/scheme_parser/transpiler/lexer/index.ts">
/**
 * Exports all lexer related components.
 */
export { Lexer } from "./lexer";
export * as LexerError from "./lexer-error";
export { SchemeLexer } from "./scheme-lexer";
</file>

<file path="src/scheme_parser/transpiler/lexer/lexer-error.ts">
import { Position } from "../types/location";

export abstract class LexerError extends SyntaxError {
  // This base error shouldn't be used directly.
  loc: Position;
  constructor(message: string, line: number, col: number) {
    super(message);
    this.loc = {
      line: line,
      column: col,
    };
  }
  toString(): string {
    return this.message;
  }
}

export class UnexpectedCharacterError extends LexerError {
  char: string;
  constructor(line: number, col: number, char: string) {
    super(`Unexpected character \'${char}\' (${line}:${col})`, line, col);
    this.char = char;
    this.name = "UnexpectedCharacterError";
  }
}

export class UnexpectedEOFError extends LexerError {
  constructor(line: number, col: number) {
    super(`Unexpected EOF (${line}:${col})`, line, col);
    this.name = "UnexpectedEOFError";
  }
}
</file>

<file path="src/scheme_parser/transpiler/lexer/lexer.ts">
/**
 * An interface for a lexer.
 *
 * Takes source code and returns tokens
 * that represent each unit of data
 * in the source code.
 */
import { Token } from "../types/tokens/token";

export interface Lexer {
  scanTokens(): Token[];
}
</file>

<file path="src/scheme_parser/transpiler/parser/index.ts">
/**
 * Exports all parser related components.
 */

export { Parser } from "./parser";
export * as ParserError from "./parser-error";
export { SchemeParser } from "./scheme-parser";
</file>

<file path="src/scheme_parser/transpiler/parser/parser.ts">
import { Expression } from "../types/nodes/scheme-node-types";

/**
 * Interface for the Parser class
 */
export interface Parser {
  parse(): Expression[];
}
</file>

<file path="src/scheme_parser/transpiler/types/nodes/scheme-node-types.ts">
/**
 * Node types of the abstract syntax tree of the Scheme Language.
 * We aim to be as simple as possible, and only represent the bare minimum
 * of Scheme syntax.
 *
 * Syntatic sugar such as "cond" or "let" will be left in another file,
 * and will be translated into the bare minimum of Scheme syntax, for now
 * with a transformer visitor, and perhaps later with a macro system.
 */

import { Visitor } from "../../visitors";
import { Location } from "../location";

/**
 * A basic node that represents a Scheme expression.
 */
export interface Expression {
  location: Location;
  accept(visitor: Visitor): any;
  equals(other: Expression): boolean;
}

/**
 * The namespace for all the atomic node types.
 */
export namespace Atomic {
  // Scheme chapter 1

  /**
   * A node that represents a sequence of expressions.
   * Also introduces a new scope.
   * The last expression is the return value of the sequence.
   */
  export class Sequence implements Expression {
    location: Location;
    expressions: Expression[];
    constructor(location: Location, expressions: Expression[]) {
      this.location = location;
      this.expressions = expressions;
    }
    accept(visitor: Visitor): any {
      return visitor.visitSequence(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Sequence) {
        if (this.expressions.length !== other.expressions.length) {
          return false;
        }
        for (let i = 0; i < this.expressions.length; i++) {
          if (!this.expressions[i].equals(other.expressions[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
  }

  /**
   * A node that represents a Scheme literal.
   */
  export interface Literal extends Expression {
    value: any;
  }

  /**
   * A node that represents a Scheme number.
   * TODO: Support the Scheme number tower.
   */
  export class NumericLiteral implements Literal {
    location: Location;
    value: string;
    constructor(location: Location, value: string) {
      this.location = location;
      this.value = value;
    }
    accept(visitor: Visitor): any {
      return visitor.visitNumericLiteral(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof NumericLiteral) {
        return this.value === other.value;
      }
      return false;
    }
  }

  /**
   * A node that represents a Scheme boolean.
   */
  export class BooleanLiteral implements Literal {
    location: Location;
    value: boolean;
    constructor(location: Location, value: boolean) {
      this.location = location;
      this.value = value;
    }
    accept(visitor: Visitor): any {
      return visitor.visitBooleanLiteral(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof BooleanLiteral) {
        return this.value === other.value;
      }
      return false;
    }
  }

  /**
   * A node that represents a Scheme string.
   */
  export class StringLiteral implements Literal {
    location: Location;
    value: string;
    constructor(location: Location, value: string) {
      this.location = location;
      this.value = value;
    }
    accept(visitor: Visitor): any {
      return visitor.visitStringLiteral(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof StringLiteral) {
        return this.value === other.value;
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme lambda expression.
   * TODO: Support rest arguments.
   */
  export class Lambda implements Expression {
    location: Location;
    params: Identifier[];
    rest?: Identifier;
    body: Expression;
    constructor(
      location: Location,
      body: Expression,
      params: Identifier[],
      rest: Identifier | undefined = undefined
    ) {
      this.location = location;
      this.params = params;
      this.rest = rest;
      this.body = body;
    }
    accept(visitor: Visitor): any {
      return visitor.visitLambda(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Lambda) {
        if (this.params.length !== other.params.length) {
          return false;
        }
        for (let i = 0; i < this.params.length; i++) {
          if (!this.params[i].equals(other.params[i])) {
            return false;
          }
        }
        if (this.rest && other.rest) {
          if (!this.rest.equals(other.rest)) {
            return false;
          }
        } else if (this.rest || other.rest) {
          return false;
        }
        return this.body.equals(other.body);
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme identifier.
   */
  export class Identifier implements Expression {
    location: Location;
    name: string;
    constructor(location: Location, name: string) {
      this.location = location;
      this.name = name;
    }
    accept(visitor: Visitor): any {
      return visitor.visitIdentifier(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Identifier) {
        return this.name === other.name;
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme variable definition.
   * Returns nil.
   */
  export class Definition implements Expression {
    location: Location;
    name: Identifier;
    value: Expression;
    constructor(location: Location, name: Identifier, value: Expression) {
      this.location = location;
      this.name = name;
      this.value = value;
    }
    accept(visitor: Visitor): any {
      return visitor.visitDefinition(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Definition) {
        return this.name.equals(other.name) && this.value.equals(other.value);
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme function application.
   */
  export class Application implements Expression {
    location: Location;
    operator: Expression;
    operands: Expression[];
    constructor(
      location: Location,
      operator: Expression,
      operands: Expression[]
    ) {
      this.location = location;
      this.operator = operator;
      this.operands = operands;
    }
    accept(visitor: Visitor): any {
      return visitor.visitApplication(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Application) {
        if (!this.operator.equals(other.operator)) {
          return false;
        }
        if (this.operands.length !== other.operands.length) {
          return false;
        }
        for (let i = 0; i < this.operands.length; i++) {
          if (!this.operands[i].equals(other.operands[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme conditional expression.
   */
  export class Conditional implements Expression {
    location: Location;
    test: Expression;
    consequent: Expression;
    alternate: Expression;
    constructor(
      location: Location,
      test: Expression,
      consequent: Expression,
      alternate: Expression
    ) {
      this.location = location;
      this.test = test;
      this.consequent = consequent;
      this.alternate = alternate;
    }
    accept(visitor: Visitor): any {
      return visitor.visitConditional(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Conditional) {
        return (
          this.test.equals(other.test) &&
          this.consequent.equals(other.consequent) &&
          this.alternate.equals(other.alternate)
        );
      }
      return false;
    }
  }

  // Scheme chapter 2

  /**
   * A node representing a Scheme pair.
   */
  export class Pair implements Expression {
    location: Location;
    car: Expression;
    cdr: Expression;
    constructor(location: Location, car: Expression, cdr: Expression) {
      this.location = location;
      this.car = car;
      this.cdr = cdr;
    }
    accept(visitor: Visitor): any {
      return visitor.visitPair(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Pair) {
        return this.car.equals(other.car) && this.cdr.equals(other.cdr);
      }
      return false;
    }
  }

  /**
   * A node representing nil, an empty scheme list.
   */
  export class Nil implements Expression {
    location: Location;
    constructor(location: Location) {
      this.location = location;
    }
    accept(visitor: Visitor): any {
      return visitor.visitNil(this);
    }
    equals(other: Expression): boolean {
      return other instanceof Nil;
    }
  }

  /**
   * A node representing a Scheme symbol.
   */
  export class Symbol implements Literal {
    location: Location;
    value: string;
    constructor(location: Location, value: string) {
      this.location = location;
      this.value = value;
    }
    accept(visitor: Visitor): any {
      return visitor.visitSymbol(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Symbol) {
        return this.value === other.value;
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme marker for unquote_splicing.
   * This will be evaluated at runtime.
   */
  export class SpliceMarker implements Expression {
    location: Location;
    value: Expression;
    constructor(location: Location, value: Expression) {
      this.location = location;
      this.value = value;
    }
    accept(visitor: Visitor): any {
      return visitor.visitSpliceMarker(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof SpliceMarker) {
        return this.value.equals(other.value);
      }
      return false;
    }
  }

  // Scheme chapter 3

  /**
   * A node representing a Scheme variable reassignment.
   * Only supposed to be used on a variable that has been defined.
   * Returns nil.
   */
  export class Reassignment implements Expression {
    location: Location;
    name: Identifier;
    value: Expression;
    constructor(location: Location, name: Identifier, value: Expression) {
      this.location = location;
      this.name = name;
      this.value = value;
    }
    accept(visitor: Visitor): any {
      return visitor.visitReassignment(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Reassignment) {
        return this.name.equals(other.name) && this.value.equals(other.value);
      }
      return false;
    }
  }

  // scm-slang specific

  /**
   * A node representing an import statement.
   * syntax: (import <source> ( <identifier>* ))
   * Returns nil.
   */
  export class Import implements Expression {
    location: Location;
    source: StringLiteral;
    identifiers: Identifier[];
    constructor(
      location: Location,
      source: StringLiteral,
      identifiers: Identifier[]
    ) {
      this.location = location;
      this.source = source;
      this.identifiers = identifiers;
    }
    accept(visitor: Visitor): any {
      return visitor.visitImport(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Import) {
        if (!this.source.equals(other.source)) {
          return false;
        }
        if (this.identifiers.length !== other.identifiers.length) {
          return false;
        }
        for (let i = 0; i < this.identifiers.length; i++) {
          if (!this.identifiers[i].equals(other.identifiers[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
  }

  /**
   * A node representing an export statement.
   * syntax: (export ( <definition> ))
   * Returns nil.
   */
  export class Export implements Expression {
    location: Location;
    definition: Definition | Extended.FunctionDefinition;
    constructor(
      location: Location,
      definition: Definition | Extended.FunctionDefinition
    ) {
      this.location = location;
      this.definition = definition;
    }
    accept(visitor: Visitor): any {
      return visitor.visitExport(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Export) {
        return this.definition.equals(other.definition);
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme Vector.
   */
  export class Vector implements Expression {
    location: Location;
    elements: Expression[];
    constructor(location: Location, elements: Expression[]) {
      this.location = location;
      this.elements = elements;
    }
    accept(visitor: Visitor): any {
      return visitor.visitVector(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Vector) {
        if (this.elements.length !== other.elements.length) {
          return false;
        }
        for (let i = 0; i < this.elements.length; i++) {
          if (!this.elements[i].equals(other.elements[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme define-syntax expression.
   */
  export class DefineSyntax implements Expression {
    location: Location;
    name: Identifier;
    transformer: SyntaxRules;
    constructor(
      location: Location,
      name: Identifier,
      transformer: SyntaxRules
    ) {
      this.location = location;
      this.name = name;
      this.transformer = transformer;
    }
    accept(visitor: Visitor): any {
      return visitor.visitDefineSyntax(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof DefineSyntax) {
        return (
          this.name.equals(other.name) &&
          this.transformer.equals(other.transformer)
        );
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme syntax-rules expression.
   */
  export class SyntaxRules implements Expression {
    location: Location;
    literals: Symbol[];
    rules: [Expression, Expression][];
    constructor(
      location: Location,
      literals: Symbol[],
      rules: [Expression, Expression][]
    ) {
      this.location = location;
      this.literals = literals;
      this.rules = rules;
    }
    accept(visitor: Visitor): any {
      return visitor.visitSyntaxRules(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof SyntaxRules) {
        if (this.literals.length !== other.literals.length) {
          return false;
        }
        for (let i = 0; i < this.literals.length; i++) {
          if (!this.literals[i].equals(other.literals[i])) {
            return false;
          }
        }
        if (this.rules.length !== other.rules.length) {
          return false;
        }
        for (let i = 0; i < this.rules.length; i++) {
          if (
            !this.rules[i][0].equals(other.rules[i][0]) ||
            !this.rules[i][1].equals(other.rules[i][1])
          ) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
  }
}

/**
 * The namespace for all the syntactic sugar node types.
 * Will be transformed into the bare minimum of Scheme syntax.
 * Eventually, we won't need this namespace, as all the syntactic sugar
 * will be converted by a macro system.
 */
export namespace Extended {
  // Scheme chapter 1

  /**
   * A node representing a function definition.
   */
  export class FunctionDefinition implements Expression {
    location: Location;
    name: Atomic.Identifier;
    params: Atomic.Identifier[];
    rest?: Atomic.Identifier;
    body: Expression;
    constructor(
      location: Location,
      name: Atomic.Identifier,
      body: Expression,
      params: Atomic.Identifier[],
      rest: Atomic.Identifier | undefined = undefined
    ) {
      this.location = location;
      this.name = name;

      this.body = body;
      this.params = params;
      this.rest = rest;
    }
    accept(visitor: Visitor): any {
      return visitor.visitFunctionDefinition(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof FunctionDefinition) {
        if (this.params.length !== other.params.length) {
          return false;
        }
        for (let i = 0; i < this.params.length; i++) {
          if (!this.params[i].equals(other.params[i])) {
            return false;
          }
        }
        if (this.rest && other.rest) {
          if (!this.rest.equals(other.rest)) {
            return false;
          }
        } else if (this.rest || other.rest) {
          return false;
        }
        return this.body.equals(other.body);
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme let expression.
   */
  export class Let implements Expression {
    location: Location;
    identifiers: Atomic.Identifier[];
    values: Expression[];
    body: Expression;
    constructor(
      location: Location,
      identifiers: Atomic.Identifier[],
      values: Expression[],
      body: Expression
    ) {
      this.location = location;
      this.identifiers = identifiers;
      this.values = values;
      this.body = body;
    }
    accept(visitor: Visitor): any {
      return visitor.visitLet(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Let) {
        if (this.identifiers.length !== other.identifiers.length) {
          return false;
        }
        for (let i = 0; i < this.identifiers.length; i++) {
          if (!this.identifiers[i].equals(other.identifiers[i])) {
            return false;
          }
        }
        if (this.values.length !== other.values.length) {
          return false;
        }
        for (let i = 0; i < this.values.length; i++) {
          if (!this.values[i].equals(other.values[i])) {
            return false;
          }
        }
        return this.body.equals(other.body);
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme cond expression.
   * MAY return nil.
   */
  export class Cond implements Expression {
    location: Location;
    predicates: Expression[];
    consequents: Expression[];
    catchall: Expression | undefined;
    constructor(
      location: Location,
      predicates: Expression[],
      consequents: Expression[],
      catchall?: Expression
    ) {
      this.location = location;
      this.predicates = predicates;
      this.consequents = consequents;
      this.catchall = catchall;
    }
    accept(visitor: Visitor): any {
      return visitor.visitCond(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Cond) {
        if (this.predicates.length !== other.predicates.length) {
          return false;
        }
        for (let i = 0; i < this.predicates.length; i++) {
          if (!this.predicates[i].equals(other.predicates[i])) {
            return false;
          }
        }
        if (this.consequents.length !== other.consequents.length) {
          return false;
        }
        for (let i = 0; i < this.consequents.length; i++) {
          if (!this.consequents[i].equals(other.consequents[i])) {
            return false;
          }
        }
        if (this.catchall && other.catchall) {
          return this.catchall.equals(other.catchall);
        } else if (this.catchall || other.catchall) {
          return false;
        }
        return true;
      }
      return false;
    }
  }

  // Scheme chapter 2

  /**
   * A node representing a Scheme list or dotted list.
   */
  export class List implements Expression {
    location: Location;
    elements: Expression[];
    terminator: Expression | undefined;
    constructor(
      location: Location,
      elements: Expression[],
      terminator: Expression | undefined = undefined
    ) {
      this.location = location;
      this.elements = elements;
      this.terminator = terminator;
    }
    accept(visitor: Visitor): any {
      return visitor.visitList(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof List) {
        if (this.elements.length !== other.elements.length) {
          return false;
        }
        for (let i = 0; i < this.elements.length; i++) {
          if (!this.elements[i].equals(other.elements[i])) {
            return false;
          }
        }
        if (this.terminator && other.terminator) {
          return this.terminator.equals(other.terminator);
        } else if (this.terminator || other.terminator) {
          return false;
        }
        return true;
      }
      return false;
    }
  }

  // Scheme chapter 3

  /**
   * A node representing a Scheme begin expression.
   * Returns the last expression.
   * syntax: (begin <expression>*)
   */
  export class Begin implements Expression {
    location: Location;
    expressions: Expression[];
    constructor(location: Location, expressions: Expression[]) {
      this.location = location;
      this.expressions = expressions;
    }
    accept(visitor: Visitor): any {
      return visitor.visitBegin(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Begin) {
        if (this.expressions.length !== other.expressions.length) {
          return false;
        }
        for (let i = 0; i < this.expressions.length; i++) {
          if (!this.expressions[i].equals(other.expressions[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    }
  }

  /**
   * A node representing a Scheme delay expression.
   * Returns a promise.
   * syntax: (delay <expression>)
   */
  export class Delay implements Expression {
    location: Location;
    expression: Expression;
    constructor(location: Location, expression: Expression) {
      this.location = location;
      this.expression = expression;
    }
    accept(visitor: Visitor): any {
      return visitor.visitDelay(this);
    }
    equals(other: Expression): boolean {
      if (other instanceof Delay) {
        return this.expression.equals(other.expression);
      }
      return false;
    }
  }
}
</file>

<file path="src/scheme_parser/transpiler/types/tokens/__tests__/group.ts">
import { Token } from "../token";
import { TokenType } from "../token-type";
import { Group } from "../group";

// This test suite will test the Group class, in particular
// the build method that preserves the invariants of the Group class.
const dummyToken = new Token(
  TokenType.IDENTIFIER,
  "hello",
  "hello",
  1,
  1,
  1,
  1
);
const quoteToken = new Token(TokenType.APOSTROPHE, "'", "'", 1, 1, 1, 1);
const lParen = new Token(TokenType.LEFT_PAREN, "(", "(", 1, 1, 1, 1);
const rParen = new Token(TokenType.RIGHT_PAREN, ")", ")", 1, 1, 1, 1);
const rBracket = new Token(TokenType.RIGHT_BRACKET, "]", "]", 1, 1, 1, 1);

// we cannot test whether this works for internal groups yet, as
// we are testing the group constructor itself.
// we will test those scenarios later in these tests.

const invalidEmptyElements: any[] = [];
const validEmptyElements = [lParen, rParen];

const validNonParenElements = [dummyToken];
const invalidSingleElement = [lParen];
const invalidNonParenElements = [dummyToken, dummyToken];
const validAffectorElements = [quoteToken, dummyToken];
const invalidAffectorMoreElements = [quoteToken, dummyToken, dummyToken];
const invalidAffectorLessElements = [quoteToken];

const validParenElements = [lParen, dummyToken, dummyToken, rParen];
const invalidParenElements = [lParen, dummyToken, dummyToken, rBracket];

test("Group.build() should reject empty elements", () => {
  expect(() => Group.build(invalidEmptyElements)).toThrow();
});

test("Group.build() should accept an empty list", () => {
  expect(Group.build(validEmptyElements)).toBeInstanceOf(Group);
});

test("Group can be of singular unparenthesized element", () => {
  expect(Group.build(validNonParenElements)).toBeInstanceOf(Group);
});

test("Group of 1 singular element must be of data type", () => {
  expect(() => Group.build(invalidSingleElement)).toThrow();
});

test("Group cannot be larger than 1 element if not parenthesized and not affector group", () => {
  expect(() => Group.build(invalidNonParenElements)).toThrow();
});

test("Group can be of 2 elements if the first is an affector", () => {
  expect(Group.build(validAffectorElements)).toBeInstanceOf(Group);
});

test("Group cannot be of more than 2 elements if affector group", () => {
  expect(() => Group.build(invalidAffectorMoreElements)).toThrow();
});

test("Group cannot be of less than 2 elements if affector group", () => {
  expect(() => Group.build(invalidAffectorLessElements)).toThrow();
});

test("Group can be of more than 2 elements if parenthesized", () => {
  expect(Group.build(validParenElements)).toBeInstanceOf(Group);
});

test("Parenthesized group must have matching parentheses", () => {
  expect(() => Group.build(invalidParenElements)).toThrow();
});

test("Group.build() should avoid nested singular groups", () => {
  const nestedGroup = Group.build(validParenElements);
  const singleGroup = Group.build([nestedGroup]);
  expect(singleGroup).toBe(nestedGroup);
});
</file>

<file path="src/scheme_parser/transpiler/types/tokens/datum.ts">
/**
 *  A datum is a token or a group of tokens.
 *  Each datum represents a single element of the syntax tree.
 */
import { Token } from "./token";
import { Group } from "./group";

export type Datum = Token | Group;
</file>

<file path="src/scheme_parser/transpiler/types/tokens/group.ts">
/**
 * A group of elements, possibly bounded by parentheses.
 * Represents a group of related elements.
 */
import { Token } from "./token";
import { TokenType } from "./token-type";
import { Location, Position } from "../location";
import { Datum } from "./datum";
import { isGroup, isToken } from ".";
import { ExpectedFormError } from "../../parser/parser-error";

export class Group {
  // Invariants:
  // - A group must not be empty (ie no tokens at all).
  // - If a group is not parenthesized, it contains either one element, that is not a group,
  //   or two elements, of which the first one is not a group.
  // - If a group is parenthesized, it must have matching parentheses.
  readonly elements: Datum[];
  readonly location: Location;
  private constructor(elements: Datum[]) {
    this.elements = elements;
    this.location = new Location(this.firstPos(), this.lastPos());
  }

  /**
   * A constructor function for a group that enforces group invariants.
   */
  public static build(elements: Datum[]) {
    // helper function to check if the parentheses match.
    function matchingParentheses(lParen: Token, rParen: Token) {
      return (
        (lParen.type === TokenType.LEFT_PAREN &&
          rParen.type === TokenType.RIGHT_PAREN) ||
        (lParen.type === TokenType.LEFT_BRACKET &&
          rParen.type === TokenType.RIGHT_BRACKET)
      );
    }

    // helper function to check if the token is a data type.
    function isDataType(token: Token) {
      return (
        token.type === TokenType.IDENTIFIER ||
        token.type === TokenType.NUMBER ||
        token.type === TokenType.STRING ||
        token.type === TokenType.BOOLEAN
      );
    }

    // helper function to determine if the token is an affector type.
    // (and the affector type should be the short version).
    function isShortAffector(token: Token) {
      return (
        token.type === TokenType.APOSTROPHE ||
        token.type === TokenType.BACKTICK ||
        token.type === TokenType.HASH_VECTOR ||
        token.type === TokenType.COMMA ||
        token.type === TokenType.COMMA_AT
      );
    }

    // Illegal empty group.
    if (elements.length === 0) {
      // This should never happen.
      // If it does its the implementor's fault.
      throw new Error("Illegal empty group. This should never happen.");
    }
    // If the group is not parenthesized, the first case contains only one element.
    if (elements.length === 1) {
      const onlyElement: Datum = elements[0];

      if (isGroup(onlyElement)) {
        // Return the inner group.
        // Avoid nested groups that are a product of the grouping generation in the parser.
        // Ensures the single internal element is not a group.
        return onlyElement;
      }

      // Ensure the single element is a data type by validating its token type.
      if (!isDataType(onlyElement)) {
        // This should never happen.
        // If it does its the implementor's fault.
        throw new ExpectedFormError("", onlyElement.pos, onlyElement, "<data>");
      }

      return new Group(elements);
    }

    // If the group is not parenthesized, the remaining case contains two elements.
    if (elements.length === 2) {
      const firstElement = elements[0];

      // Ensure the first element is an affector type and
      if (isToken(firstElement) && isShortAffector(firstElement)) {
        return new Group(elements);
      }

      // If all else fails, use the most generic case below.
    }

    // If the group is parenthesized, the parentheses must match.
    const firstElement = elements[0];
    const lastElement = elements[elements.length - 1];
    if (
      isToken(firstElement) &&
      isToken(lastElement) &&
      matchingParentheses(firstElement, lastElement)
    ) {
      return new Group(elements);
    }

    // This should never happen.
    const wrongGroup = new Group(elements);
    throw new ExpectedFormError(
      "",
      wrongGroup.location.start,
      wrongGroup,
      "matching parentheses"
    );
  }

  // Get the first element of the group.
  first(): Datum {
    return this.elements[0];
  }

  // Get the first token of the group.
  public firstToken(): Token {
    const firstElement = this.first();
    if (isToken(firstElement)) {
      return firstElement;
    } else {
      return firstElement.firstToken();
    }
  }

  // Get the starting position of the first element of the group.
  firstPos(): Position {
    return this.firstToken().pos;
  }

  // Get the last element of the group.
  last(): Datum {
    return this.elements[this.elements.length - 1];
  }

  lastToken(): Token {
    const lastElement = this.last();
    if (isToken(lastElement)) {
      return lastElement;
    } else {
      return lastElement.lastToken();
    }
  }

  // Get the ending position of the last element of the group.
  lastPos(): Position {
    return this.lastToken().pos;
  }

  /**
   * Check if the current group is parenthesized.
   */
  public isParenthesized(): boolean {
    const firstElement = this.first();

    // Because of the validation performed by the factory function,
    // we can assume that as long as the first element is a paranthesis,
    // the last element is also the corresponding paranthesis.
    return (
      isToken(firstElement) &&
      (firstElement.type === TokenType.LEFT_PAREN ||
        firstElement.type === TokenType.LEFT_BRACKET)
    );
  }

  /**
   * Using the invariants, we can determine if a group actually
   * represents a singular identifier.
   */
  public isSingleIdentifier(): boolean {
    return !this.isParenthesized() && this.length() === 1;
  }

  /**
   * Get the internal elements of the group.
   * If the group is bounded by parentheses, the parentheses are excluded.
   * @returns All elements of the group excluding parentheses.
   */
  public unwrap(): Datum[] {
    if (this.isParenthesized()) {
      return this.elements.slice(1, this.elements.length - 1);
    }
    return this.elements;
  }

  /**
   * Get the number of elements in the group.
   * Ignores parentheses.
   * @returns The number of elements in the group.
   */
  public length(): number {
    return this.unwrap().length;
  }

  /**
   * @returns A string representation of the group
   */
  toString(): string {
    return this.elements.map(e => e.toString()).join(" ");
  }
}
</file>

<file path="src/scheme_parser/transpiler/types/tokens/index.ts">
import { Datum } from "./datum";
import { Group } from "./group";
import { Token } from "./token";

export { Token } from "./token";
export { TokenType } from "./token-type";
export { Group } from "./group";
export { Datum } from "./datum";

export function isToken(datum: Datum): datum is Token {
  return datum instanceof Token;
}

export function isGroup(datum: Datum): datum is Group {
  return datum instanceof Group;
}
</file>

<file path="src/scheme_parser/transpiler/types/tokens/token-type.ts">
// Adapted from https://craftinginterpreters.com/scanning.html
// Adapted for Scheme use

export enum TokenType {
  // + - * / % ^ ! = < > & | ~ etc are recognized as IDENTIFIERS

  // S-expression syntax
  LEFT_PAREN,
  RIGHT_PAREN,
  LEFT_BRACKET,
  RIGHT_BRACKET,
  DOT,

  // Datum comments
  HASH_SEMICOLON,

  // Atoms: Literals or Identifiers
  IDENTIFIER,
  NUMBER,
  BOOLEAN,
  STRING,

  // SICP Chapter 1
  IF,
  LET,
  COND,
  ELSE,
  DEFINE,
  LAMBDA,

  // SICP Chapter 2
  APOSTROPHE, // Quote
  BACKTICK, // Quasiquote
  COMMA, // Unquote
  COMMA_AT, // Unquote-splicing
  QUOTE,
  QUASIQUOTE,
  UNQUOTE,
  UNQUOTE_SPLICING,

  // SICP Chapter 3
  SET,
  BEGIN,
  DELAY,

  // Other important keywords
  IMPORT,
  EXPORT,

  // keywords associated with macros
  DEFINE_SYNTAX,
  SYNTAX_RULES,

  // Not in scope at the moment
  HASH_VECTOR, // vector
  VECTOR, // depreciated, as i believe
  // turning vector into a procedure call is better
  EOF,
}
</file>

<file path="src/scheme_parser/transpiler/types/tokens/token.ts">
/**
 * A data structure representing a particular token.
 */

import { Position } from "../location";
import { TokenType } from ".";

export class Token {
  type: TokenType;
  lexeme: string;
  literal: any;
  start: number;
  end: number;
  pos: Position;
  endPos: Position;

  constructor(
    type: TokenType,
    lexeme: any,
    literal: any,
    start: number,
    end: number,
    line: number,
    col: number
  ) {
    this.type = type;
    this.lexeme = lexeme;
    this.literal = literal;
    this.start = start;
    this.end = end;
    this.pos = new Position(line, col);
    this.endPos = new Position(line, col + lexeme.length - 1);
  }

  /**
   * Converts a token to another representation of itself.
   * Especially useful for quotation tokens.
   * @returns A converted token.
   */
  public convertToken(): Token {
    switch (this.type) {
      case TokenType.APOSTROPHE:
        return new Token(
          TokenType.QUOTE,
          this.lexeme,
          this.literal,
          this.start,
          this.end,
          this.pos.line,
          this.pos.column
        );
      case TokenType.BACKTICK:
        return new Token(
          TokenType.QUASIQUOTE,
          this.lexeme,
          this.literal,
          this.start,
          this.end,
          this.pos.line,
          this.pos.column
        );
      case TokenType.HASH_VECTOR:
        return new Token(
          TokenType.VECTOR,
          this.lexeme,
          this.literal,
          this.start,
          this.end,
          this.pos.line,
          this.pos.column
        );
      case TokenType.COMMA:
        return new Token(
          TokenType.UNQUOTE,
          this.lexeme,
          this.literal,
          this.start,
          this.end,
          this.pos.line,
          this.pos.column
        );
      case TokenType.COMMA_AT:
        return new Token(
          TokenType.UNQUOTE_SPLICING,
          this.lexeme,
          this.literal,
          this.start,
          this.end,
          this.pos.line,
          this.pos.column
        );
      default:
        return this;
    }
  }

  /**
   * For debugging.
   * @returns A string representation of the token.
   */
  public toString(): string {
    return `${this.lexeme}`;
  }
}
</file>

<file path="src/scheme_parser/transpiler/types/constants.ts">
// The chapters of the parser.

export const BASIC_CHAPTER = 1;
export const QUOTING_CHAPTER = 2;
export const VECTOR_CHAPTER = 3;
export const MUTABLE_CHAPTER = 3;
export const MACRO_CHAPTER = 5;
</file>

<file path="src/scheme_parser/transpiler/types/location.ts">
// A data structure representing the span of the scheme node.
export class Location {
  constructor(
    public start: Position,
    public end: Position
  ) {}

  merge(other: Location): Location {
    return new Location(this.start, other.end);
  }
}

// A data structure representing a particular position of a token.
export class Position {
  constructor(
    public line: number,
    public column: number
  ) {}
}
</file>

<file path="src/scheme_parser/transpiler/visitors/index.ts">
/**
 * This file is used to export all the visitors used.
 */

export { Visitor } from "./visitor";
export { Transpiler } from "./transpiler";
export { Simplifier } from "./simplifier";
export { Redefiner } from "./redefiner";
export { Printer } from "./printer";
</file>

<file path="src/scheme_parser/transpiler/visitors/printer.ts">
import { Visitor } from ".";
import { Atomic, Extended } from "../types/nodes/scheme-node-types";

/**
 * Visitor implementation that prints the AST.
 */
export class Printer implements Visitor {
  indentationLevel: number;

  constructor(indentationLevel: number) {
    this.indentationLevel = indentationLevel;
  }

  // Factory method for creating a new Printer instance.
  public static create(): Printer {
    // Since the entire AST is wrapped in a sequence node, we start with an indentation level of 0.
    // Sequences increment the indentation level by 1.
    return new Printer(0);
  }

  increment(): Printer {
    this.indentationLevel += 1;
    return this;
  }

  decrement(): Printer {
    this.indentationLevel -= 1;
    return this;
  }

  indent(): void {
    process.stdout.write(" ".repeat(this.indentationLevel * 0));
  }

  display(value: any): void {
    process.stdout.write(value);
  }

  // Atomic AST
  visitSequence(node: Atomic.Sequence): void {
    this.indent();
    const indentedPrinter = this.increment();
    node.expressions.forEach(expression => {
      this.indent();
      expression.accept(indentedPrinter);
      this.display("\n");
    });
    this.decrement();
    this.indent();
  }

  visitNumericLiteral(node: Atomic.NumericLiteral): void {
    //   this.indent();
    this.display(node.value.toString());
  }

  visitBooleanLiteral(node: Atomic.BooleanLiteral): void {
    //   this.indent();
    this.display(node.value.toString());
  }

  visitStringLiteral(node: Atomic.StringLiteral): void {
    //   this.indent();
    this.display(node.value);
  }

  visitLambda(node: Atomic.Lambda): void {
    //   this.indent();
    this.display("( lambda ");
    this.display("( ");
    node.params.forEach(parameter => {
      parameter.accept(this.increment());
      this.display(" ");
    });
    if (node.rest) {
      this.display(". ");
      node.rest.accept(this);
    }
    this.display(") ");
    node.body.accept(this.increment());
    this.decrement();
    this.indent();
    this.display(") ");
  }
  visitIdentifier(node: Atomic.Identifier): any {
    this.display(node.name);
  }
  visitDefinition(node: Atomic.Definition): any {
    // this.indent();
    this.display("( define ");
    node.name.accept(this.increment());
    this.display(" ");
    node.value.accept(this.increment());
    this.display(") ");
  }

  visitApplication(node: Atomic.Application): any {
    // this.indent();
    this.display("( ");
    node.operator.accept(this.increment());
    node.operands.forEach(operand => {
      this.display(" ");
      operand.accept(this.increment());
    });
    this.display(") ");
  }

  visitConditional(node: Atomic.Conditional): any {
    // this.indent();
    this.display("( if ");
    node.test.accept(this.increment());
    this.display(" ");
    node.consequent.accept(this.increment());
    this.display(" ");
    node.alternate.accept(this.increment());
    this.display(")");
  }

  visitPair(node: Atomic.Pair): any {
    // this.indent();
    this.display("( cons ");
    node.car.accept(this.increment());
    this.display(" ");
    node.cdr.accept(this.increment());
    this.display(")");
  }
  visitNil(node: Atomic.Nil): any {
    // this.indent();
    this.display("()");
  }

  visitSymbol(node: Atomic.Symbol): any {
    // this.indent();
    this.display(node.value);
  }

  visitSpliceMarker(node: Atomic.SpliceMarker): any {
    // this.indent();
    this.display(",@");
    this.display(node.value);
    this.display(" ");
  }

  visitReassignment(node: Atomic.Reassignment): any {
    // this.indent();
    this.display("( set! ");
    node.name.accept(this.increment());
    node.value.accept(this.increment());
    this.display(")");
  }

  visitImport(node: Atomic.Import): any {
    throw new Error("Method not implemented.");
  }
  visitExport(node: Atomic.Export): any {
    throw new Error("Method not implemented.");
  }
  visitVector(node: Atomic.Vector) {
    // this.indent();
    this.display("#( ");
    node.elements.forEach(element => {
      this.display(" ");
      element.accept(this.increment());
    });
    this.display(") ");
  }

  // Extended AST
  visitFunctionDefinition(node: Extended.FunctionDefinition): any {
    // this.indent();
    this.display("( define ");
    this.display("( ");
    node.name.accept(this);
    this.display(" ");
    node.params.forEach(parameter => {
      parameter.accept(this.increment());
      this.display(" ");
    });
    if (node.rest) {
      this.display(". ");
      node.rest.accept(this);
    }
    this.display(") ");
    this.display("\n");
    node.body.accept(this.increment());
    this.display(") ");
  }

  visitLet(node: Extended.Let): any {
    throw new Error("Method not implemented.");
  }

  visitCond(node: Extended.Cond): any {
    throw new Error("Method not implemented.");
  }

  visitList(node: Extended.List): any {
    // this.indent();
    this.display("( list ");
    node.elements.forEach(value => {
      this.display(" ");
      value.accept(this.increment());
    });
    if (node.terminator) {
      node.terminator.accept(this);
    }
    this.display(") ");
  }

  visitBegin(node: Extended.Begin): any {
    // this.indent();
    this.display("( begin ");
    node.expressions.forEach(expression => {
      this.display(" ");
      expression.accept(this.increment());
    });
    this.display(") ");
  }

  visitDelay(node: Extended.Delay): any {
    // this.indent();
    this.display("( delay ");
    node.expression.accept(this.increment());
    this.display(") ");
  }

  visitDefineSyntax(node: Atomic.DefineSyntax) {
    // this.indent();
    this.display("( define-syntax ");
    node.name.accept(this.increment());
    this.display(" ");
    node.transformer.accept(this.increment());
    this.display(") ");
  }

  visitSyntaxRules(node: Atomic.SyntaxRules) {
    // this.indent();
    this.display("( syntax-rules ");
    this.display("( ");
    node.literals.forEach(literal => {
      literal.accept(this.increment());
      this.display(" ");
    });
    this.display(") ");
    node.rules.forEach(rule => {
      this.display("\n");
      this.display("( ");
      rule[0].accept(this.increment());
      this.display(" ");
      rule[1].accept(this.increment());
      this.display(") ");
    });
    this.display(") ");
  }
}
</file>

<file path="src/scheme_parser/transpiler/visitors/redefiner.ts">
/**
 * A visitor that evaluates all definitions in a Scheme AST.
 * If several redefinitions are made, they are converted to reassignments.
 * Required to play nice with JavaScript's scoping rules.
 */

import { Expression, Atomic, Extended } from "../types/nodes/scheme-node-types";
import { Visitor } from ".";

export class Redefiner implements Visitor {
  // Factory method for creating a new Redefiner instance.
  public static create(): Redefiner {
    return new Redefiner();
  }

  redefineScope(scope: Expression[]): Expression[] {
    const names = new Set<string>();
    const newScope = scope.map(expression => {
      if (expression instanceof Atomic.Definition) {
        const exprName = expression.name.name;
        if (names.has(exprName)) {
          return new Atomic.Reassignment(
            expression.location,
            expression.name,
            expression.value
          );
        }
        names.add(exprName);
      }
      return expression;
    });
    return newScope;
  }

  public redefine(nodes: Expression[]): Expression[] {
    // recursivly redefine the scope of the nodes
    // then work directly on the new nodes
    const newNodes = nodes.map(node => node.accept(this));
    return this.redefineScope(newNodes);
  }

  // Atomic AST
  visitSequence(node: Atomic.Sequence): Atomic.Sequence {
    const location = node.location;
    const newExpressions = node.expressions.map(expression =>
      expression.accept(this)
    );
    return new Atomic.Sequence(location, this.redefineScope(newExpressions));
  }

  visitNumericLiteral(node: Atomic.NumericLiteral): Atomic.NumericLiteral {
    return node;
  }

  visitBooleanLiteral(node: Atomic.BooleanLiteral): Atomic.BooleanLiteral {
    return node;
  }

  visitStringLiteral(node: Atomic.StringLiteral): Atomic.StringLiteral {
    return node;
  }

  visitLambda(node: Atomic.Lambda): Atomic.Lambda {
    const location = node.location;
    const params = node.params;
    const rest = node.rest;
    const newBody = node.body.accept(this);

    return new Atomic.Lambda(location, newBody, params, rest);
  }

  visitIdentifier(node: Atomic.Identifier): Atomic.Identifier {
    return node;
  }

  visitDefinition(node: Atomic.Definition): Atomic.Definition {
    const location = node.location;
    const name = node.name;
    const newValue = node.value.accept(this);

    return new Atomic.Definition(location, name, newValue);
  }

  visitApplication(node: Atomic.Application): Atomic.Application {
    const location = node.location;
    const newOperator = node.operator.accept(this);
    const newOperands = node.operands.map(operand => operand.accept(this));

    return new Atomic.Application(location, newOperator, newOperands);
  }

  visitConditional(node: Atomic.Conditional): Atomic.Conditional {
    const location = node.location;
    const newTest = node.test.accept(this);
    const newConsequent = node.consequent.accept(this);
    const newAlternate = node.alternate.accept(this);

    return new Atomic.Conditional(
      location,
      newTest,
      newConsequent,
      newAlternate
    );
  }

  visitPair(node: Atomic.Pair): Atomic.Pair {
    const location = node.location;
    const newCar = node.car.accept(this);
    const newCdr = node.cdr.accept(this);

    return new Atomic.Pair(location, newCar, newCdr);
  }

  visitNil(node: Atomic.Nil): Atomic.Nil {
    return node;
  }

  visitSymbol(node: Atomic.Symbol): Atomic.Symbol {
    return node;
  }

  visitSpliceMarker(node: Atomic.SpliceMarker) {
    const location = node.location;
    const newValue = node.value.accept(this);

    return new Atomic.SpliceMarker(location, newValue);
  }

  visitReassignment(node: Atomic.Reassignment): Atomic.Reassignment {
    const location = node.location;
    const name = node.name;
    const newValue = node.value.accept(this);

    return new Atomic.Reassignment(location, name, newValue);
  }

  // Already in simplest form.
  visitImport(node: Atomic.Import): Atomic.Import {
    return node;
  }

  visitExport(node: Atomic.Export): Atomic.Export {
    const location = node.location;
    const newDefinition = node.definition.accept(this);

    return new Atomic.Export(location, newDefinition);
  }

  visitVector(node: Atomic.Vector) {
    const location = node.location;

    // Simplify the elements of the vector
    const newElements = node.elements.map(element => element.accept(this));

    return new Atomic.Vector(location, newElements);
  }

  // Extended AST
  visitFunctionDefinition(
    node: Extended.FunctionDefinition
  ): Extended.FunctionDefinition {
    const location = node.location;
    const name = node.name;
    const params = node.params;
    const rest = node.rest;
    const newBody = node.body.accept(this);

    return new Extended.FunctionDefinition(
      location,
      name,
      newBody,
      params,
      rest
    );
  }

  visitLet(node: Extended.Let): Extended.Let {
    const location = node.location;
    const identifiers = node.identifiers;
    const newValues = node.values.map(value => value.accept(this));
    const newBody = node.body.accept(this);

    return new Extended.Let(location, identifiers, newValues, newBody);
  }

  visitCond(node: Extended.Cond): Extended.Cond {
    const location = node.location;
    const newPredicates = node.predicates.map(predicate =>
      predicate.accept(this)
    );
    const newConsequents = node.consequents.map(consequent =>
      consequent.accept(this)
    );
    const newCatchall = node.catchall
      ? node.catchall.accept(this)
      : node.catchall;
    return new Extended.Cond(
      location,
      newPredicates,
      newConsequents,
      newCatchall
    );
  }

  visitList(node: Extended.List): Extended.List {
    const location = node.location;
    const newElements = node.elements.map(element => element.accept(this));
    const newTerminator = node.terminator
      ? node.terminator.accept(this)
      : undefined;
    return new Extended.List(location, newElements, newTerminator);
  }

  visitBegin(node: Extended.Begin): Extended.Begin {
    const location = node.location;
    const newExpressions = node.expressions.map(expression =>
      expression.accept(this)
    );

    return new Extended.Begin(location, this.redefineScope(newExpressions));
  }

  visitDelay(node: Extended.Delay): Extended.Delay {
    const location = node.location;
    const newBody = node.expression.accept(this);

    return new Extended.Delay(location, newBody);
  }

  // there are no redefinitions in the following nodes.
  visitDefineSyntax(node: Atomic.DefineSyntax) {
    return node;
  }

  visitSyntaxRules(node: Atomic.SyntaxRules) {
    return node;
  }
}
</file>

<file path="src/scheme_parser/transpiler/visitors/simplifier.ts">
/**
 * A visitor that transforms all "extended AST" nodes into "atomic AST" nodes.
 * Except for everything inside a quote, which is left alone.
 *
 * It also does double work by "flattening" begin nodes whenever possible, to allow definitions
 * to be visible outside the begin structure (since begins don't have their own scope).
 */

import { Expression, Atomic, Extended } from "../types/nodes/scheme-node-types";
import { Location } from "../types/location";
import { Visitor } from ".";

// a function that takes an expression and returns an array of expressions
// we will use this to "remove" the begin node whenever possible by returning its expressions
// this is useful when the begin is in a sequence, to allow its side effects to be visible
// outside the begin block
function flattenBegin(ex: Expression): Expression[] {
  if (!(ex instanceof Extended.Begin)) {
    return [ex];
  }

  const beginExpressions = ex.expressions;

  // these expressions may themselves contain begin nodes
  // that need to be flattened
  return beginExpressions.flatMap(flattenBegin);
}

export class Simplifier implements Visitor {
  // Factory method for creating a new Simplifier instance.
  public static create(): Simplifier {
    return new Simplifier();
  }

  public simplify(node: Expression[]): Expression[] {
    const flattenedExpressions = node.flatMap(flattenBegin);
    return flattenedExpressions.map(expression => expression.accept(this));
  }

  // Atomic AST
  visitSequence(node: Atomic.Sequence): Atomic.Sequence {
    const location = node.location;
    const flattenedExpressions = node.expressions.flatMap(flattenBegin);
    const newExpressions = flattenedExpressions.map(expression =>
      expression.accept(this)
    );
    return new Atomic.Sequence(location, newExpressions);
  }

  visitNumericLiteral(node: Atomic.NumericLiteral): Atomic.NumericLiteral {
    return node;
  }

  visitBooleanLiteral(node: Atomic.BooleanLiteral): Atomic.BooleanLiteral {
    return node;
  }

  visitStringLiteral(node: Atomic.StringLiteral): Atomic.StringLiteral {
    return node;
  }

  visitLambda(node: Atomic.Lambda): Atomic.Lambda {
    const location = node.location;
    const params = node.params;
    const rest = node.rest;
    const newBody = node.body.accept(this);

    return new Atomic.Lambda(location, newBody, params, rest);
  }

  visitIdentifier(node: Atomic.Identifier): Atomic.Identifier {
    return node;
  }

  visitDefinition(node: Atomic.Definition): Atomic.Definition {
    const location = node.location;
    const name = node.name;
    const newValue = node.value.accept(this);

    return new Atomic.Definition(location, name, newValue);
  }

  visitApplication(node: Atomic.Application): Atomic.Application {
    const location = node.location;
    const newOperator = node.operator.accept(this);
    const newOperands = node.operands.map(operand => operand.accept(this));

    return new Atomic.Application(location, newOperator, newOperands);
  }

  visitConditional(node: Atomic.Conditional): Atomic.Conditional {
    const location = node.location;
    const newTest = node.test.accept(this);
    const newConsequent = node.consequent.accept(this);
    const newAlternate = node.alternate.accept(this);

    return new Atomic.Conditional(
      location,
      newTest,
      newConsequent,
      newAlternate
    );
  }

  visitPair(node: Atomic.Pair): Atomic.Pair {
    const location = node.location;
    const newCar = node.car.accept(this);
    const newCdr = node.cdr.accept(this);

    return new Atomic.Pair(location, newCar, newCdr);
  }

  visitNil(node: Atomic.Nil): Atomic.Nil {
    return node;
  }

  visitSymbol(node: Atomic.Symbol): Atomic.Symbol {
    return node;
  }

  visitSpliceMarker(node: Atomic.SpliceMarker) {
    const location = node.location;
    const newValue = node.value.accept(this);

    return new Atomic.SpliceMarker(location, newValue);
  }

  visitReassignment(node: Atomic.Reassignment): Atomic.Reassignment {
    const location = node.location;
    const name = node.name;
    const newValue = node.value.accept(this);

    return new Atomic.Reassignment(location, name, newValue);
  }

  // Already in simplest form.
  visitImport(node: Atomic.Import): Atomic.Import {
    return node;
  }

  visitExport(node: Atomic.Export): Atomic.Export {
    const location = node.location;
    const newDefinition = node.definition.accept(this);

    return new Atomic.Export(location, newDefinition);
  }

  visitVector(node: Atomic.Vector) {
    const location = node.location;

    // Simplify the elements of the vector
    const newElements = node.elements.map(element => element.accept(this));

    return new Atomic.Vector(location, newElements);
  }

  // Extended AST
  visitFunctionDefinition(
    node: Extended.FunctionDefinition
  ): Atomic.Definition {
    const location = node.location;
    const name = node.name;
    const params = node.params;
    const rest = node.rest;
    const newBody = node.body.accept(this);

    const newLambda = new Atomic.Lambda(location, newBody, params, rest);
    return new Atomic.Definition(location, name, newLambda);
  }

  visitLet(node: Extended.Let): Atomic.Application {
    const location = node.location;
    const identifiers = node.identifiers;
    const newValues = node.values.map(value => value.accept(this));
    const newBody = node.body.accept(this);

    const newLambda = new Atomic.Lambda(location, newBody, identifiers);
    return new Atomic.Application(location, newLambda, newValues);
  }

  visitCond(node: Extended.Cond): Expression {
    const location = node.location;
    const newPredicates = node.predicates.map(predicate =>
      predicate.accept(this)
    );
    const newConsequents = node.consequents.map(consequent =>
      consequent.accept(this)
    );
    const newCatchall = node.catchall
      ? node.catchall.accept(this)
      : node.catchall;

    if (newPredicates.length == 0) {
      // Return catchall if there is no predicate
      return new Atomic.Conditional(
        location,
        new Atomic.BooleanLiteral(location, false),
        new Atomic.Nil(location),
        node.catchall ? newCatchall : new Atomic.Nil(location)
      );
    }

    newPredicates.reverse();
    newConsequents.reverse();
    const lastLocation = newPredicates[0].location;
    let newConditional = newCatchall
      ? newCatchall
      : new Atomic.Nil(lastLocation);

    for (let i = 0; i < newPredicates.length; i++) {
      const predicate = newPredicates[i];
      const consequent = newConsequents[i];
      const predLocation = predicate.location;
      const consLocation = consequent.location;
      const newLocation = new Location(predLocation.start, consLocation.end);
      newConditional = new Atomic.Conditional(
        newLocation,
        predicate,
        consequent,
        newConditional
      );
    }

    return newConditional;
  }

  // we will keep list as it is useful in its current state.
  visitList(node: Extended.List): Expression {
    const location = node.location;
    const newElements = node.elements.map(element => element.accept(this));
    const newTerminator = node.terminator
      ? node.terminator.accept(this)
      : undefined;
    return new Extended.List(location, newElements, newTerminator);
  }

  // these begins are not located at the top level, or in sequences,
  // so they have been left alone
  // they are used as ways to sequence expressions locally instead
  visitBegin(node: Extended.Begin): Atomic.Sequence {
    const location = node.location;
    const flattenedExpressions = node.expressions.flatMap(flattenBegin);
    const newExpressions = flattenedExpressions.map(expression =>
      expression.accept(this)
    );

    return new Atomic.Sequence(location, newExpressions);
  }

  // we transform delay into a call expression of "make-promise"
  visitDelay(node: Extended.Delay): Atomic.Application {
    const location = node.location;
    const newBody = node.expression.accept(this);
    const delayedLambda = new Atomic.Lambda(location, newBody, []);
    const makePromise = new Atomic.Identifier(location, "make-promise");
    return new Atomic.Application(location, makePromise, [delayedLambda]);
  }

  // these nodes are already in their simplest form
  visitDefineSyntax(node: Atomic.DefineSyntax) {
    return node;
  }

  visitSyntaxRules(node: Atomic.SyntaxRules) {
    return node;
  }
}
</file>

<file path="src/scheme_parser/transpiler/visitors/transpiler.ts">
/**
 * The final transpiler visitor.
 * Takes in expressions, yields es.Node[], so we can flatmap into a final program
 */

import * as es from "estree";
import * as estreeBuilder from "../../utils/estree-nodes";
import {
  Atomic,
  Extended,
  Expression as scmExpression,
} from "../types/nodes/scheme-node-types";
import { Visitor } from ".";

// helper functions

function isExpression(node: es.Node): node is es.Expression {
  return !node.type.includes("Statement") && !node.type.includes("Declaration");
}

function wrapInRest(param: es.Identifier): es.RestElement {
  return estreeBuilder.makeRestElement(param);
}

function wrapInStatement(expression: es.Expression): es.ExpressionStatement {
  return estreeBuilder.makeExpressionStatement(expression);
}

function wrapInReturn(expression: es.Expression): es.ReturnStatement {
  return estreeBuilder.makeReturnStatement(expression) as es.ReturnStatement;
}

export class Transpiler implements Visitor {
  public static create(): Transpiler {
    return new Transpiler();
  }

  public transpile(program: scmExpression[]): es.Program {
    // create an array of expressions
    const expressions = program.flatMap(e => e.accept(this));

    // then create an array of statements
    const statements = expressions.map(e =>
      isExpression(e) ? wrapInStatement(e) : e
    );

    // then wrap the whole thing in a program
    return estreeBuilder.makeProgram(statements);
  }
  // Atomic AST

  // iife
  visitSequence(node: Atomic.Sequence): [es.CallExpression] {
    const expressions = node.expressions.flatMap(e => e.accept(this));

    // wrap each expression into an expression statement if required
    const statements = expressions.map(e =>
      isExpression(e) ? wrapInStatement(e) : e
    );

    // promote the last expression to a return statement
    const lastExpression: es.Statement = statements.at(-1);

    // if the last expression is not something that emits an expression,
    // the sequence should return undefined
    if (lastExpression.type !== "ExpressionStatement") {
      statements.push(
        // always remember that undefined is an identifier
        wrapInStatement(
          estreeBuilder.makeIdentifier("undefined", node.location)
        )
      );
    } else {
      // if the last expression is an expression statement, we should promote it to a return statement
      statements[statements.length - 1] = wrapInReturn(
        lastExpression.expression
      );
    }

    // turn the statements into a block
    const body = estreeBuilder.makeBlockStatement(statements);

    // make the call expression
    const iife = estreeBuilder.makeCallExpression(
      estreeBuilder.makeArrowFunctionExpression([], body, node.location),
      [],
      node.location
    );

    // if other parts of the program want to optimize their code, eliminating
    // the iife sequence, they can see that this is a sequence with this flag
    (iife as any).isSequence = true;
    return [iife];
  }

  // literals
  visitNumericLiteral(node: Atomic.NumericLiteral): [es.CallExpression] {
    // we need to wrap the number in a call to make-number
    const makeNumber = estreeBuilder.makeIdentifier(
      "make_number",
      node.location
    );
    // we turn the number into a literal
    const number = estreeBuilder.makeLiteral(node.value, node.location);
    return [
      estreeBuilder.makeCallExpression(makeNumber, [number], node.location),
    ];
  }

  visitBooleanLiteral(node: Atomic.BooleanLiteral): [es.Literal] {
    return [estreeBuilder.makeLiteral(node.value, node.location)];
  }

  visitStringLiteral(node: Atomic.StringLiteral): [es.Literal] {
    return [estreeBuilder.makeLiteral(node.value, node.location)];
  }

  visitLambda(node: Atomic.Lambda): [es.ArrowFunctionExpression] {
    const parameters: any[] = node.params.flatMap(p => p.accept(this));
    const [fnBody] = node.body.accept(this);

    // if the inner body is a sequence, we can optimize it by removing the sequence
    // and making the arrow function expression return the last expression
    // we left a flag in the sequence to indicate that it is an iife
    let finalBody = (fnBody as any).isSequence
      ? // then we know that body is a sequence, stored as a call expression to an
        // inner callee with an interior arrow function expression that takes no arguments
        // let's steal that arrow function expression's body and use it as ours
        fnBody.callee.body
      : fnBody;

    if (!node.rest) {
      return [
        estreeBuilder.makeArrowFunctionExpression(
          parameters,
          finalBody,
          node.location
        ),
      ];
    }

    // there is a rest parameter to deal with

    const [restParameter] = node.rest.accept(this);
    // wrap it in a restElement
    const restElement = wrapInRest(restParameter);
    parameters.push(restElement);

    // place an implicit vector-to-list conversion around the rest parameter
    // this is to ensure that the rest parameter is always a list
    const vectorToList = estreeBuilder.makeIdentifier(
      "vector->list",
      node.location
    );

    // we make a call to it with the rest parameter as the argument
    const restParameterConversion = estreeBuilder.makeCallExpression(
      vectorToList,
      [restParameter],
      node.location
    );

    // then we reassign the rest parameter to the result of the call
    const restParameterAssignment = estreeBuilder.makeAssignmentExpression(
      restParameter,
      restParameterConversion,
      node.location
    );

    // then we inject it into the final body
    if (finalBody.type === "BlockStatement") {
      finalBody.body.unshift(wrapInStatement(restParameterAssignment));
      return [
        estreeBuilder.makeArrowFunctionExpression(
          parameters,
          finalBody,
          node.location
        ),
      ];
    }

    // otherwise, we need to wrap the final body in a block statement
    // and then inject the vectorToList call
    finalBody = estreeBuilder.makeBlockStatement([
      wrapInStatement(restParameterAssignment),
      wrapInReturn(finalBody),
    ]);

    return [
      estreeBuilder.makeArrowFunctionExpression(
        parameters,
        finalBody,
        node.location
      ),
    ];
  }

  // identifiers
  visitIdentifier(node: Atomic.Identifier): [es.Identifier] {
    return [estreeBuilder.makeIdentifier(node.name, node.location)];
  }

  // make a verifier that prevents this from being part of an
  // expression context
  // turns into statement
  visitDefinition(node: Atomic.Definition): [es.VariableDeclaration] {
    const [value] = node.value.accept(this);
    const [id] = node.name.accept(this);
    return [estreeBuilder.makeDeclaration("let", id, value, node.location)];
  }

  // expressions
  visitApplication(node: Atomic.Application): [es.CallExpression] {
    const [operator] = node.operator.accept(this);
    const operands = node.operands.flatMap(o => o.accept(this));
    return [
      estreeBuilder.makeCallExpression(operator, operands, node.location),
    ];
  }

  visitConditional(node: Atomic.Conditional): [es.ConditionalExpression] {
    const [test] = node.test.accept(this);
    // scheme's truthiness is different from javascript's,
    // and so we must use a custom truthiness function truthy to evaluate the test
    const truthy = estreeBuilder.makeIdentifier("truthy", node.location);
    const schemeTest = estreeBuilder.makeCallExpression(
      truthy,
      [test],
      node.location
    );
    const [consequent] = node.consequent.accept(this);
    const [alternate] = node.alternate.accept(this);
    return [
      estreeBuilder.makeConditionalExpression(
        schemeTest,
        consequent,
        alternate,
        node.location
      ),
    ];
  }

  // pair represented using cons call
  visitPair(node: Atomic.Pair): [es.CallExpression] {
    const [car] = node.car.accept(this);
    const [cdr] = node.cdr.accept(this);

    // construct the callee, cons, by hand
    const cons = estreeBuilder.makeIdentifier("cons", node.location);

    return [estreeBuilder.makeCallExpression(cons, [car, cdr], node.location)];
  }
  visitNil(node: Atomic.Nil): [es.Literal] {
    return [estreeBuilder.makeLiteral(null, node.location)];
  }

  // generate symbols with string->symbol call
  visitSymbol(node: Atomic.Symbol): [es.CallExpression] {
    // take the string out of the symbol value
    const str = estreeBuilder.makeLiteral(node.value, node.location);
    const stringToSymbol = estreeBuilder.makeIdentifier(
      "string->symbol",
      node.location
    );

    return [
      estreeBuilder.makeCallExpression(stringToSymbol, [str], node.location),
    ];
  }

  // we are assured that this marker will always exist within a list context.
  // leave a splice marker in the list that will be removed by a runtime
  // call to eval-splice on a list
  visitSpliceMarker(node: Atomic.SpliceMarker): [es.CallExpression] {
    const [expr] = node.value.accept(this);

    const makeSplice = estreeBuilder.makeIdentifier(
      "make-splice",
      node.location
    );

    return [estreeBuilder.makeCallExpression(makeSplice, expr, node.location)];
  }

  // turns into expression that returns assigned value
  // maybe in the future we can make a setall! macro
  visitReassignment(node: Atomic.Reassignment): [es.AssignmentExpression] {
    const [left] = node.name.accept(this);
    const [right] = node.value.accept(this);

    return [estreeBuilder.makeAssignmentExpression(left, right, node.location)];
  }

  // make a verifier that keeps these top level
  // and separate from nodes
  visitImport(node: Atomic.Import): (es.Statement | es.ModuleDeclaration)[] {
    // first we make the importDeclaration
    const newIdentifiers = node.identifiers.flatMap(i => i.accept(this));
    const mappedIdentifierNames = newIdentifiers.map(i => {
      const copy = Object.assign({}, i);
      copy.name = "imported" + copy.name;
      return copy;
    });

    const makeSpecifiers = (
      importeds: es.Identifier[],
      locals: es.Identifier[]
    ) =>
      importeds.map((imported: es.Identifier, i: number) =>
        // safe to cast as we are assured all source locations are present
        estreeBuilder.makeImportSpecifier(
          imported,
          locals[i],
          imported.loc as es.SourceLocation
        )
      );

    const specifiers = makeSpecifiers(newIdentifiers, mappedIdentifierNames);

    const [source] = node.source.accept(this);

    const importDeclaration = estreeBuilder.makeImportDeclaration(
      specifiers,
      source,
      node.location
    );

    // then for each imported function, we define their proper
    // names with definitions

    const makeRedefinitions = (
      importeds: es.Identifier[],
      locals: es.Identifier[]
    ) =>
      importeds.flatMap((imported: es.Identifier, i: number) =>
        estreeBuilder.makeDeclaration(
          "let",
          imported,
          locals[i],
          // we are assured that all source locations are present
          imported.loc as es.SourceLocation
        )
      );

    const redefinitions = makeRedefinitions(
      newIdentifiers,
      mappedIdentifierNames
    );

    return [importDeclaration, ...redefinitions];
  }

  visitExport(node: Atomic.Export): [es.ModuleDeclaration] {
    const [newDefinition] = node.definition.accept(this);
    return [
      estreeBuilder.makeExportNamedDeclaration(newDefinition, node.location),
    ];
  }

  // turn into an array
  visitVector(node: Atomic.Vector): [es.ArrayExpression] {
    const newElements = node.elements.flatMap(e => e.accept(this));
    return [estreeBuilder.makeArrayExpression(newElements, node.location)];
  }

  // Extended AST

  // this is in the extended AST, but useful enough to keep.
  visitList(node: Extended.List): [es.CallExpression] {
    const newElements = node.elements.flatMap(e => e.accept(this));
    const [newTerminator] = node.terminator
      ? node.terminator.accept(this)
      : [undefined];
    if (newTerminator) {
      // cons* or list* produces dotted lists
      // we prefer list* here as it explicitly describes the
      // construction of an improper list - the word LIST
      const dottedList = estreeBuilder.makeIdentifier("list*", node.location);
      return [
        estreeBuilder.makeCallExpression(
          dottedList,
          [...newElements, newTerminator],
          node.location
        ),
      ];
    }

    // a proper list
    const list = estreeBuilder.makeIdentifier("list", node.location);

    return [estreeBuilder.makeCallExpression(list, newElements, node.location)];
  }

  // if any of these are called, its an error. the simplifier
  // should be called first.
  visitFunctionDefinition(
    node: Extended.FunctionDefinition
  ): [es.VariableDeclaration] {
    throw new Error("The AST should be simplified!");
  }
  visitLet(node: Extended.Let): [es.CallExpression] {
    throw new Error("The AST should be simplified!");
  }
  visitCond(node: Extended.Cond): [es.ConditionalExpression] {
    throw new Error("The AST should be simplified!");
  }
  visitBegin(node: Extended.Begin): [es.CallExpression] {
    throw new Error("The AST should be simplified!");
  }
  visitDelay(node: Extended.Delay): [es.ArrowFunctionExpression] {
    throw new Error("The AST should be simplified!");
  }
  visitDefineSyntax(node: Atomic.DefineSyntax) {
    throw new Error("This should not be called!");
  }
  visitSyntaxRules(node: Atomic.SyntaxRules) {
    throw new Error("This should not be called!");
  }
}
</file>

<file path="src/scheme_parser/transpiler/visitors/visitor.ts">
/**
 * Visitor interface for the AST.
 * Allows us to traverse the AST and perform operations on it.
 */

import { Atomic, Extended } from "../types/nodes/scheme-node-types";

export interface Visitor {
  // Atomic AST
  visitSequence(node: Atomic.Sequence): any;

  visitNumericLiteral(node: Atomic.NumericLiteral): any;
  visitBooleanLiteral(node: Atomic.BooleanLiteral): any;
  visitStringLiteral(node: Atomic.StringLiteral): any;
  visitLambda(node: Atomic.Lambda): any;

  visitIdentifier(node: Atomic.Identifier): any;
  visitDefinition(node: Atomic.Definition): any;

  visitApplication(node: Atomic.Application): any;
  visitConditional(node: Atomic.Conditional): any;

  visitPair(node: Atomic.Pair): any;
  visitNil(node: Atomic.Nil): any;
  visitSymbol(node: Atomic.Symbol): any;
  visitSpliceMarker(node: Atomic.SpliceMarker): any;

  visitReassignment(node: Atomic.Reassignment): any;

  visitImport(node: Atomic.Import): any;
  visitExport(node: Atomic.Export): any;

  visitVector(node: Atomic.Vector): any;

  visitSyntaxRules(node: Atomic.SyntaxRules): any;
  visitDefineSyntax(node: Atomic.DefineSyntax): any;

  // Extended AST
  visitFunctionDefinition(node: Extended.FunctionDefinition): any;
  visitLet(node: Extended.Let): any;
  visitCond(node: Extended.Cond): any;

  visitList(node: Extended.List): any;

  visitBegin(node: Extended.Begin): any;
  visitDelay(node: Extended.Delay): any;
}
</file>

<file path="src/scheme_parser/transpiler/index.ts">
/**
 * The main entry point of the scheme transpiler.
 */

import { SchemeLexer } from "./lexer";
import { SchemeParser } from "./parser";
import { Atomic, Expression, Extended } from "./types/nodes/scheme-node-types";
import { Program } from "estree";

import { Simplifier, Transpiler, Redefiner } from "./visitors";
import { estreeEncode } from "..";
import { MACRO_CHAPTER } from "./types/constants";

export { LexerError } from "./lexer";
export { ParserError } from "./parser";

/**
 * wrap an s-expression in an eval call.
 */
function wrapInEval(body: Expression): Expression {
  const evalObj = new Atomic.Identifier(body.location, "eval");
  return new Atomic.Application(body.location, evalObj, [body]);
}

/**
 * wrap an s-expression in a begin statement.
 * since we want an s-expression as return,
 * begin is represented as a list of expressions starting with "begin".
 */
function wrapInBegin(expressions: Expression[]): Expression {
  // use the total location of the first and last expressions
  const dummyloc = expressions[0].location.merge(
    expressions[expressions.length - 1].location
  );
  const begin = new Atomic.Symbol(dummyloc, "begin");
  return new Extended.List(dummyloc, [begin, ...expressions]);
}

/**
 * Transpiles Scheme source code into an ESTree program.
 * @param source The Scheme source code
 * @param chapter The chapter of the Scheme language.
 *                If not provided, defaults to the latest version.
 * @returns
 */
export function schemeParse(
  source: string,
  chapter: number = Infinity,
  encode?: boolean
): Program {
  // Instantiate the lexer
  const lexer = new SchemeLexer(source);

  // Generate tokens
  const tokens = lexer.scanTokens();

  // Instantiate the parser
  const parser = new SchemeParser(source, tokens, chapter);

  // The Scheme AST is represented as an
  // array of expressions, which is all top-level expressions

  let finalAST: Expression[];

  // Generate the first AST
  const firstAST: Expression[] = parser.parse();

  // We instantiate all the visitors
  const simplifier = Simplifier.create();
  const redefiner = Redefiner.create();
  const transpiler = Transpiler.create();

  if (chapter < MACRO_CHAPTER) {
    // Then we simplify the AST
    const simplifiedAST: Expression[] = simplifier.simplify(firstAST);

    // Then we redefine the AST
    const redefinedAST: Expression[] = redefiner.redefine(simplifiedAST);

    finalAST = redefinedAST;
  } else {
    // Then we prepare the AST for evaluation within the CSET machine.
    // Take the imports from the AST
    const macroASTImports: Expression[] = firstAST.filter(
      e => e instanceof Atomic.Import
    );
    const macroASTRest: Expression[] = firstAST.filter(
      e => !(e instanceof Atomic.Import)
    );

    // On the rest elements,
    // 1. If empty, do nothing
    // 2. If 1 element, wrap in eval call
    // 3. If more than one element, sequence as one begin statement, then wrap in eval call
    const macroASTformattedRest: Expression[] =
      macroASTRest.length === 0
        ? []
        : macroASTRest.length === 1
          ? [wrapInEval(macroASTRest[0])]
          : [wrapInEval(wrapInBegin(macroASTRest))];

    // Concatenate the imports and the rest
    finalAST = [...macroASTImports, ...macroASTformattedRest];
  }

  // Finally we transpile the AST
  const program: Program = transpiler.transpile(finalAST);

  return encode ? (estreeEncode(program) as Program) : program;
}
</file>

<file path="src/scheme_parser/utils/encoder-visitor.ts">
import * as es from "estree";
import { decode, encode } from "..";
const walk = require("acorn-walk");

// A function to modify all names in the estree program.
// Prevents any name collisions with JS keywords and invalid characters.
export function estreeEncode(ast: es.Node): es.Node {
  walk.full(ast, (node: es.Node) => {
    if ((node as any).encoded === true) {
      return;
    }
    if (node.type === "Identifier") {
      node.name = encode(node.name);
      // ensures the conversion is only done once
      (node as any).encoded = true;
    }
  });
  walk.full(ast, (node: es.Node) => {
    (node as any).encoded = undefined;
  });
  return ast;
}

export function estreeDecode(ast: es.Node): es.Node {
  walk.full(ast, (node: es.Node) => {
    if ((node as any).decoded === true) {
      return;
    }
    if (node.type === "Identifier") {
      node.name = decode(node.name);
      // ensures the conversion is only done once
      (node as any).decoded = true;
    }
  });
  walk.full(ast, (node: es.Node) => {
    (node as any).decoded = undefined;
  });
  return ast;
}
</file>

<file path="src/scheme_parser/utils/reverse_parser.ts">
import * as es from "estree";

export function unparse(node: es.Node): string {
  //if ((node as any)?.hidden) return "";
  switch (node.type) {
    case "Identifier":
      return node.name;

    case "Literal":
      return node.raw!;

    case "CallExpression":
      const callee = unparse(node.callee);
      const args = node.arguments.map(unparse).join(" ");
      return `(${callee} ${args})`;

    case "ArrayExpression":
      const elements = node.elements.map(s => unparse(s as any)).join(" ");
      return `(vector ${elements})`;

    case "ArrowFunctionExpression":
      const params = node.params.map(unparse).join(" ");
      const body = unparse(node.body);
      return `(lambda (${params}) ${body})`;

    case "RestElement":
      return `. ${unparse(node.argument!)}`;

    case "BlockStatement":
      const statements = node.body.map(unparse).join(" ");
      return `(begin ${statements})`;

    case "ReturnStatement":
      const argument = unparse(node.argument!);
      return argument;

    case "VariableDeclaration":
      const id = unparse(node.declarations[0].id);
      const init = unparse(node.declarations[0].init!);
      return `(define ${id} ${init})`;

    case "ExpressionStatement":
      return unparse(node.expression);

    case "AssignmentExpression":
      const left = unparse(node.left);
      const right = unparse(node.right);
      return `(set! ${left} ${right})`;

    case "ConditionalExpression":
      const test = unparse(node.test);
      const consequent = unparse(node.consequent);
      const alternate = unparse(node.alternate);
      return `(if ${test} ${consequent} ${alternate})`;

    case "Program":
      return node.body.map(unparse).join("\n");

    case "ImportDeclaration":
      const identifiers = node.specifiers.map(unparse).join(" ");
      const source = unparse(node.source);
      return `(import (${source} ${identifiers}))`;

    case "ExportNamedDeclaration":
      const definition = unparse(node.declaration!);
      return `(export ${definition})`;

    default:
      throw new Error(`Unparsing for node type ${node.type} not implemented`);
  }
}
</file>

<file path="src/scheme_parser/compile-libs.ts">
import path from "path";
import fs from "fs";
import { schemeParse } from "./transpiler";
import { estreeEncode } from "./utils/encoder-visitor";
const escodegen = require("escodegen");

function transpile(inputFilePath: string, outputFilePath: string) {
  fs.readFile(inputFilePath, "utf8", (err, data) => {
    if (err) {
      console.error(`Error reading file: ${err}`);
      return;
    }

    // we transpile the file
    const transpiledAST = schemeParse(data);
    const encodedAST = estreeEncode(transpiledAST);
    const transpiledProgram = escodegen.generate(encodedAST);

    fs.writeFile(outputFilePath, transpiledProgram, err => {
      if (err) {
        console.error(`Error writing file: ${err}`);
        return;
      }
      console.log(`${inputFilePath} has been transpiled to ${outputFilePath}`);
    });
  });
}

// get file paths from command line arguments
const inputFilePath: string = process.argv[2];
const outputFilePath: string = process.argv[3]
  ? process.argv[3]
  : inputFilePath.replace(".scm", ".js");

// validate file paths
if (!inputFilePath) {
  console.error("Please provide an input file path and an output file path");
}

if (!(path.extname(inputFilePath) === ".scm")) {
  console.error("Please provide a .scm file for compilation!");
}

// if everything is fine, we transpile the file
transpile(inputFilePath, outputFilePath);
</file>

<file path="src/scheme_parser/index.ts">
import { encode as b64Encode, decode as b64Decode } from "js-base64";

export * from "./utils/encoder-visitor";
export { unparse } from "./utils/reverse_parser";
export { LexerError } from "./transpiler";
export { ParserError } from "./transpiler";
export { schemeParse } from "./transpiler";

const JS_KEYWORDS: string[] = [
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  "enum",
  "await",
  "implements",
  "package",
  "protected",
  "static",
  "interface",
  "private",
  "public",
];

/**
 * Takes a Scheme identifier and encodes it to follow JS naming conventions.
 *
 * @param identifier An identifier name.
 * @returns An encoded identifier that follows JS naming conventions.
 */
export function encode(identifier: string): string {
  if (JS_KEYWORDS.includes(identifier) || identifier.startsWith("$scheme_")) {
    return (
      "$scheme_" +
      b64Encode(identifier).replace(
        /([^a-zA-Z0-9_])/g,
        (match: string) => `\$${match.charCodeAt(0)}\$`
      )
    );
  } else {
    return identifier.replace(
      /([^a-zA-Z0-9_])/g,
      (match: string) => `\$${match.charCodeAt(0)}\$`
    );
  }
}

/**
 * Takes a JS identifier and decodes it to follow Scheme naming conventions.
 *
 * @param identifier An encoded identifier name.
 * @returns A decoded identifier that follows Scheme naming conventions.
 */
export function decode(identifier: string): string {
  if (identifier.startsWith("$scheme_")) {
    return b64Decode(
      identifier
        .slice(8)
        .replace(/\$([0-9]+)\$/g, (_, code: string) =>
          String.fromCharCode(parseInt(code))
        )
    );
  } else {
    return identifier.replace(/\$([0-9]+)\$/g, (_, code: string) =>
      String.fromCharCode(parseInt(code))
    );
  }
}
</file>

<file path=".pnp.loader.mjs">
/* eslint-disable */
// @ts-nocheck

import fs from 'fs';
import { URL as URL$1, fileURLToPath, pathToFileURL } from 'url';
import path from 'path';
import { createHash } from 'crypto';
import { EOL } from 'os';
import esmModule, { createRequire, isBuiltin } from 'module';
import assert from 'assert';

const SAFE_TIME = 456789e3;

const PortablePath = {
  root: `/`,
  dot: `.`,
  parent: `..`
};
const npath = Object.create(path);
const ppath = Object.create(path.posix);
npath.cwd = () => process.cwd();
ppath.cwd = process.platform === `win32` ? () => toPortablePath(process.cwd()) : process.cwd;
if (process.platform === `win32`) {
  ppath.resolve = (...segments) => {
    if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
      return path.posix.resolve(...segments);
    } else {
      return path.posix.resolve(ppath.cwd(), ...segments);
    }
  };
}
const contains = function(pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to)
    return `.`;
  if (!from.endsWith(pathUtils.sep))
    from = from + pathUtils.sep;
  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};
npath.contains = (from, to) => contains(npath, from, to);
ppath.contains = (from, to) => contains(ppath, from, to);
const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\/\/(\.\/)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/;
function fromPortablePathWin32(p) {
  let portablePathMatch, uncPortablePathMatch;
  if (portablePathMatch = p.match(PORTABLE_PATH_REGEXP))
    p = portablePathMatch[1];
  else if (uncPortablePathMatch = p.match(UNC_PORTABLE_PATH_REGEXP))
    p = `\\\\${uncPortablePathMatch[1] ? `.\\` : ``}${uncPortablePathMatch[2]}`;
  else
    return p;
  return p.replace(/\//g, `\\`);
}
function toPortablePathWin32(p) {
  p = p.replace(/\\/g, `/`);
  let windowsPathMatch, uncWindowsPathMatch;
  if (windowsPathMatch = p.match(WINDOWS_PATH_REGEXP))
    p = `/${windowsPathMatch[1]}`;
  else if (uncWindowsPathMatch = p.match(UNC_WINDOWS_PATH_REGEXP))
    p = `/unc/${uncWindowsPathMatch[1] ? `.dot/` : ``}${uncWindowsPathMatch[2]}`;
  return p;
}
const toPortablePath = process.platform === `win32` ? toPortablePathWin32 : (p) => p;
const fromPortablePath = process.platform === `win32` ? fromPortablePathWin32 : (p) => p;
npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;
function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}

const defaultTime = new Date(SAFE_TIME * 1e3);
const defaultTimeMs = defaultTime.getTime();
async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : await sourceFs.lstatPromise(normalizedSource);
  await destinationFs.mkdirpPromise(destinationFs.pathUtils.dirname(destination), { utimes: [atime, mtime] });
  await copyImpl(prelayout, postlayout, destinationFs, normalizedDestination, sourceFs, normalizedSource, { ...opts, didParentExist: true });
  for (const operation of prelayout)
    await operation();
  await Promise.all(postlayout.map((operation) => {
    return operation();
  }));
}
async function copyImpl(prelayout, postlayout, destinationFs, destination, sourceFs, source, opts) {
  const destinationStat = opts.didParentExist ? await maybeLStat(destinationFs, destination) : null;
  const sourceStat = await sourceFs.lstatPromise(source);
  const { atime, mtime } = opts.stableTime ? { atime: defaultTime, mtime: defaultTime } : sourceStat;
  let updated;
  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isFile():
      {
        updated = await copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isSymbolicLink():
      {
        updated = await copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    default: {
      throw new Error(`Unsupported file type (${sourceStat.mode})`);
    }
  }
  if (opts.linkStrategy?.type !== `HardlinkFromIndex` || !sourceStat.isFile()) {
    if (updated || destinationStat?.mtime?.getTime() !== mtime.getTime() || destinationStat?.atime?.getTime() !== atime.getTime()) {
      postlayout.push(() => destinationFs.lutimesPromise(destination, atime, mtime));
      updated = true;
    }
    if (destinationStat === null || (destinationStat.mode & 511) !== (sourceStat.mode & 511)) {
      postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 511));
      updated = true;
    }
  }
  return updated;
}
async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}
async function copyFolder(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  let updated = false;
  if (destinationStat === null) {
    prelayout.push(async () => {
      try {
        await destinationFs.mkdirPromise(destination, { mode: sourceStat.mode });
      } catch (err) {
        if (err.code !== `EEXIST`) {
          throw err;
        }
      }
    });
    updated = true;
  }
  const entries = await sourceFs.readdirPromise(source);
  const nextOpts = opts.didParentExist && !destinationStat ? { ...opts, didParentExist: false } : opts;
  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async (entry) => {
      await copyImpl(prelayout, postlayout, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts);
    }));
    if (entriesUpdateStatus.some((status) => status)) {
      updated = true;
    }
  }
  return updated;
}
async function copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, linkStrategy) {
  const sourceHash = await sourceFs.checksumFilePromise(source, { algorithm: `sha1` });
  const defaultMode = 420;
  const sourceMode = sourceStat.mode & 511;
  const indexFileName = `${sourceHash}${sourceMode !== defaultMode ? sourceMode.toString(8) : ``}`;
  const indexPath = destinationFs.pathUtils.join(linkStrategy.indexPath, sourceHash.slice(0, 2), `${indexFileName}.dat`);
  let AtomicBehavior;
  ((AtomicBehavior2) => {
    AtomicBehavior2[AtomicBehavior2["Lock"] = 0] = "Lock";
    AtomicBehavior2[AtomicBehavior2["Rename"] = 1] = "Rename";
  })(AtomicBehavior || (AtomicBehavior = {}));
  let atomicBehavior = 1 /* Rename */;
  let indexStat = await maybeLStat(destinationFs, indexPath);
  if (destinationStat) {
    const isDestinationHardlinkedFromIndex = indexStat && destinationStat.dev === indexStat.dev && destinationStat.ino === indexStat.ino;
    const isIndexModified = indexStat?.mtimeMs !== defaultTimeMs;
    if (isDestinationHardlinkedFromIndex) {
      if (isIndexModified && linkStrategy.autoRepair) {
        atomicBehavior = 0 /* Lock */;
        indexStat = null;
      }
    }
    if (!isDestinationHardlinkedFromIndex) {
      if (opts.overwrite) {
        prelayout.push(async () => destinationFs.removePromise(destination));
        destinationStat = null;
      } else {
        return false;
      }
    }
  }
  const tempPath = !indexStat && atomicBehavior === 1 /* Rename */ ? `${indexPath}.${Math.floor(Math.random() * 4294967296).toString(16).padStart(8, `0`)}` : null;
  let tempPathCleaned = false;
  prelayout.push(async () => {
    if (!indexStat) {
      if (atomicBehavior === 0 /* Lock */) {
        await destinationFs.lockPromise(indexPath, async () => {
          const content = await sourceFs.readFilePromise(source);
          await destinationFs.writeFilePromise(indexPath, content);
        });
      }
      if (atomicBehavior === 1 /* Rename */ && tempPath) {
        const content = await sourceFs.readFilePromise(source);
        await destinationFs.writeFilePromise(tempPath, content);
        try {
          await destinationFs.linkPromise(tempPath, indexPath);
        } catch (err) {
          if (err.code === `EEXIST`) {
            tempPathCleaned = true;
            await destinationFs.unlinkPromise(tempPath);
          } else {
            throw err;
          }
        }
      }
    }
    if (!destinationStat) {
      await destinationFs.linkPromise(indexPath, destination);
    }
  });
  postlayout.push(async () => {
    if (!indexStat) {
      await destinationFs.lutimesPromise(indexPath, defaultTime, defaultTime);
      if (sourceMode !== defaultMode) {
        await destinationFs.chmodPromise(indexPath, sourceMode);
      }
    }
    if (tempPath && !tempPathCleaned) {
      await destinationFs.unlinkPromise(tempPath);
    }
  });
  return false;
}
async function copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    const content = await sourceFs.readFilePromise(source);
    await destinationFs.writeFilePromise(destination, content);
  });
  return true;
}
async function copyFile(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (opts.linkStrategy?.type === `HardlinkFromIndex`) {
    return copyFileViaIndex(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts, opts.linkStrategy);
  } else {
    return copyFileDirect(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
  }
}
async function copySymlink(prelayout, postlayout, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    await destinationFs.symlinkPromise(convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}

class FakeFS {
  pathUtils;
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }
  async *genTraversePromise(init, { stableSort = false } = {}) {
    const stack = [init];
    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);
      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);
        if (stableSort) {
          for (const entry2 of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry2));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }
  async checksumFilePromise(path, { algorithm = `sha512` } = {}) {
    const fd = await this.openPromise(path, `r`);
    try {
      const CHUNK_SIZE = 65536;
      const chunk = Buffer.allocUnsafeSlow(CHUNK_SIZE);
      const hash = createHash(algorithm);
      let bytesRead = 0;
      while ((bytesRead = await this.readPromise(fd, chunk, 0, CHUNK_SIZE)) !== 0)
        hash.update(bytesRead === CHUNK_SIZE ? chunk : chunk.slice(0, bytesRead));
      return hash.digest(`hex`);
    } finally {
      await this.closePromise(fd);
    }
  }
  async removePromise(p, { recursive = true, maxRetries = 5 } = {}) {
    let stat;
    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive) {
        const entries = await this.readdirPromise(p);
        await Promise.all(entries.map((entry) => {
          return this.removePromise(this.pathUtils.resolve(p, entry));
        }));
      }
      for (let t = 0; t <= maxRetries; t++) {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code !== `EBUSY` && error.code !== `ENOTEMPTY`) {
            throw error;
          } else if (t < maxRetries) {
            await new Promise((resolve) => setTimeout(resolve, t * 100));
          }
        }
      }
    } else {
      await this.unlinkPromise(p);
    }
  }
  removeSync(p, { recursive = true } = {}) {
    let stat;
    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive)
        for (const entry of this.readdirSync(p))
          this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }
  async mkdirpPromise(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ??= subPath;
        if (chmod != null)
          await this.chmodPromise(subPath, chmod);
        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  mkdirpSync(p, { chmod, utimes } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return void 0;
    const parts = p.split(this.pathUtils.sep);
    let createdDirectory;
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        createdDirectory ??= subPath;
        if (chmod != null)
          this.chmodSync(subPath, chmod);
        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
    return createdDirectory;
  }
  async copyPromise(destination, source, { baseFs = this, overwrite = true, stableSort = false, stableTime = false, linkStrategy = null } = {}) {
    return await copyPromise(this, destination, baseFs, source, { overwrite, stableSort, stableTime, linkStrategy });
  }
  copySync(destination, source, { baseFs = this, overwrite = true } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);
    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);
      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), { baseFs, overwrite });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }
    const mode = stat.mode & 511;
    this.chmodSync(destination, mode);
  }
  async changeFilePromise(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content, opts);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }
  async changeFileBufferPromise(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = await this.readFilePromise(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    await this.writeFilePromise(p, content, { mode });
  }
  async changeFileTextPromise(p, content, { automaticNewlines, mode } = {}) {
    let current = ``;
    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    await this.writeFilePromise(p, normalizedContent, { mode });
  }
  changeFileSync(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content, opts);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }
  changeFileBufferSync(p, content, { mode } = {}) {
    let current = Buffer.alloc(0);
    try {
      current = this.readFileSync(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    this.writeFileSync(p, content, { mode });
  }
  changeFileTextSync(p, content, { automaticNewlines = false, mode } = {}) {
    let current = ``;
    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    this.writeFileSync(p, normalizedContent, { mode });
  }
  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }
  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }
  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1e3 / 60;
    const startTime = Date.now();
    let fd = null;
    const isAlive = async () => {
      let pid;
      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        return Date.now() - startTime < 500;
      }
      try {
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };
    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!await isAlive()) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error2) {
            }
          }
          if (Date.now() - startTime < 60 * 1e3) {
            await new Promise((resolve) => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }
    await this.writePromise(fd, JSON.stringify([process.pid]));
    try {
      return await callback();
    } finally {
      try {
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {
      }
    }
  }
  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  async writeJsonPromise(p, data, { compact = false } = {}) {
    const space = compact ? 0 : 2;
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, space)}
`);
  }
  writeJsonSync(p, data, { compact = false } = {}) {
    const space = compact ? 0 : 2;
    return this.writeFileSync(p, `${JSON.stringify(data, null, space)}
`);
  }
  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
      p = result;
    await this.lutimesPromise(p, stat.atime, stat.mtime);
  }
  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`)
      p = result;
    this.lutimesSync(p, stat.atime, stat.mtime);
  }
}
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(ppath);
  }
}
function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null)
    return EOL;
  const crlf = matches.filter((nl) => nl === `\r
`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r
` : `
`;
}
function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}

class ProxiedFS extends FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }
  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }
  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }
  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), { path: p });
  }
  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), { path: p });
  }
  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }
  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }
  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }
  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }
  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }
  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }
  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }
  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }
  async statPromise(p, opts) {
    return this.baseFs.statPromise(this.mapToBase(p), opts);
  }
  statSync(p, opts) {
    return this.baseFs.statSync(this.mapToBase(p), opts);
  }
  async fstatPromise(fd, opts) {
    return this.baseFs.fstatPromise(fd, opts);
  }
  fstatSync(fd, opts) {
    return this.baseFs.fstatSync(fd, opts);
  }
  lstatPromise(p, opts) {
    return this.baseFs.lstatPromise(this.mapToBase(p), opts);
  }
  lstatSync(p, opts) {
    return this.baseFs.lstatSync(this.mapToBase(p), opts);
  }
  async fchmodPromise(fd, mask) {
    return this.baseFs.fchmodPromise(fd, mask);
  }
  fchmodSync(fd, mask) {
    return this.baseFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }
  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return this.baseFs.fchownPromise(fd, uid, gid);
  }
  fchownSync(fd, uid, gid) {
    return this.baseFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }
  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }
  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }
  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }
  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }
  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }
  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }
  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }
  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }
  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return this.baseFs.lutimesPromise(this.mapToBase(p), atime, mtime);
  }
  lutimesSync(p, atime, mtime) {
    return this.baseFs.lutimesSync(this.mapToBase(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }
  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }
  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }
  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }
  async rmPromise(p, opts) {
    return this.baseFs.rmPromise(this.mapToBase(p), opts);
  }
  rmSync(p, opts) {
    return this.baseFs.rmSync(this.mapToBase(p), opts);
  }
  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }
  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }
  async symlinkPromise(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkPromise(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkPromise(mappedTarget, mappedP, type);
  }
  symlinkSync(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkSync(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkSync(mappedTarget, mappedP, type);
  }
  async readFilePromise(p, encoding) {
    return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
  }
  readFileSync(p, encoding) {
    return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
  }
  readdirPromise(p, opts) {
    return this.baseFs.readdirPromise(this.mapToBase(p), opts);
  }
  readdirSync(p, opts) {
    return this.baseFs.readdirSync(this.mapToBase(p), opts);
  }
  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }
  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }
  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }
  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }
  async ftruncatePromise(fd, len) {
    return this.baseFs.ftruncatePromise(fd, len);
  }
  ftruncateSync(fd, len) {
    return this.baseFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.baseFs.watch(
      this.mapToBase(p),
      // @ts-expect-error
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.baseFs.watchFile(
      this.mapToBase(p),
      // @ts-expect-error
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }
  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }
}

function direntToPortable(dirent) {
  const portableDirent = dirent;
  if (typeof dirent.path === `string`)
    portableDirent.path = npath.toPortablePath(dirent.path);
  return portableDirent;
}
class NodeFS extends BasePortableFakeFS {
  realFs;
  constructor(realFs = fs) {
    super();
    this.realFs = realFs;
  }
  getExtractHint() {
    return false;
  }
  getRealPath() {
    return PortablePath.root;
  }
  resolve(p) {
    return ppath.resolve(p);
  }
  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }
  openSync(p, flags, mode) {
    return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then((dir) => {
      const dirWithFixedPath = dir;
      Object.defineProperty(dirWithFixedPath, `path`, {
        value: p,
        configurable: true,
        writable: true
      });
      return dirWithFixedPath;
    });
  }
  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(npath.fromPortablePath(p), opts) : this.realFs.opendirSync(npath.fromPortablePath(p));
    const dirWithFixedPath = dir;
    Object.defineProperty(dirWithFixedPath, `path`, {
      value: p,
      configurable: true,
      writable: true
    });
    return dirWithFixedPath;
  }
  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }
  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }
  closeSync(fd) {
    this.realFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }
  createWriteStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }
  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  realpathSync(p) {
    return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
  }
  async existsPromise(p) {
    return await new Promise((resolve) => {
      this.realFs.exists(npath.fromPortablePath(p), resolve);
    });
  }
  accessSync(p, mode) {
    return this.realFs.accessSync(npath.fromPortablePath(p), mode);
  }
  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }
  existsSync(p) {
    return this.realFs.existsSync(npath.fromPortablePath(p));
  }
  async statPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.stat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  statSync(p, opts) {
    if (opts) {
      return this.realFs.statSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.statSync(npath.fromPortablePath(p));
    }
  }
  async fstatPromise(fd, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.fstat(fd, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.fstat(fd, this.makeCallback(resolve, reject));
      }
    });
  }
  fstatSync(fd, opts) {
    if (opts) {
      return this.realFs.fstatSync(fd, opts);
    } else {
      return this.realFs.fstatSync(fd);
    }
  }
  async lstatPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.lstat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  lstatSync(p, opts) {
    if (opts) {
      return this.realFs.lstatSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.lstatSync(npath.fromPortablePath(p));
    }
  }
  async fchmodPromise(fd, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchmod(fd, mask, this.makeCallback(resolve, reject));
    });
  }
  fchmodSync(fd, mask) {
    return this.realFs.fchmodSync(fd, mask);
  }
  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }
  chmodSync(p, mask) {
    return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
  }
  async fchownPromise(fd, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.fchown(fd, uid, gid, this.makeCallback(resolve, reject));
    });
  }
  fchownSync(fd, uid, gid) {
    return this.realFs.fchownSync(fd, uid, gid);
  }
  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown(npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }
  chownSync(p, uid, gid) {
    return this.realFs.chownSync(npath.fromPortablePath(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  renameSync(oldP, newP) {
    return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }
  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }
  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }
  unlinkSync(p) {
    return this.realFs.unlinkSync(npath.fromPortablePath(p));
  }
  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async lutimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.lutimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  lutimesSync(p, atime, mtime) {
    this.realFs.lutimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }
  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
  }
  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.rmdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  rmdirSync(p, opts) {
    return this.realFs.rmdirSync(npath.fromPortablePath(p), opts);
  }
  async rmPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.rm(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rm(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  rmSync(p, opts) {
    return this.realFs.rmSync(npath.fromPortablePath(p), opts);
  }
  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link(npath.fromPortablePath(existingP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  linkSync(existingP, newP) {
    return this.realFs.linkSync(npath.fromPortablePath(existingP), npath.fromPortablePath(newP));
  }
  async symlinkPromise(target, p, type) {
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type, this.makeCallback(resolve, reject));
    });
  }
  symlinkSync(target, p, type) {
    return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type);
  }
  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }
  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }
  async readdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        if (opts.recursive && process.platform === `win32`) {
          if (opts.withFileTypes) {
            this.realFs.readdir(npath.fromPortablePath(p), opts, this.makeCallback((results) => resolve(results.map(direntToPortable)), reject));
          } else {
            this.realFs.readdir(npath.fromPortablePath(p), opts, this.makeCallback((results) => resolve(results.map(npath.toPortablePath)), reject));
          }
        } else {
          this.realFs.readdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
        }
      } else {
        this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  readdirSync(p, opts) {
    if (opts) {
      if (opts.recursive && process.platform === `win32`) {
        if (opts.withFileTypes) {
          return this.realFs.readdirSync(npath.fromPortablePath(p), opts).map(direntToPortable);
        } else {
          return this.realFs.readdirSync(npath.fromPortablePath(p), opts).map(npath.toPortablePath);
        }
      } else {
        return this.realFs.readdirSync(npath.fromPortablePath(p), opts);
      }
    } else {
      return this.realFs.readdirSync(npath.fromPortablePath(p));
    }
  }
  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  readlinkSync(p) {
    return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
  }
  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate(npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }
  truncateSync(p, len) {
    return this.realFs.truncateSync(npath.fromPortablePath(p), len);
  }
  async ftruncatePromise(fd, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.ftruncate(fd, len, this.makeCallback(resolve, reject));
    });
  }
  ftruncateSync(fd, len) {
    return this.realFs.ftruncateSync(fd, len);
  }
  watch(p, a, b) {
    return this.realFs.watch(
      npath.fromPortablePath(p),
      // @ts-expect-error
      a,
      b
    );
  }
  watchFile(p, a, b) {
    return this.realFs.watchFile(
      npath.fromPortablePath(p),
      // @ts-expect-error
      a,
      b
    );
  }
  unwatchFile(p, cb) {
    return this.realFs.unwatchFile(npath.fromPortablePath(p), cb);
  }
  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }
}

const NUMBER_REGEXP = /^[0-9]+$/;
const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends ProxiedFS {
  baseFs;
  static makeVirtualPath(base, component, to) {
    if (ppath.basename(base) !== `__virtual__`)
      throw new Error(`Assertion failed: Virtual folders must be named "__virtual__"`);
    if (!ppath.basename(component).match(VALID_COMPONENT))
      throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`);
    const target = ppath.relative(ppath.dirname(base), to);
    const segments = target.split(`/`);
    let depth = 0;
    while (depth < segments.length && segments[depth] === `..`)
      depth += 1;
    const finalSegments = segments.slice(depth);
    const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }
  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5])
      return p;
    const target = ppath.dirname(match[1]);
    if (!match[3] || !match[4])
      return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum)
      return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(ppath.join(target, backstep, subpath));
  }
  constructor({ baseFs = new NodeFS() } = {}) {
    super(ppath);
    this.baseFs = baseFs;
  }
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  getRealPath() {
    return this.baseFs.getRealPath();
  }
  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return this.baseFs.realpathSync(p);
    if (!match[5])
      return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return await this.baseFs.realpathPromise(p);
    if (!match[5])
      return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  mapToBase(p) {
    if (p === ``)
      return p;
    if (this.pathUtils.isAbsolute(p))
      return VirtualFS.resolveVirtual(p);
    const resolvedRoot = VirtualFS.resolveVirtual(this.baseFs.resolve(PortablePath.dot));
    const resolvedP = VirtualFS.resolveVirtual(this.baseFs.resolve(p));
    return ppath.relative(resolvedRoot, resolvedP) || PortablePath.dot;
  }
  mapFromBase(p) {
    return p;
  }
}

const URL = Number(process.versions.node.split('.', 1)[0]) < 20 ? URL$1 : globalThis.URL;

const [major, minor] = process.versions.node.split(`.`).map((value) => parseInt(value, 10));
const WATCH_MODE_MESSAGE_USES_ARRAYS = major > 19 || major === 19 && minor >= 2 || major === 18 && minor >= 13;
const HAS_LAZY_LOADED_TRANSLATORS = major === 20 && minor < 6 || major === 19 && minor >= 3;
const SUPPORTS_IMPORT_ATTRIBUTES = major >= 21 || major === 20 && minor >= 10 || major === 18 && minor >= 20;
const SUPPORTS_IMPORT_ATTRIBUTES_ONLY = major >= 22;

function readPackageScope(checkPath) {
  const rootSeparatorIndex = checkPath.indexOf(npath.sep);
  let separatorIndex;
  do {
    separatorIndex = checkPath.lastIndexOf(npath.sep);
    checkPath = checkPath.slice(0, separatorIndex);
    if (checkPath.endsWith(`${npath.sep}node_modules`))
      return false;
    const pjson = readPackage(checkPath + npath.sep);
    if (pjson) {
      return {
        data: pjson,
        path: checkPath
      };
    }
  } while (separatorIndex > rootSeparatorIndex);
  return false;
}
function readPackage(requestPath) {
  const jsonPath = npath.resolve(requestPath, `package.json`);
  if (!fs.existsSync(jsonPath))
    return null;
  return JSON.parse(fs.readFileSync(jsonPath, `utf8`));
}

async function tryReadFile$1(path2) {
  try {
    return await fs.promises.readFile(path2, `utf8`);
  } catch (error) {
    if (error.code === `ENOENT`)
      return null;
    throw error;
  }
}
function tryParseURL(str, base) {
  try {
    return new URL(str, base);
  } catch {
    return null;
  }
}
let entrypointPath = null;
function setEntrypointPath(file) {
  entrypointPath = file;
}
function getFileFormat(filepath) {
  const ext = path.extname(filepath);
  switch (ext) {
    case `.mjs`: {
      return `module`;
    }
    case `.cjs`: {
      return `commonjs`;
    }
    case `.wasm`: {
      throw new Error(
        `Unknown file extension ".wasm" for ${filepath}`
      );
    }
    case `.json`: {
      return `json`;
    }
    case `.js`: {
      const pkg = readPackageScope(filepath);
      if (!pkg)
        return `commonjs`;
      return pkg.data.type ?? `commonjs`;
    }
    default: {
      if (entrypointPath !== filepath)
        return null;
      const pkg = readPackageScope(filepath);
      if (!pkg)
        return `commonjs`;
      if (pkg.data.type === `module`)
        return null;
      return pkg.data.type ?? `commonjs`;
    }
  }
}

async function load$1(urlString, context, nextLoad) {
  const url = tryParseURL(urlString);
  if (url?.protocol !== `file:`)
    return nextLoad(urlString, context, nextLoad);
  const filePath = fileURLToPath(url);
  const format = getFileFormat(filePath);
  if (!format)
    return nextLoad(urlString, context, nextLoad);
  if (format === `json`) {
    if (SUPPORTS_IMPORT_ATTRIBUTES_ONLY) {
      if (context.importAttributes?.type !== `json`) {
        const err = new TypeError(`[ERR_IMPORT_ATTRIBUTE_MISSING]: Module "${urlString}" needs an import attribute of "type: json"`);
        err.code = `ERR_IMPORT_ATTRIBUTE_MISSING`;
        throw err;
      }
    } else {
      const type = `importAttributes` in context ? context.importAttributes?.type : context.importAssertions?.type;
      if (type !== `json`) {
        const err = new TypeError(`[ERR_IMPORT_ASSERTION_TYPE_MISSING]: Module "${urlString}" needs an import ${SUPPORTS_IMPORT_ATTRIBUTES ? `attribute` : `assertion`} of type "json"`);
        err.code = `ERR_IMPORT_ASSERTION_TYPE_MISSING`;
        throw err;
      }
    }
  }
  if (process.env.WATCH_REPORT_DEPENDENCIES && process.send) {
    const pathToSend = pathToFileURL(
      npath.fromPortablePath(
        VirtualFS.resolveVirtual(npath.toPortablePath(filePath))
      )
    ).href;
    process.send({
      "watch:import": WATCH_MODE_MESSAGE_USES_ARRAYS ? [pathToSend] : pathToSend
    });
  }
  return {
    format,
    source: format === `commonjs` ? void 0 : await fs.promises.readFile(filePath, `utf8`),
    shortCircuit: true
  };
}

const ArrayIsArray = Array.isArray;
const JSONStringify = JSON.stringify;
const ObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
const ObjectPrototypeHasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
const RegExpPrototypeExec = (obj, string) => RegExp.prototype.exec.call(obj, string);
const RegExpPrototypeSymbolReplace = (obj, ...rest) => RegExp.prototype[Symbol.replace].apply(obj, rest);
const StringPrototypeEndsWith = (str, ...rest) => String.prototype.endsWith.apply(str, rest);
const StringPrototypeIncludes = (str, ...rest) => String.prototype.includes.apply(str, rest);
const StringPrototypeLastIndexOf = (str, ...rest) => String.prototype.lastIndexOf.apply(str, rest);
const StringPrototypeIndexOf = (str, ...rest) => String.prototype.indexOf.apply(str, rest);
const StringPrototypeReplace = (str, ...rest) => String.prototype.replace.apply(str, rest);
const StringPrototypeSlice = (str, ...rest) => String.prototype.slice.apply(str, rest);
const StringPrototypeStartsWith = (str, ...rest) => String.prototype.startsWith.apply(str, rest);
const SafeMap = Map;
const JSONParse = JSON.parse;

function createErrorType(code, messageCreator, errorType) {
  return class extends errorType {
    constructor(...args) {
      super(messageCreator(...args));
      this.code = code;
      this.name = `${errorType.name} [${code}]`;
    }
  };
}
const ERR_PACKAGE_IMPORT_NOT_DEFINED = createErrorType(
  `ERR_PACKAGE_IMPORT_NOT_DEFINED`,
  (specifier, packagePath, base) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ``} imported from ${base}`;
  },
  TypeError
);
const ERR_INVALID_MODULE_SPECIFIER = createErrorType(
  `ERR_INVALID_MODULE_SPECIFIER`,
  (request, reason, base = void 0) => {
    return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ``}`;
  },
  TypeError
);
const ERR_INVALID_PACKAGE_TARGET = createErrorType(
  `ERR_INVALID_PACKAGE_TARGET`,
  (pkgPath, key, target, isImport = false, base = void 0) => {
    const relError = typeof target === `string` && !isImport && target.length && !StringPrototypeStartsWith(target, `./`);
    if (key === `.`) {
      assert(isImport === false);
      return `Invalid "exports" main target ${JSONStringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
    }
    return `Invalid "${isImport ? `imports` : `exports`}" target ${JSONStringify(
      target
    )} defined for '${key}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : ``}${relError ? `; targets must start with "./"` : ``}`;
  },
  Error
);
const ERR_INVALID_PACKAGE_CONFIG = createErrorType(
  `ERR_INVALID_PACKAGE_CONFIG`,
  (path, base, message) => {
    return `Invalid package config ${path}${base ? ` while importing ${base}` : ``}${message ? `. ${message}` : ``}`;
  },
  Error
);

function filterOwnProperties(source, keys) {
  const filtered = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (ObjectPrototypeHasOwnProperty(source, key)) {
      filtered[key] = source[key];
    }
  }
  return filtered;
}

const packageJSONCache = new SafeMap();
function getPackageConfig(path, specifier, base, readFileSyncFn) {
  const existing = packageJSONCache.get(path);
  if (existing !== void 0) {
    return existing;
  }
  const source = readFileSyncFn(path);
  if (source === void 0) {
    const packageConfig2 = {
      pjsonPath: path,
      exists: false,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    packageJSONCache.set(path, packageConfig2);
    return packageConfig2;
  }
  let packageJSON;
  try {
    packageJSON = JSONParse(source);
  } catch (error) {
    throw new ERR_INVALID_PACKAGE_CONFIG(
      path,
      (base ? `"${specifier}" from ` : "") + fileURLToPath(base || specifier),
      error.message
    );
  }
  let { imports, main, name, type } = filterOwnProperties(packageJSON, [
    "imports",
    "main",
    "name",
    "type"
  ]);
  const exports = ObjectPrototypeHasOwnProperty(packageJSON, "exports") ? packageJSON.exports : void 0;
  if (typeof imports !== "object" || imports === null) {
    imports = void 0;
  }
  if (typeof main !== "string") {
    main = void 0;
  }
  if (typeof name !== "string") {
    name = void 0;
  }
  if (type !== "module" && type !== "commonjs") {
    type = "none";
  }
  const packageConfig = {
    pjsonPath: path,
    exists: true,
    main,
    name,
    type,
    exports,
    imports
  };
  packageJSONCache.set(path, packageConfig);
  return packageConfig;
}
function getPackageScopeConfig(resolved, readFileSyncFn) {
  let packageJSONUrl = new URL("./package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (StringPrototypeEndsWith(packageJSONPath2, "node_modules/package.json")) {
      break;
    }
    const packageConfig2 = getPackageConfig(
      fileURLToPath(packageJSONUrl),
      resolved,
      void 0,
      readFileSyncFn
    );
    if (packageConfig2.exists) {
      return packageConfig2;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = fileURLToPath(packageJSONUrl);
  const packageConfig = {
    pjsonPath: packageJSONPath,
    exists: false,
    main: void 0,
    name: void 0,
    type: "none",
    exports: void 0,
    imports: void 0
  };
  packageJSONCache.set(packageJSONPath, packageConfig);
  return packageConfig;
}

function throwImportNotDefined(specifier, packageJSONUrl, base) {
  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJSONUrl && fileURLToPath(new URL(".", packageJSONUrl)),
    fileURLToPath(base)
  );
}
function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {
  const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath(packageJSONUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    subpath,
    reason,
    base && fileURLToPath(base)
  );
}
function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {
  if (typeof target === "object" && target !== null) {
    target = JSONStringify(target, null, "");
  } else {
    target = `${target}`;
  }
  throw new ERR_INVALID_PACKAGE_TARGET(
    fileURLToPath(new URL(".", packageJSONUrl)),
    subpath,
    target,
    internal,
    base && fileURLToPath(base)
  );
}
const invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
const patternRegEx = /\*/g;
function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (!StringPrototypeStartsWith(target, "./")) {
    if (internal && !StringPrototypeStartsWith(target, "../") && !StringPrototypeStartsWith(target, "/")) {
      let isURL = false;
      try {
        new URL(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace(patternRegEx, target, () => subpath) : target + subpath;
        return exportTarget;
      }
    }
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  }
  if (RegExpPrototypeExec(
    invalidSegmentRegEx,
    StringPrototypeSlice(target, 2)
  ) !== null)
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  const resolved = new URL(target, packageJSONUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL(".", packageJSONUrl).pathname;
  if (!StringPrototypeStartsWith(resolvedPath, packagePath))
    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
  if (subpath === "") return resolved;
  if (RegExpPrototypeExec(invalidSegmentRegEx, subpath) !== null) {
    const request = pattern ? StringPrototypeReplace(match, "*", () => subpath) : match + subpath;
    throwInvalidSubpath(request, packageJSONUrl, internal, base);
  }
  if (pattern) {
    return new URL(
      RegExpPrototypeSymbolReplace(patternRegEx, resolved.href, () => subpath)
    );
  }
  return new URL(subpath, resolved);
}
function isArrayIndex(key) {
  const keyNum = +key;
  if (`${keyNum}` !== key) return false;
  return keyNum >= 0 && keyNum < 4294967295;
}
function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJSONUrl,
      base,
      pattern,
      internal);
  } else if (ArrayIsArray(target)) {
    if (target.length === 0) {
      return null;
    }
    let lastException;
    for (let i = 0; i < target.length; i++) {
      const targetItem = target[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJSONUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
      } catch (e) {
        lastException = e;
        if (e.code === "ERR_INVALID_PACKAGE_TARGET") {
          continue;
        }
        throw e;
      }
      if (resolveResult === void 0) {
        continue;
      }
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null)
      return lastException;
    throw lastException;
  } else if (typeof target === "object" && target !== null) {
    const keys = ObjectGetOwnPropertyNames(target);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (isArrayIndex(key)) {
        throw new ERR_INVALID_PACKAGE_CONFIG(
          fileURLToPath(packageJSONUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === "default" || conditions.has(key)) {
        const conditionalTarget = target[key];
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          conditions
        );
        if (resolveResult === void 0) continue;
        return resolveResult;
      }
    }
    return void 0;
  } else if (target === null) {
    return null;
  }
  throwInvalidPackageTarget(
    packageSubpath,
    target,
    packageJSONUrl,
    internal,
    base
  );
}
function patternKeyCompare(a, b) {
  const aPatternIndex = StringPrototypeIndexOf(a, "*");
  const bPatternIndex = StringPrototypeIndexOf(b, "*");
  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLenA > baseLenB) return -1;
  if (baseLenB > baseLenA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a.length > b.length) return -1;
  if (b.length > a.length) return 1;
  return 0;
}
function packageImportsResolve({ name, base, conditions, readFileSyncFn }) {
  if (name === "#" || StringPrototypeStartsWith(name, "#/") || StringPrototypeEndsWith(name, "/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));
  }
  let packageJSONUrl;
  const packageConfig = getPackageScopeConfig(base, readFileSyncFn);
  if (packageConfig.exists) {
    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (ObjectPrototypeHasOwnProperty(imports, name) && !StringPrototypeIncludes(name, "*")) {
        const resolveResult = resolvePackageTarget(
          packageJSONUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          conditions
        );
        if (resolveResult != null) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath;
        const keys = ObjectGetOwnPropertyNames(imports);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const patternIndex = StringPrototypeIndexOf(key, "*");
          if (patternIndex !== -1 && StringPrototypeStartsWith(
            name,
            StringPrototypeSlice(key, 0, patternIndex)
          )) {
            const patternTrailer = StringPrototypeSlice(key, patternIndex + 1);
            if (name.length >= key.length && StringPrototypeEndsWith(name, patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && StringPrototypeLastIndexOf(key, "*") === patternIndex) {
              bestMatch = key;
              bestMatchSubpath = StringPrototypeSlice(
                name,
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJSONUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            conditions
          );
          if (resolveResult != null) {
            return resolveResult;
          }
        }
      }
    }
  }
  throwImportNotDefined(name, packageJSONUrl, base);
}

let findPnpApi = esmModule.findPnpApi;
if (!findPnpApi) {
  const require = createRequire(import.meta.url);
  const pnpApi = require(`./.pnp.cjs`);
  pnpApi.setup();
  findPnpApi = esmModule.findPnpApi;
}
const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:node:)?(?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
const isRelativeRegexp = /^\.{0,2}\//;
function tryReadFile(filePath) {
  try {
    return fs.readFileSync(filePath, `utf8`);
  } catch (err) {
    if (err.code === `ENOENT`)
      return void 0;
    throw err;
  }
}
async function resolvePrivateRequest(specifier, issuer, context, nextResolve) {
  const resolved = packageImportsResolve({
    name: specifier,
    base: pathToFileURL(issuer),
    conditions: new Set(context.conditions),
    readFileSyncFn: tryReadFile
  });
  if (resolved instanceof URL) {
    return { url: resolved.href, shortCircuit: true };
  } else {
    if (resolved.startsWith(`#`))
      throw new Error(`Mapping from one private import to another isn't allowed`);
    return resolve$1(resolved, context, nextResolve);
  }
}
async function resolve$1(originalSpecifier, context, nextResolve) {
  if (!findPnpApi || isBuiltin(originalSpecifier))
    return nextResolve(originalSpecifier, context, nextResolve);
  let specifier = originalSpecifier;
  const url = tryParseURL(specifier, isRelativeRegexp.test(specifier) ? context.parentURL : void 0);
  if (url) {
    if (url.protocol !== `file:`)
      return nextResolve(originalSpecifier, context, nextResolve);
    specifier = fileURLToPath(url);
  }
  const { parentURL, conditions = [] } = context;
  const issuer = parentURL && tryParseURL(parentURL)?.protocol === `file:` ? fileURLToPath(parentURL) : process.cwd();
  const pnpapi = findPnpApi(issuer) ?? (url ? findPnpApi(specifier) : null);
  if (!pnpapi)
    return nextResolve(originalSpecifier, context, nextResolve);
  if (specifier.startsWith(`#`))
    return resolvePrivateRequest(specifier, issuer, context, nextResolve);
  const dependencyNameMatch = specifier.match(pathRegExp);
  let allowLegacyResolve = false;
  if (dependencyNameMatch) {
    const [, dependencyName, subPath] = dependencyNameMatch;
    if (subPath === `` && dependencyName !== `pnpapi`) {
      const resolved = pnpapi.resolveToUnqualified(`${dependencyName}/package.json`, issuer);
      if (resolved) {
        const content = await tryReadFile$1(resolved);
        if (content) {
          const pkg = JSON.parse(content);
          allowLegacyResolve = pkg.exports == null;
        }
      }
    }
  }
  let result;
  try {
    result = pnpapi.resolveRequest(specifier, issuer, {
      conditions: new Set(conditions),
      // TODO: Handle --experimental-specifier-resolution=node
      extensions: allowLegacyResolve ? void 0 : []
    });
  } catch (err) {
    if (err instanceof Error && `code` in err && err.code === `MODULE_NOT_FOUND`)
      err.code = `ERR_MODULE_NOT_FOUND`;
    throw err;
  }
  if (!result)
    throw new Error(`Resolving '${specifier}' from '${issuer}' failed`);
  const resultURL = pathToFileURL(result);
  if (url) {
    resultURL.search = url.search;
    resultURL.hash = url.hash;
  }
  if (!parentURL)
    setEntrypointPath(fileURLToPath(resultURL));
  return {
    url: resultURL.href,
    shortCircuit: true
  };
}

if (!HAS_LAZY_LOADED_TRANSLATORS) {
  const binding = process.binding(`fs`);
  const originalReadFile = binding.readFileUtf8 || binding.readFileSync;
  if (originalReadFile) {
    binding[originalReadFile.name] = function(...args) {
      try {
        return fs.readFileSync(args[0], {
          encoding: `utf8`,
          // @ts-expect-error - The docs says it needs to be a string but
          // links to https://nodejs.org/dist/latest-v20.x/docs/api/fs.html#file-system-flags
          // which says it can be a number which matches the implementation.
          flag: args[1]
        });
      } catch {
      }
      return originalReadFile.apply(this, args);
    };
  } else {
    const binding2 = process.binding(`fs`);
    const originalfstat = binding2.fstat;
    const ZIP_MASK = 4278190080;
    const ZIP_MAGIC = 704643072;
    binding2.fstat = function(...args) {
      const [fd, useBigint, req] = args;
      if ((fd & ZIP_MASK) === ZIP_MAGIC && useBigint === false && req === void 0) {
        try {
          const stats = fs.fstatSync(fd);
          return new Float64Array([
            stats.dev,
            stats.mode,
            stats.nlink,
            stats.uid,
            stats.gid,
            stats.rdev,
            stats.blksize,
            stats.ino,
            stats.size,
            stats.blocks
            // atime sec
            // atime ns
            // mtime sec
            // mtime ns
            // ctime sec
            // ctime ns
            // birthtime sec
            // birthtime ns
          ]);
        } catch {
        }
      }
      return originalfstat.apply(this, args);
    };
  }
}

const resolve = resolve$1;
const load = load$1;

export { load, resolve };
</file>

<file path=".tool-versions">
nodejs 22.17.0
</file>

<file path="LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="src/language_server/__test__/test.pie">

</file>

<file path="src/language_server/client/src/extension.ts">
import * as path from 'path';
import * as vscode from 'vscode';
import * as fs from 'fs';

import {
  LanguageClient,
  LanguageClientOptions,
  ServerOptions,
  TransportKind
} from 'vscode-languageclient/node';

import { PieOutputProvider } from './pie_output_provider';
import { PieCommandHandler } from './pie_command_handler';

let client: LanguageClient;

export function activate(context: vscode.ExtensionContext) {
  
  // Initialize the Pie output provider and command handler
  const outputProvider = new PieOutputProvider();
  const commandHandler = new PieCommandHandler(outputProvider);

  // Register the tree data provider for the sidebar
  vscode.window.registerTreeDataProvider('pieOutput', outputProvider);

  // Register commands
  const runCommand = vscode.commands.registerCommand('pie.runCode', () => {
    commandHandler.runPieCode();
  });

  const refreshCommand = vscode.commands.registerCommand('pie.refreshOutput', () => {
    commandHandler.refreshOutput();
  });

  context.subscriptions.push(runCommand, refreshCommand);

  try {
    // The server is implemented in node
    const serverModule = context.asAbsolutePath(path.join('out', 'src', 'language_server', 'server', 'src', 'server.js'));
    
    // Check if file exists
    if (!fs.existsSync(serverModule)) {
      vscode.window.showErrorMessage(`Pie LSP: Server module not found at ${serverModule}`);
      return;
    }
    
    // The debug options for the server
    // --inspect=6009: runs the server in Node's Inspector mode so VS Code can attach to the server for debugging
    const debugOptions = { execArgv: ['--nolazy', '--inspect=6009'] };

    // If the extension is launched in debug mode then the debug server options are used
    // Otherwise the run options are used
    const serverOptions: ServerOptions = {
      run: { module: serverModule, transport: TransportKind.ipc },
      debug: {
        module: serverModule,
        transport: TransportKind.ipc,
        options: debugOptions
      }
    };

    // Options to control the language client
    const clientOptions: LanguageClientOptions = {
      // Register the server for pie documents
      documentSelector: [
        { scheme: 'file', language: 'pie' },
        { scheme: 'untitled', language: 'pie' }  // Also support untitled files
      ]
    };

    // Create the language client and start the client.
    client = new LanguageClient(
      'pie-lsp',
      'Pie Language Server',
      serverOptions,
      clientOptions
    );
    // Start the client. This will also launch the server
    client.start().then(() => {
      // Client started successfully
    }).catch((error) => {
      vscode.window.showErrorMessage(`Pie LSP: Failed to start: ${error.message}`);
    });
  } catch (error) {
    vscode.window.showErrorMessage(`Pie LSP: Activation error: ${error}`);
  }
}

export function deactivate(): Thenable<void> | undefined {
  if (!client) {
    return undefined;
  }
  return client.stop();
}
</file>

<file path="src/language_server/client/src/pie_command_handler.ts">
import * as vscode from 'vscode';
import { PieOutputProvider } from './pie_output_provider';

export class PieCommandHandler {
  constructor(private outputProvider: PieOutputProvider) { }

  async runPieCode(): Promise<void> {
    const activeEditor = vscode.window.activeTextEditor;

    if (!activeEditor) {
      vscode.window.showErrorMessage('No active editor found');
      return;
    }

    if (activeEditor.document.languageId !== 'pie') {
      vscode.window.showErrorMessage('Current file is not a Pie file');
      return;
    }

    const code = activeEditor.document.getText();

    if (!code.trim()) {
      vscode.window.showWarningMessage('No code to execute');
      return;
    }

    try {
      // Show progress indicator
      await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "Running Pie Code...",
        cancellable: false
      }, async (progress) => {
        progress.report({ increment: 0 });

        try {
          progress.report({ increment: 50, message: "Evaluating..." });

          // Get the evaluatePie function
          const pieModule = this.getEvaluatePieFunction();
          const result = pieModule.evaluatePie(code);

          progress.report({ increment: 100, message: "Complete" });

          // Update the output provider with results
          this.outputProvider.updateOutput(result || 'Execution completed successfully (no output)');
          
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.outputProvider.updateOutput('', errorMessage);
          vscode.window.showErrorMessage(`Execution failed: ${errorMessage}`);
        }
      });

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      vscode.window.showErrorMessage(`Failed to run Pie code: ${errorMessage}`);
    }
  }

  private getEvaluatePieFunction(): { evaluatePie: (code: string) => string } {
    try {
      // Use dynamic require to load the compiled module
      // This is necessary because we need the compiled JavaScript version
      const modulePath = require.resolve('../../out/src/pie_interpreter/main');
      // Clear the require cache to ensure we get the latest version
      delete require.cache[modulePath];
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      const pieModule = require(modulePath);

      if (pieModule && typeof pieModule.evaluatePie === 'function') {
        return pieModule;
      }

      throw new Error('evaluatePie function not found in module');
    } catch (error) {
      // If import fails, show error with helpful message
      throw new Error(`Could not load Pie interpreter. Make sure the extension is compiled. Error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  refreshOutput(): void {
    this.outputProvider.refresh();
  }
}
</file>

<file path="src/language_server/client/src/pie_output_provider.ts">
import * as vscode from 'vscode';

export class PieOutputProvider implements vscode.TreeDataProvider<PieOutputItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<PieOutputItem | undefined | null | void> = new vscode.EventEmitter<PieOutputItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<PieOutputItem | undefined | null | void> = this._onDidChangeTreeData.event;

    private output: string = 'No output yet. Run some Pie code to see results.';
    private error: string | null = null;

    constructor() {}

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    updateOutput(output: string, error?: string): void {
        this.output = output;
        this.error = error || null;
        this.refresh();
    }

    getTreeItem(element: PieOutputItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: PieOutputItem): Thenable<PieOutputItem[]> {
        if (!element) {
            // Root level items
            const items: PieOutputItem[] = [];
            
            if (this.error) {
                items.push(new PieOutputItem(
                    'Error',
                    this.error,
                    vscode.TreeItemCollapsibleState.Expanded,
                    'error'
                ));
            }
            
            if (this.output) {
                const lines = this.output.split('\n').filter(line => line.trim() !== '');
                if (lines.length > 0) {
                    items.push(new PieOutputItem(
                        'Output',
                        '',
                        vscode.TreeItemCollapsibleState.Expanded,
                        'output'
                    ));
                }
            }
            
            return Promise.resolve(items);
        } else if (element.contextValue === 'output') {
            // Show output lines as children
            const lines = this.output.split('\n').filter(line => line.trim() !== '');
            const items = lines.map(line => new PieOutputItem(
                line.trim(),
                line.trim(),
                vscode.TreeItemCollapsibleState.None,
                'line'
            ));
            return Promise.resolve(items);
        } else if (element.contextValue === 'error') {
            // Show error details as children
            const errorLines = this.error ? this.error.split('\n').filter(line => line.trim() !== '') : [];
            const items = errorLines.map(line => new PieOutputItem(
                line.trim(),
                line.trim(),
                vscode.TreeItemCollapsibleState.None,
                'errorLine'
            ));
            return Promise.resolve(items);
        }
        
        return Promise.resolve([]);
    }
}

export class PieOutputItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly tooltip: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState,
        public readonly contextValue: string
    ) {
        super(label, collapsibleState);
        this.tooltip = tooltip;
        
        // Set icons based on context
        switch (contextValue) {
            case 'error':
                this.iconPath = new vscode.ThemeIcon('error');
                break;
            case 'output':
                this.iconPath = new vscode.ThemeIcon('output');
                break;
            case 'line':
                this.iconPath = new vscode.ThemeIcon('symbol-string');
                break;
            case 'errorLine':
                this.iconPath = new vscode.ThemeIcon('warning');
                break;
        }
    }
}
</file>

<file path="src/language_server/server/src/pie_hover_info.ts">
// Built-in Pie symbols with hover information
export const PIE_HOVER_INFO = new Map([
  // Natural numbers
  ['Nat', {
    summary: 'Natural numbers',
    details: 'The type of natural numbers (0, 1, 2, ...)',
    examples: '(the Nat 5)'
  }],
  ['zero', {
    summary: 'Zero',
    details: 'The natural number zero.',
    examples: '(the Nat zero)'
  }],
  ['add1', {
    summary: 'Add one',
    details: 'Adds one to a natural number.',
    examples: '(add1 3) ; evaluates to 4'
  }],
  // Nat's elimination forms
  ['which-Nat', {
    summary: 'Case analysis on natural numbers',
    details: 'Performs case analysis on a natural number.',
    examples: '(which-Nat n base step)'
  }],
  ['iter-Nat', {
    summary: 'Iteration on natural numbers',
    details: 'Performs iteration on a natural number.',
    examples: '(iter-Nat n base step)'
  }],
  ['rec-Nat', {
    summary: 'Recursion on natural numbers',
    details: 'Performs recursion on a natural number.',
    examples: '(rec-Nat n base step)'
  }],
  ['ind-Nat', {
    summary: 'Induction on natural numbers',
    details: 'Performs induction on a natural number.',
    examples: '(ind-Nat n motive base step)'
  }],
  
  // Atoms
  ['Atom', {
    summary: 'Atomic values',
    details: 'The type of indivisible values (quoted symbols).',
    examples: "(the Atom 'hello)"
  }],
  ['quote', {
    summary: 'Quote an atom',
    details: 'Creates an atomic value.',
    examples: "(quote hello) ; same as 'hello"
  }],
  
  // Lists
  ['List', {
    summary: 'Lists',
    details: 'A list type constructor.',
    examples: '(List Nat) ; type of lists of natural numbers'
  }],
  ['nil', {
    summary: 'Empty list',
    details: 'The empty list.',
    examples: '(the (List Nat) nil)'
  }],
  ['::',  {
    summary: 'List constructor',
    details: 'Adds an element to the front of a list.',
    examples: '(:: 1 (:: 2 nil))'
  }],
  ['rec-List', {
    summary: 'Recursion on lists',
    details: 'Performs recursion on a list.',
    examples: '(rec-List lst base step)'
  }],
  ['ind-List', {
    summary: 'Induction on lists',
    details: 'Performs induction on a list.',
    examples: '(ind-List lst motive base step)'/*  */
  }],

  // Functions
  ['lambda', {
    summary: 'Lambda expression',
    details: 'Creates an anonymous function.',
    examples: '(lambda (x) (add1 x))'
  }],
  ['λ', {
    summary: 'Lambda expression (Unicode)',
    details: 'Unicode version of lambda.',
    examples: '(λ (x) (add1 x))'
  }],
  
  // Types
  ['the', {
    summary: 'Type annotation',
    details: 'Asserts that an expression has a particular type.',
    examples: '(the Nat 5)'
  }],
  ['->', {
    summary: 'Function type',
    details: 'Non-dependent function type.',
    examples: '(the (-> Nat Nat) (lambda (x) (add1 x)))'
  }],
  ['→', {
    summary: 'Function type (Unicode)',
    details: 'Unicode version of ->.',
    examples: '(the (→ Nat Nat) (λ (x) (add1 x)))'
  }],
  ['Universe', {
    summary: 'Type of types',
    details: 'The type of types.',
    examples: '(the Universe Nat)'
  }],
  ['U', {
    summary: 'Type of types (short)',
    details: 'Short form of Universe.',
    examples: '(the U Nat)'
  }],
  
  // Dependent types
  ['Pi', {
    summary: 'Dependent function type',
    details: 'Creates a dependent function type.',
    examples: '(Pi ((n Nat)) (Vec Nat n))'
  }],
  ['Π', {
    summary: 'Dependent function type (Unicode)',
    details: 'Unicode version of Pi.',
    examples: '(Π ((n Nat)) (Vec Nat n))'
  }],
  ['Sigma', {
    summary: 'Dependent pair type',
    details: 'Creates a dependent pair type.',
    examples: '(Sigma ((A U)) (List A))'
  }],
  ['Σ', {
    summary: 'Dependent pair type (Unicode)',
    details: 'Unicode version of Sigma.',
    examples: '(Σ ((A U)) (List A))'
  }],
  
  // Pairs
  ['Pair', {
    summary: 'Pair type',
    details: 'Type of pairs (non-dependent).',
    examples: '(Pair Nat Atom)'
  }],
  ['cons', {
    summary: 'Pair constructor',
    details: 'Creates a pair.',
    examples: '(cons 1 2)'
  }],
  ['car', {
    summary: 'First element of pair',
    details: 'Extracts the first element of a pair.',
    examples: '(car (cons 1 2)) ; evaluates to 1'
  }],
  ['cdr', {
    summary: 'Second element of pair',
    details: 'Extracts the second element of a pair.',
    examples: '(cdr (cons 1 2)) ; evaluates to 2'
  }],

  // Eithers
  ['Either', {
    summary: 'Either type',
    details: 'Type representing a value that can be one of two types.',
    examples: '(Either Nat Atom)'
  }],
  ['left', {
    summary: 'Left constructor for Either',
    details: 'Creates a left value of an Either type.',
    examples: '(left 5) ; if Either is (Either Nat Atom)'
  }],
  ['right', {
    summary: 'Right constructor for Either',
    details: 'Creates a right value of an Either type.',
    examples: "(right 'hello) ; if Either is (Either Nat Atom)"
  }],
  ['ind-Either', {
    summary: 'Induction on Either type',
    details: 'Performs induction on an Either value.',
    examples: '(ind-Either e motive left-case right-case)'
  }],

  // Vectors
  ['Vec', {
    summary: 'Vectors',
    details: 'Type of vectors (lists with fixed length).',
    examples: '(Vec Nat 3) ; type of vectors of 3 natural numbers'
  }],
  ['vecnil', {
    summary: 'Empty vector',
    details: 'The empty vector.',
    examples: '(the (Vec Nat 0) vecnil)'
  }],
  ['vec::',  {
    summary: 'Vector constructor',
    details: 'Adds an element to the front of a vector.',
    examples: '(vec:: 1 (vec:: 2 vecnil))'
  }],
  ['ind-Vec', {
    summary: 'Induction on vectors',
    details: 'Performs induction on a vector.',
    examples: '(ind-Vec v len motive base step)'
  }],
  
  // Equality
  ['=', {
    summary: 'Equality type',
    details: 'Type of equality proofs.',
    examples: '(= Nat 1 1)'
  }],
  ['same', {
    summary: 'Reflexivity of equality',
    details: 'Proof that something equals itself.',
    examples: '(same 5)'
  }],
  ['replace', {
    summary: 'Substitution of equals for equals',
    details: 'Uses an equality proof to replace equals for equals.',
    examples: '(replace proof-a=b target motive)'
  }],
  ['trans', {
    summary: 'Transitivity of equality',
    details: 'Combines two equality proofs.',
    examples: '(trans proof-a=b proof-b=c)'
  }],
  ['cong', {
    summary: 'Congruence of equality',
    details: 'Applies a function to both sides of an equality.',
    examples: '(cong proof-a=b function)'
  }],
  ['symm', {
    summary: 'Symmetry of equality',
    details: 'Reverses an equality proof.',
    examples: '(symm proof-a=b)'
  }],
  ['ind-=', {
    summary: 'Induction on equality',
    details: 'Performs induction on an equality proof.',
    examples: '(ind-= proof-a=b proof-b=c)'
  }],


  // Special
  ['TODO', {
    summary: 'Placeholder for incomplete code',
    details: 'Indicates a hole to be filled in later.',
    examples: '(define my-function TODO)'
  }],
  ['Absurd', {
    summary: 'Absurd type',
    details: 'A type with no elements, representing falsehood.',
    examples: 'Absurd has no elements'
  }],
  ['Trivial', {
    summary: 'Trivial type',
    details: 'A type with exactly one element.',
    examples: '(the Trivial 5)'
  }],
]);
</file>

<file path="src/language_server/syntaxes/pie.tmLanguage.json">
{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "Pie",
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#keywords"
    },
    {
      "include": "#types"
    },
    {
      "include": "#constants"
    },
    {
      "include": "#operators"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#atoms"
    },
    {
      "include": "#parens"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.semicolon.pie",
          "match": ";.*$"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.tactics.pie",
          "match": "(?<![a-zA-Z0-9_-])(define-tactically|exact|intro|exists|elimNat|elimList|elimVec|elimEqual|elimEither|elimAbsurd|split)(?![a-zA-Z0-9_-])"
        },
        {
          "name": "keyword.control.pie",
          "match": "(?<![a-zA-Z0-9_-])(lambda|λ|Pi|Π|Sigma|Σ|define|claim|check-same|the|TODO)(?![a-zA-Z0-9_-])"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "storage.type.pie",
          "match": "(?<![a-zA-Z0-9_-])(U|Universe|Nat|Atom|List|Vec|Either|Trivial|Absurd|Pair|=)(?<![a-zA-Z0-9_-])"
        },
        {
          "name": "storage.type.arrow.pie",
          "match": "(?<![a-zA-Z0-9_-])(->|→)(?<![a-zA-Z0-9_-])"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "keyword.constructor.pie",
          "match": "(?<![a-zA-Z0-9_-])(zero|add1|quote|nil|::|cons|left|right|vecnil|vec::|same|replace|trans|cong|symm)(?<![a-zA-Z0-9_-])"
        },
        {
          "name": "keyword.destructor.pie",
          "match": "(?<![a-zA-Z0-9_-])(which-Nat|iter-Nat|rec-Nat|ind-Nat|rec-List|ind-List|ind-Vec|ind-Absurd|car|cdr|ind-Either|ind-Vec|ind-=|)(?<![a-zA-Z0-9_-])"
        }
      ]
    },
    "constants": {
      "patterns": [
        {
          "name": "constant.language.pie",
          "match": "\\b(zero|sole|nil|vecnil)\\b"
        },
        {
          "name": "constant.language.constructor.pie",
          "match": "\\b(add1|cons|car|cdr|left|right|same|quote)\\b"
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.pie",
          "match": "\\b\\d+\\b"
        }
      ]
    },
    "atoms": {
      "patterns": [
        {
          "name": "constant.other.atom.pie",
          "match": "'[a-zA-Z][a-zA-Z0-9-_]*"
        }
      ]
    },
    "parens": {
      "patterns": [
        {
          "begin": "\\(",
          "end": "\\)",
          "name": "meta.parens.pie",
          "patterns": [
            {
              "include": "$self"
            }
          ]
        }
      ]
    }
  },
  "scopeName": "source.pie"
}
</file>

<file path="src/language_server/language-configuration.json">
{
    "comments": {
        "lineComment": ";"
    },
    "brackets": [
        ["(", ")"],
        ["[", "]"]
    ],
    "autoClosingPairs": [
        ["(", ")"],
        ["[", "]"],
        ["\"", "\""]
    ],
    "surroundingPairs": [
        ["(", ")"],
        ["[", "]"],
        ["\"", "\""]
    ]
}
</file>

<file path="src/language_server/LICENSE">
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</file>

<file path="src/language_server/tsconfig.json">
{
	"compilerOptions": {
		"target": "ES2024",
		"lib": [
			"ES2024",
			"WebWorker"
		],
		"module": "commonjs",
		"moduleResolution": "node",
		"sourceMap": true,
		"strict": false,
		"outDir": "out",
		"rootDir": "../..",
		"baseUrl": "../..",
		"paths": {
			"@pie_interpreter/*": ["src/pie_interpreter/*"],
			"@scheme_parser/*": ["src/scheme_parser/*"],
			"js-base64": ["src/language_server/node_modules/js-base64"]
		},
		"skipLibCheck": true,
		"skipDefaultLibCheck": true,
		"noEmitOnError": false,
		"noImplicitAny": false,
		"esModuleInterop": true,
		"allowSyntheticDefaultImports": true,
		"types": ["node", "vscode", "jest"]
	},
	"include": [
		"client/src/**/*.ts",
		"server/src/**/*.ts",
		"../pie_interpreter/**/*.ts",
		"../scheme_parser/**/*.ts"
	],
	"exclude": [
		"node_modules/**/*",
		".vscode-test/**/*",
		"**/*.test.ts",
		"**/*.spec.ts",
		"**/__tests__/**/*",
		"../../node_modules/**/*",
		"**/conductor/**/*"
	]
}
</file>

<file path="src/pie_interpreter/__tests__/test_and.ts">
import 'jest'
import { evaluatePie } from '../main';

describe("and tests", () => {
    it("trivial", () => {
        const str = 
        `
(claim test_and
  (Pair Nat Nat))

(define test_and
  (cons zero zero))`
        console.log(evaluatePie(str))
    })

    it("trivial tactic ver0", () => {
        const str = 
        `(claim test_and
  (Pair Nat Nat))

(define-tactically test_and
     ((exists zero n)
      (exact zero))) `
        console.log(evaluatePie(str))
    })

    it("trivial tactic ver1", () => {
        const str = 
        `(claim test_and
  (Pair Nat Nat))

(define-tactically test_and
     ((split)
      (exact zero)
      (exact zero))) `
        console.log(evaluatePie(str))
    })

}
)
</file>

<file path="src/pie_interpreter/__tests__/test_check_same_advanced.ts">
import { evaluatePie } from "../main";

describe("check-same advanced (higher-order with Absurd and =)", () => {
  it("Distinct selector functions can be definitionally equal (empty domain)", () => {
    const T = `
(→ (→ (= Nat 2 3) Absurd)
   (→ (= Nat 2 3) Absurd)
   (→ (= Nat 2 3) Absurd))`;

    const f = `(λ (f g) f)`;
    const g = `(λ (f g) g)`;

    const program = `(check-same ${T} ${f} ${g})`;
    // In this type, (= Nat 2 3) is empty, so functions from it are equal extensionally.
    expect(() => evaluatePie(program)).not.toThrow();
  });

  it("Alpha-equivalent functions are equal", () => {
    // Same body but different binder names should be equal under alpha-equivalence
    const T = `
(→ (→ (= Nat 2 3) Absurd)
   (→ (= Nat 2 3) Absurd)
   (→ (= Nat 2 3) Absurd))`;

    const f1 = `(λ (f g) f)`;
    const f2 = `(λ (x y) x)`;

    const program = `(check-same ${T} ${f1} ${f2})`;
    expect(() => evaluatePie(program)).not.toThrow();
  });
});
</file>

<file path="src/pie_interpreter/__tests__/test_check_same_collections.ts">
import { evaluatePie } from "../main";

describe("check-same collections (List, Vec)", () => {
  // List tests
  it("List: nil equals nil", () => {
    const program = `(check-same (List Nat) nil nil)`;
    expect(() => evaluatePie(program)).not.toThrow();
  });

  it("List: simple cons equals same structure", () => {
    const program = `(check-same (List Nat) (:: 0 nil) (:: 0 nil))`;
    expect(() => evaluatePie(program)).not.toThrow();
  });

  it("List: cons with two items equals same structure", () => {
    const program = `(check-same (List Nat) (:: 0 (:: 1 nil)) (:: 0 (:: 1 nil)))`;
    expect(() => evaluatePie(program)).not.toThrow();
  });

  it("List: inequality by element value", () => {
      const program = `(check-same (List Nat) (:: 0 nil) (:: 1 nil))`;
    expect(() => evaluatePie(program)).toThrow();
  });

  it("List: inequality by length", () => {
    const program = `(check-same (List Nat) (:: 0 nil) nil)`;
    expect(() => evaluatePie(program)).toThrow();
  });

  // Vec tests
  it("Vec: empty vectors equal", () => {
    const program = `(check-same (Vec Nat 0) vecnil vecnil)`;
    expect(() => evaluatePie(program)).not.toThrow();
  });

  it("Vec: length-1 vectors with same element equal", () => {
    const program = `(check-same (Vec Nat 1) (vec:: 0 vecnil) (vec:: 0 vecnil))`;
    expect(() => evaluatePie(program)).not.toThrow();
  });

  it("Vec: length-2 vectors with same elements equal", () => {
    const program = `(check-same (Vec Nat 2) (vec:: 0 (vec:: 1 vecnil)) (vec:: 0 (vec:: 1 vecnil)))`;
    expect(() => evaluatePie(program)).not.toThrow();
  });

  it("Vec: inequality by element value", () => {
    const program = `(check-same (Vec Nat 2) (vec:: 0 (vec:: 1 vecnil)) (vec:: 1 (vec:: 1 vecnil)))`;
    expect(() => evaluatePie(program)).toThrow();
  });

  it("Vec: inequality by length", () => {
    const program = `(check-same (Vec Nat 1) (vec:: 0 vecnil) vecnil)`;
    expect(() => evaluatePie(program)).toThrow();
  });
});
</file>

<file path="src/pie_interpreter/__tests__/test_check_same.ts">
import { evaluatePie } from "../main";

/**
 * Tests focused solely on the `(check-same ...)` form.
 */

describe("check-same", () => {
  it("succeeds when left and right are the same (Atom 'a 'a)", () => {
    const program = `(check-same Atom 'a 'a)`;
    expect(() => evaluatePie(program)).not.toThrow();
    const out = evaluatePie(program);
    // check-same doesn't modify the context or produce output
    expect(out).toBe("");
  });

  it("throws when left and right differ (Atom 'a 'b)", () => {
    const program = `(check-same Atom 'a 'b)`;
    expect(() => evaluatePie(program)).toThrow();
  });

  it("succeeds for Nat equality (0 0)", () => {
    const program = `(check-same Nat 0 0)`;
    expect(() => evaluatePie(program)).not.toThrow();
  });

  it("fails for Nat inequality (0 1)", () => {
    const program = `(check-same Nat 0 1)`;
    expect(() => evaluatePie(program)).toThrow();
  });

  it("normalizes Nat before comparing ((add1 0) 1)", () => {
    const program = `(check-same Nat (add1 0) 1)`;
    expect(() => evaluatePie(program)).not.toThrow();
  });

  it("fails when terms don't have the claimed type (Atom 'a 0)", () => {
    const program = `(check-same Atom 'a 0)`;
    expect(() => evaluatePie(program)).toThrow();
  });

  
});
</file>

<file path="src/pie_interpreter/__tests__/test_elimlist.ts">
import 'jest';

import {evaluatePie} from '../main'

describe("elimlist", () => {
  it("Basic", () => {
    const str = `
(claim length
(Π ((E U ))
(→ (List E)
Nat)))

(claim step-length
(Π ((E U ))
(→ E (List E) Nat
Nat)))

(define step-length
(λ (E)
(λ (e es lengthes )
(add1 lengthes ))))

(define length
(λ (E)
(λ (es)
(rec-List es
0
(step-length E)))))

(claim list->vec
(Π ((E U )
(es (List E)))
(Vec E (length E es))))

(claim mot-list->vec
(Π ((E U ))
(→ (List E)
U )))

(define mot-list->vec
(λ (E)
(λ (es)
(Vec E (length E es)))))


(claim step-list->vec
(Π ((E U )
(e E)
(es (List E)))
(→ (mot-list->vec E es)
(mot-list->vec E (:: e es)))))

(define step-list->vec
(λ (E e es)
(λ (list->veces )
(vec:: e list->veces ))))


(define list->vec
(λ (E es)
(ind-List es
(mot-list->vec E)
vecnil
(step-list->vec E))))
`
    console.log(evaluatePie(str));
  })

  it("Tactic", () => {
    const str = `
(claim length
(Π ((E U ))
(→ (List E)
Nat)))

(claim step-length
(Π ((E U ))
(→ E (List E) Nat
Nat)))

(define step-length
(λ (E)
(λ (e es lengthes )
(add1 lengthes ))))

(define length
(λ (E)
(λ (es)
(rec-List es
0
(step-length E)))))

(claim list->vec
(Π ((E U )
(es (List E)))
(Vec E (length E es))))

(claim mot-list->vec
(Π ((E U ))
(→ (List E)
U )))

(define mot-list->vec
(λ (E)
(λ (es)
(Vec E (length E es)))))


(claim step-list->vec
(Π ((E U )
(e E)
(es (List E)))
(→ (mot-list->vec E es)
(mot-list->vec E (:: e es)))))

(define step-list->vec
(λ (E e es)
(λ (list->veces )
(vec:: e list->veces ))))


(define-tactically list->vec
  ((intro E)
   (intro es)
   (elimList es (mot-list->vec E))
   (exact vecnil)
   (exact (step-list->vec E)))
)
`
    console.log(evaluatePie(str))
  })
})

describe('elimvec', () => {
  it('Basic', () => {
    const str = 
    `
(claim +
  (→ Nat Nat
    Nat))

(claim step-plus
  (→ Nat
    Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1 ) ))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus )))

(claim vec-append
(Π ((E U )
(l Nat)
(j Nat))
(→ (Vec E l) (Vec E j)
(Vec E (+ l j)))))

(claim mot-vec-append
(Π ((E U )
( j Nat)
(k Nat))
(→ (Vec E k)
U )))
(define mot-vec-append
(λ (E j k)
(λ (es)
(Vec E (+ k j)))))

(claim step-vec-append
(Π ((E U )
(j Nat)
(k Nat)
(e E)
(es (Vec E k)))
(→ (mot-vec-append E j
k es)
(mot-vec-append E j
(add1 k) (vec:: e es))))) 

(define step-vec-append
(λ (E j l-1 e es)
(λ (vec-appendes )
(vec:: e vec-appendes )))) 


(define vec-append
(λ (E l j)
(λ (es end)
(ind-Vec l es
(mot-vec-append E j)
end
(step-vec-append E j)))))
    `
    console.log(evaluatePie(str));
  })

  it('Tactic', () => {
    const str = 
    `
(claim +
  (→ Nat Nat
    Nat))

(claim step-plus
  (→ Nat
    Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1 ) ))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus )))

(claim vec-append
(Π ((E U )
(l Nat)
(j Nat))
(→ (Vec E l) (Vec E j)
(Vec E (+ l j)))))

(claim mot-vec-append
(Π ((E U )
( j Nat)
(k Nat))
(→ (Vec E k)
U )))
(define mot-vec-append
(λ (E j k)
(λ (es)
(Vec E (+ k j)))))

(claim step-vec-append
(Π ((E U )
(j Nat)
(k Nat)
(e E)
(es (Vec E k)))
(→ (mot-vec-append E j
k es)
(mot-vec-append E j
(add1 k) (vec:: e es))))) 

(define step-vec-append
(λ (E j l-1 e es)
(λ (vec-appendes )
(vec:: e vec-appendes )))) 


(define-tactically vec-append
  ((intro E)
   (intro l)
   (intro j)
   (intro es)
   (intro end)
   (elimVec es (mot-vec-append E j) l)
   (exact end)
    (exact (step-vec-append E j))))
    `
    console.log(evaluatePie(str));
  })
})
</file>

<file path="src/pie_interpreter/__tests__/test_tactics.ts">
import 'jest';

import {evaluatePie} from '../main'

describe("demo", () => {
  it("Basic", () => {
    const str = 
    `
(claim +
(→ Nat Nat
Nat))

(claim step-+
(→ Nat
Nat))
(define step-+
(λ ( +n-1)
(add1 +n-1 ) ))

(define +
(λ (n j)
(iter-Nat n
j
step-+ )))

(claim +1=add1
(Π ((n Nat))
(= Nat (+ 1 n) (add1 n))))

(define-tactically +1=add1
; test
 ((intro n)
  (exact (same (add1 n)))))
`
    console.log(evaluatePie(str));
  });



//   it("Renaming0", () => {
//     const str = 
//     `
//     (claim renaming0 
//       (Π ((x Nat))
//         (Π ((x Nat))
//           Nat)))
    
//     (define renaming0
//     (λ (x)
//       (λ (x)
//         x)))`
//     console.log(evaluatePie(str));
//   })

//   it("Renaming0-Tac", () => {
//     const str = 
//     `
//     (claim renaming0-tac 
//       (Π ((x Nat))
//         (Π ((x Nat))
//           Nat)))
    
//     (define-tactically renaming0-tac
//     ((intro x)
//      (intro x)
//      (exact x)))`
//     console.log(evaluatePie(str));
//   })

//   it("Renaming1", () => {
//     const str = 
//     `
//     (claim problematic-capture
//       (Π ((n Nat) (P (→ Nat U)))
//         (Π ((n (P n)))  
//           (P n))))      
    
//     (define problematic-capture
//       (λ (n P)
//         (λ (n)
//           n)))`
//     console.log(evaluatePie(str));
//   })

//   it("Renaming1-Tac", () => {
//     const str = 
//     `
//     (claim problematic-capture-tac
//       (Π ((n Nat) (P (→ Nat U)))
//         (Π ((n (P n)))  
//           (P n))))      
    
//     (define-tactically problematic-capture-tac
//       ((intro n)
//        (intro P)
//        (intro n)
//        (exact n)))`
//     console.log(evaluatePie(str));
//   });

//   it("Reference to captured variable", () => {
//   const str = `
//     (claim captured-reference  
//       (Π ((x Nat))
//         (Π ((P (→ Nat U)))
//           (Π ((x (P x)))        
//             (Π ((y (P x)))      ; This (P x) should use outer x, not inner x
//               (P x))))))        ; This (P x) should use outer x
    
//            (define-tactically captured-reference
//       ((intro x)      ; x₁ : Nat (outer)
//        (intro P)      ; P : (→ Nat U)  
//        (intro x)      ; x₂ : (P x₁) (inner) - need to track that this x should be renamed
//        (intro y)      ; y : (P x₁) - the P x should still refer to x₁
//        (exact y)))    ; Should work since y : (P x₁) and goal is (P x₁)   
//   `;
  
//   console.log(evaluatePie(str));
// });
});

describe("EliminateTactic Tests", () => {
  
  it("Simple Nat elimination - prove n = n", () => {
    const str = 
    `
(claim n=n
  (Π ((n Nat))
    (= Nat n n)))

(define-tactically n=n
  ((intro n)
   (elimNat n (λ (k) (= Nat k k)))
   ; After eliminate, we get 3 goals:
   ; 1. Motive: (Π (k Nat) U)  
   ; 2. Base: (motive zero)
   ; 3. Step: (Π (n-1 Nat) (→ (motive n-1) (motive (add1 n-1))))
   (exact (same zero))             ; Solve base case
   (intro n-1)                     ; Introduce variables for step case
   (intro ih)
   (exact (same (add1 n-1)))))     ; Solve step case
`;
    console.log(evaluatePie(str));});

  it("Simple List elimination", () => {
    const str = `

`;
    console.log(evaluatePie(str));
  });
});
</file>

<file path="src/pie_interpreter/__tests__/test_vec.ts">
// Test cases for ind-Vec functionality
// These tests cover basic usage, edge cases, and potential bug scenarios

import { evaluatePie } from "../main";

describe('basic test cases', () => {
  it('first of one', () => {
    const src = `
        (claim first-of-one
(Π ((E U ))
(→ (Vec E 1)
E)))
(define first-of-one
(λ (E)
(λ (es)
(head es))))`
    console.log(evaluatePie(src))
  })

  it('first', () => {
    const src =
      `(claim first
(Π ((E U )
(l Nat))
(→ (Vec E (add1 l))
E)))

(define first
(λ (E l)
(λ (es)
(head es))))`
    console.log(evaluatePie(src));
  })

  it('rest', () => {
    const src =
      `(claim rest
(Π ((E U )
(l Nat))
(→ (Vec E (add1 l))
(Vec E l))))

(define rest
(λ (E l)
(λ (es)
(tail es))))`
    console.log(evaluatePie(src));
  })

  it('peas', () => {
    const src =
      `
(claim peas
(Π ((how-many-peas Nat))
(Vec Atom how-many-peas)))

(claim mot-peas
(→ Nat
U ))

(define mot-peas
(λ (k)
(Vec Atom k)))

(claim step-peas
(Π ((l-1 Nat))
(→ (mot-peas l-1)
(mot-peas (add1 l-1)))))
(define step-peas
(λ (l-1)
(λ (peasl-1)
(vec:: 'pea peasl-1))))

(define peas
(λ (how-many-peas)
(ind-Nat how-many-peas
mot-peas
vecnil
step-peas)))
`
  })
})

describe('ind-Vec test cases', () => {
  it('vecnil case', () => {
    const src =
      `(claim vec-length
  (Pi ((E U) (l Nat) )
    (-> (Vec E l)
        Nat)))

(claim mot-length
  (Pi ((E U)
       (len Nat))
    (-> (Vec E len)
        U)))

(define mot-length
  (lambda (E len)
    (lambda (es)
      Nat)))

(claim step-length
  (Pi ((E U)
       (len Nat)
       (e E)
       (es (Vec E len )))
    (-> (mot-length E len es)
        (mot-length E (add1 len) (vec:: e es)))))

(define step-length
  (lambda (E len e es)
    (lambda (vec-lengthes)
      (add1 vec-lengthes))))

(define vec-length
  (lambda (E n)
    (lambda (es)
  (ind-Vec n es
    (mot-length E)
    zero
    (step-length E)))))`
    console.log(evaluatePie(src));
  })
});
</file>

<file path="src/pie_interpreter/solver/main.ts">
import { solveTodo, todoQueue } from "./todo_solver";

async function main() {
  // Run type checker to collect TODOs
  // Then solve each one
  for (const todo of todoQueue) {
    const solution = await solveTodo(todo);
    console.log(`\n=== ${todo.location} ===`);
    console.log(solution);
  }
}
</file>

<file path="src/pie_interpreter/solver/todo_solver.browser.ts">
import type { Context } from "../utils/context";
import type { Location } from "../utils/locations";
import type { Value } from "../types/value";
import type { Renaming } from "../typechecker/utils";

export interface TodoInfo {
  location: Location;
  context: Context;
  expectedType: Value;
  renaming: Renaming;
}

export const todoQueue: TodoInfo[] = [];

export function addTodo(todo: TodoInfo): void {
  todoQueue.push(todo);
}

export function clearQueue(): void {
  todoQueue.length = 0;
}

export function clearCache(): void {
  // No cached state when running in the browser.
}

export async function solveTodo(): Promise<string> {
  throw new Error("TODO solving via LLM is not available in the browser environment.");
}
</file>

<file path="src/pie_interpreter/solver/todo_solver.ts">
// src/ai/todo_solver.ts
import { GoogleGenAI } from "@google/genai";
import * as fs from "fs/promises";
import * as path from "path";
import { Parser } from "../parser/parser";
import { stop } from "../types/utils";
import { Location } from "../utils/locations";
import { Context, readBackContext } from "../utils/context";
import { Value } from "../types/value";
import { Renaming } from "../typechecker/utils";
import 'dotenv/config';

const MISSING_API_KEY_ERROR = new Error(
  'GOOGLE_API_KEY environment variable is not set. ' +
  'Please create a .env file in the project root with: GOOGLE_API_KEY=your_key_here'
);

let genAI: GoogleGenAI | null = null;

function ensureClient(): GoogleGenAI {
  if (genAI) {
    return genAI;
  }

  const apiKey = process.env.GOOGLE_API_KEY;
  if (!apiKey) {
    throw MISSING_API_KEY_ERROR;
  }

  genAI = new GoogleGenAI({ apiKey });
  return genAI;
}

// Cache for project context string (in-memory)
let cachedProjectContext: string | null = null;

export interface TodoInfo {
  location: Location;
  context: Context;
  expectedType: Value;
  renaming: Renaming;
}

export const todoQueue: TodoInfo[] = [];

export function addTodo(todo: TodoInfo) {
  todoQueue.push(todo);
}

export function clearQueue() {
  todoQueue.length = 0;
}

export function clearCache() {
  cachedProjectContext = null;
}

// Collect all .ts files from src/pie_interpreter
async function getProjectFiles(): Promise<Map<string, string>> {
  const files = new Map<string, string>();
  const dir = "src/pie_interpreter";

  async function walk(dir: string) {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory() && !entry.name.startsWith(".")) {
        await walk(fullPath);
      } else if (entry.name.endsWith(".ts") && !entry.name.includes("test")) {
        files.set(fullPath, await fs.readFile(fullPath, "utf-8"));
      }
    }
  }

  await walk(dir);
  return files;
}

// Build and cache project context string
async function getOrBuildProjectContext(): Promise<string> {
  if (cachedProjectContext) {
    return cachedProjectContext;
  }

  const projectFiles = await getProjectFiles();

  // Build comprehensive project context with file contents
  let projectContext = "# Project structure and files:\n\n";

  // Add file paths list for overview
  projectContext += "## File listing:\n";
  for (const path of projectFiles.keys()) {
    projectContext += `- ${path}\n`;
  }

  // Add actual file contents (with size limit per file)
  projectContext += "\n## File contents:\n\n";
  for (const [path, content] of projectFiles) {
    const lines = content.split('\n');
    const truncatedContent = lines.slice(0, 10000).join('\n'); // Limit to first 100 lines per file
    projectContext += `### ${path}\n\`\`\`typescript\n${truncatedContent}\n\`\`\`\n\n`;
  }

  // Cache the built context
  cachedProjectContext = projectContext;
  return projectContext;
}

export async function solveTodo(todo: TodoInfo): Promise<string> {
  const genAI = ensureClient();
  // Get cached or build project context
  const projectContext = await getOrBuildProjectContext();

  const startTime = Date.now();
  const TIMEOUT_MS = 30000; // 30 seconds

  // Stringify objects for AI prompt
  const serializedContext = JSON.stringify(readBackContext(todo.context));
  const serializedRenaming = JSON.stringify(Array.from(todo.renaming.entries()));
  const expectedTypeStr = todo.expectedType.readBackType(todo.context).prettyPrint();

  // Use the real objects for typechecking
  const ctx = todo.context;
  const renaming = todo.renaming;

  const basePrompt = `You are helping to fill in TODO expressions in Pie language 
          code (a dependently-typed language from "The Little Typer").

${projectContext}

## TODO Context:
Available context (variable bindings): ${serializedContext}
Renaming map: ${serializedRenaming}
Expected type: ${expectedTypeStr}

## Task:
Generate ONLY a valid Pie expression (not TypeScript!) that has the expected type.

Common Pie types and their values:
- Nat: zero, (add1 zero), (add1 (add1 zero)), etc.
- Atom: 'foo, 'bar, etc. (quoted symbols)
- Trivial: sole (the only value of type Trivial)
- (List T): (the (List T) nil), (:: head tail)
  Note: nil needs explicit typing like (the (List Nat) nil)
- (Pair A D): (cons a d)
- (→ A B): (lambda (x) body) or (λ (x) body)

Important: When you need to provide an explicit type annotation, use (the Type value).
For example: (the Nat zero), (the (List Nat) nil)

Do not include code fences, markdown, or explanations. Just the Pie expression.
`;

  let errorHistory = "";
  let attempts = 0;

  while (Date.now() - startTime < TIMEOUT_MS) {
    attempts++;

    const prompt = basePrompt + errorHistory;

    try {
      const result = await genAI.models.generateContent({
        model: "gemini-2.5-flash",
        contents: prompt
      });
      if (!result.text) {
        errorHistory += `\n\nAttempt ${attempts} failed - No text generated by the model.`;
        continue;
      }
      const pieCode = result.text.trim()
        .replace(/^```[\w]*\n?/, '')  // Remove opening code fence
        .replace(/\n?```$/, '')        // Remove closing code fence
        .trim();

      // Try to parse the Pie expression
      let parsed;
      try {
        parsed = Parser.parsePie(pieCode);
      } catch (parseError: any) {
        errorHistory += `\n\nAttempt ${attempts} failed - Parse error: ${parseError.message}\nYou generated: ${pieCode}\nPlease fix the syntax and try again.`;
        continue;
      }

      // Try to typecheck it
      try {
        // Use check mode since we have the expected type (already as Value)
        const checkResult = parsed.check(ctx, renaming, todo.expectedType);

        if (checkResult instanceof stop) {
          // Typecheck failed
          errorHistory += `\n\nAttempt ${attempts} failed - Type error: ${checkResult.message.toString()}\nYou generated: ${pieCode}\nPlease generate a correct expression.`;
          continue;
        }

        // Success! Return the expression
        return pieCode;
      } catch (typecheckError: any) {
        errorHistory += `\n\nAttempt ${attempts} failed - Typecheck error: ${typecheckError.message}\nYou generated: ${pieCode}\nPlease fix and try again.`;
        continue;
      }
    } catch (error: any) {
      errorHistory += `\n\nAttempt ${attempts} failed - API error: ${error.message}`;
      // Wait a bit before retrying API errors
      await new Promise(resolve => setTimeout(resolve, 1000));
      continue;
    }
  }

  // Timeout reached
  throw new Error(`Failed to solve TODO after ${attempts} attempts in 30 seconds. Last errors: ${errorHistory}`);
}
</file>

<file path="src/pie_interpreter/utils/environment.ts">
import { Value } from '../types/value';

/*  
    ## Run-time Environments ##

    Run-time environments
    A run-time environment associates a value with each variable.
*/

export type Environment = Map<string, Value>;
  export function extendEnvironment(env: Environment, name: string, value: Value): Environment {
    return new Map([...env, [name, value]]);
  }

  // Lookup the value of a variable in an environment (var-val)
  export function getValueFromEnvironment(env: Environment, name: string): Value {
    if (env.has(name)) {
      // As we are sure that the variable is in the environment,
      // we can use the non-nullable assertion operator (!)
      return env.get(name)!;
    } else {
      throw new Error(`Variable ${name} not found in environment`);
    }
  }

  // To find the value of a variable in an environment
  export function ValueOfVar(env: Environment, name: string): Value {
    if (env.has(name)) {
      return env.get(name)!;
    } else {
      throw new Error(`Variable ${name} not in env: ${JSON.stringify(env)}`);
    }
  }
</file>

<file path="src/scheme_parser/transpiler/lexer/scheme-lexer.ts">
// Thanks to Ken Jin (py-slang) for the great resource
// https://craftinginterpreters.com/scanning.html
// This tokenizer/lexer is a modified version, inspired by both the
// tokenizer/lexer above as well as Ken Jin's py-slang tokenizer/lexer.
// It has been adapted to be written in typescript for scheme.
// Crafting Interpreters: https://craftinginterpreters.com/
// py-slang: https://github.com/source-academy/py-slang

import { stringIsSchemeNumber } from "../../core-math";
import { Token } from "../types/tokens/token";
import { TokenType } from "../types/tokens/token-type";
import { Lexer } from "./lexer";
import * as LexerError from "./lexer-error";

// syntactic keywords in the scheme language
const keywords = new Map<string, TokenType>([
  [".", TokenType.DOT],
  ["if", TokenType.IF],
  ["let", TokenType.LET],
  ["cond", TokenType.COND],
  ["else", TokenType.ELSE],
  ["set!", TokenType.SET],
  ["begin", TokenType.BEGIN],
  ["delay", TokenType.DELAY],
  ["quote", TokenType.QUOTE],
  ["export", TokenType.EXPORT],
  ["import", TokenType.IMPORT],
  ["define", TokenType.DEFINE],
  ["lambda", TokenType.LAMBDA],
  ["define-syntax", TokenType.DEFINE_SYNTAX],
  ["syntax-rules", TokenType.SYNTAX_RULES],
]);

export class SchemeLexer implements Lexer {
  private readonly source: string;
  private readonly tokens: Token[];
  private start: number = 0;
  private current: number = 0;
  private line: number = 1;
  private col: number = 0;

  constructor(source: string) {
    this.source = source;
    this.tokens = [];
  }

  private isAtEnd(): boolean {
    return this.current >= this.source.length;
  }

  private advance(): string {
    // get the next character
    this.col++;
    return this.source.charAt(this.current++);
  }

  private jump(): void {
    // when you want to ignore a character
    this.start = this.current;
    this.col++;
    this.current++;
  }

  private addToken(type: TokenType): void;
  private addToken(type: TokenType, literal: any): void;
  private addToken(type: TokenType, literal: any = null): void {
    const text = this.source.substring(this.start, this.current);
    this.tokens.push(
      new Token(
        type,
        text,
        literal,
        this.start,
        this.current,
        this.line,
        this.col
      )
    );
  }

  public scanTokens(): Token[] {
    while (!this.isAtEnd()) {
      this.start = this.current;
      this.scanToken();
    }

    this.tokens.push(
      new Token(
        TokenType.EOF,
        "",
        null,
        this.start,
        this.current,
        this.line,
        this.col
      )
    );
    return this.tokens;
  }

  private scanToken(): void {
    const c = this.advance();
    switch (c) {
      case "(":
        this.addToken(TokenType.LEFT_PAREN);
        break;
      case ")":
        this.addToken(TokenType.RIGHT_PAREN);
        break;
      case "[":
        this.addToken(TokenType.LEFT_BRACKET);
        break;
      case "]":
        this.addToken(TokenType.RIGHT_BRACKET);
        break;
      case "'":
        this.addToken(TokenType.APOSTROPHE);
        break;
      case "`":
        this.addToken(TokenType.BACKTICK);
        break;
      case ",":
        if (this.match("@")) {
          this.addToken(TokenType.COMMA_AT);
          break;
        }
        this.addToken(TokenType.COMMA);
        break;
      case "#":
        // by itself, it is an error
        if (this.match("t") || this.match("f")) {
          this.booleanToken();
        } else if (this.match("|")) {
          // a multiline comment
          this.comment();
        } else if (this.match(";")) {
          // a datum comment
          this.addToken(TokenType.HASH_SEMICOLON);
        } else if (this.peek() === "(" || this.peek() === "[") {
          // We keep the hash character and the parenthesis/bracket
          // separate as our parentheses matching systems
          // will suffer with 4 possible left grouping tokens!

          // ensure that the next character is a vector
          this.addToken(TokenType.HASH_VECTOR);
        } else {
          // chars are not currently supported
          throw new LexerError.UnexpectedCharacterError(this.line, this.col, c);
        }
        break;
      case ";":
        // a comment
        while (this.peek() != "\n" && !this.isAtEnd()) this.advance();
        break;
      // double character tokens not currently needed
      case " ":
      case "\r":
      case "\t":
        // ignore whitespace
        break;
      case "\n":
        this.line++;
        this.col = 0;
        break;
      case '"':
        this.stringToken();
        break;
      case "|":
        this.identifierTokenLoose();
        break;
      default:
        // Deviates slightly from the original lexer.
        // Scheme allows for identifiers to start with a digit
        // or include a specific set of symbols.
        if (
          this.isDigit(c) ||
          c === "-" ||
          c === "+" ||
          c === "." ||
          c === "i" || // inf
          c === "n" // nan
        ) {
          // may or may not be a number
          this.identifierNumberToken();
        } else if (this.isValidIdentifier(c)) {
          // filtered out the potential numbers
          // these are definitely identifiers
          this.identifierToken();
        } else {
          throw new LexerError.UnexpectedCharacterError(this.line, this.col, c);
        }
        break;
    }
  }

  private comment(): void {
    while (!(this.peek() == "|" && this.peekNext() == "#") && !this.isAtEnd()) {
      if (this.peek() === "\n") {
        this.line++;
        this.col = 0;
      }
      this.advance();
    }

    if (this.isAtEnd()) {
      throw new LexerError.UnexpectedEOFError(this.line, this.col);
    }

    this.jump();
    this.jump();
  }

  private identifierToken(): void {
    while (this.isValidIdentifier(this.peek())) this.advance();
    this.addToken(this.checkKeyword());
  }

  private identifierTokenLoose(): void {
    // this is a special case for identifiers
    // add the first |
    this.advance();
    while (this.peek() != "|" && !this.isAtEnd()) {
      if (this.peek() === "\n") {
        this.line++;
        this.col = 0;
      }
      this.advance();
    }

    if (this.isAtEnd()) {
      throw new LexerError.UnexpectedEOFError(this.line, this.col);
    }

    // add the last |
    this.advance();

    this.addToken(this.checkKeyword());
  }

  private identifierNumberToken(): void {
    // we first obtain the entire identifier
    while (this.isValidIdentifier(this.peek())) {
      this.advance();
    }
    const lexeme = this.source.substring(this.start, this.current);
    if (stringIsSchemeNumber(lexeme)) {
      this.addToken(TokenType.NUMBER, lexeme);
      return;
    }
    this.addToken(this.checkKeyword());
  }

  private checkKeyword(): TokenType {
    const text = this.source.substring(this.start, this.current);
    if (keywords.has(text)) {
      return keywords.get(text) as TokenType;
    }
    return TokenType.IDENTIFIER;
  }

  private stringToken(): void {
    while (this.peek() != '"' && !this.isAtEnd()) {
      if (this.peek() === "\n") {
        this.line++;
        this.col = 0;
      }
      this.advance();
    }

    if (this.isAtEnd()) {
      throw new LexerError.UnexpectedEOFError(this.line, this.col);
    }

    // closing "
    this.advance();

    // trim the surrounding quotes
    const value = this.source.substring(this.start + 1, this.current - 1);
    this.addToken(TokenType.STRING, value);
  }

  private booleanToken(): void {
    this.addToken(TokenType.BOOLEAN, this.peekPrev() === "t" ? true : false);
  }

  private match(expected: string): boolean {
    if (this.isAtEnd()) return false;
    if (this.source.charAt(this.current) != expected) return false;
    this.current++;
    return true;
  }

  private peek(): string {
    if (this.isAtEnd()) return "\0";
    return this.source.charAt(this.current);
  }

  private peekNext(): string {
    if (this.current + 1 >= this.source.length) return "\0";
    return this.source.charAt(this.current + 1);
  }

  private peekPrev(): string {
    if (this.current - 1 < 0) return "\0";
    return this.source.charAt(this.current - 1);
  }

  private isDigit(c: string): boolean {
    return c >= "0" && c <= "9";
  }

  private isSpecialSyntax(c: string): boolean {
    return (
      c === "(" || c === ")" || c === "[" || c === "]" || c === ";" || c === "|"
    );
  }

  private isValidIdentifier(c: string): boolean {
    return !this.isWhitespace(c) && !this.isSpecialSyntax(c);
  }

  private isWhitespace(c: string): boolean {
    return c === " " || c === "\0" || c === "\n" || c === "\r" || c === "\t";
  }
}
</file>

<file path="src/scheme_parser/transpiler/parser/parser-error.ts">
import { Datum } from "../types/tokens/datum";
import { Token } from "../types/tokens/token";
import { Position } from "estree";

function extractLine(source: string, pos: Position): string {
  const lines = source.split("\n");
  return lines[pos.line - 1];
}

function showPoint(pos: Position): string {
  return "^".padStart(pos.column, " ");
}

export abstract class ParserError extends SyntaxError {
  // This base error shouldn't be used directly.
  loc: Position;
  constructor(message: string, pos: Position) {
    super(`Syntax error at (${pos.line}:${pos.column})\n${message}`);
    this.loc = pos;
  }
  toString(): string {
    return this.message;
  }
}

export class GenericSyntaxError extends ParserError {
  constructor(source: string, pos: Position) {
    super(extractLine(source, pos) + "\n" + showPoint(pos), pos);
    this.name = "GenericSyntaxError";
  }
}

export class ParenthesisMismatchError extends ParserError {
  constructor(source: string, pos: Position) {
    super(
      extractLine(source, pos) +
        "\n" +
        showPoint(pos) +
        "\n" +
        "Mismatched parenthesis",
      pos
    );
    this.name = "ParenthesisMismatchError";
  }
}

export class UnexpectedEOFError extends ParserError {
  constructor(source: string, pos: Position) {
    super(extractLine(source, pos) + "\n" + "Unexpected EOF", pos);
    this.name = "UnexpectedEOFError";
  }
}

export class UnexpectedFormError extends ParserError {
  form: Datum;
  constructor(source: string, pos: Position, form: Datum) {
    super(
      extractLine(source, pos) +
        "\n" +
        showPoint(pos) +
        "\n" +
        `Unexpected \'${form}\'`,
      pos
    );
    this.form = form;
    this.name = "UnexpectedTokenError";
  }
}

export class ExpectedFormError extends ParserError {
  form: Datum;
  expected: string;
  constructor(source: string, pos: Position, form: Datum, expected: string) {
    super(
      extractLine(source, pos) +
        "\n" +
        showPoint(pos) +
        "\n" +
        `Expected \'${expected}\' but got \'${form}\'`,
      pos
    );
    this.form = form;
    this.expected = expected;
    this.name = "ExpectedTokenError";
  }
}

export class MissingFormError extends ParserError {
  expected: string;
  constructor(source: string, pos: Position, expected: string) {
    super(
      extractLine(source, pos) +
        "\n" +
        showPoint(pos) +
        "\n" +
        `Expected \'${expected}\'`,
      pos
    );
    this.expected = expected;
    this.name = "MissingTokenError";
  }
}

export class DisallowedTokenError extends ParserError {
  token: Token;
  constructor(source: string, pos: Position, token: Token, chapter: number) {
    super(
      extractLine(source, pos) +
        "\n" +
        showPoint(pos) +
        "\n" +
        `Syntax \'${token}\' not allowed at Scheme \xa7${chapter}`,
      pos
    );
    this.token = token;
    this.name = "DisallowedTokenError";
  }
}

export class UnsupportedTokenError extends ParserError {
  token: Token;
  constructor(source: string, pos: Position, token: Token) {
    super(
      extractLine(source, pos) +
        "\n" +
        showPoint(pos) +
        "\n" +
        `Syntax \'${token}\' not supported yet`,
      pos
    );
    this.token = token;
    this.name = "UnsupportedTokenError";
  }
}
</file>

<file path="src/scheme_parser/transpiler/parser/scheme-parser.ts">
import { Token } from "../types/tokens/token";
import { TokenType } from "../types/tokens/token-type";
import { Location } from "../types/location";
import { Atomic, Expression, Extended } from "../types/nodes/scheme-node-types";
import * as ParserError from "./parser-error";
import { Datum } from "../types/tokens/datum";
import { Group } from "../types/tokens/group";
import { Parser } from "./parser";
import { isGroup, isToken } from "../types/tokens";
import {
  BASIC_CHAPTER,
  MACRO_CHAPTER,
  MUTABLE_CHAPTER,
  QUOTING_CHAPTER,
  VECTOR_CHAPTER,
} from "../types/constants";

/**
 * An enum representing the current quoting mode of the parser.
 */
enum QuoteMode {
  NONE,
  QUOTE,
  QUASIQUOTE,
}

export class SchemeParser implements Parser {
  private readonly source: string;
  private readonly tokens: Token[];
  private readonly chapter: number;
  private current: number = 0;
  private quoteMode: QuoteMode = QuoteMode.NONE;

  constructor(source: string, tokens: Token[], chapter: number = Infinity) {
    this.source = source;
    this.tokens = tokens;
    this.chapter = chapter;
  }

  private advance(): Token {
    if (!this.isAtEnd()) this.current++;
    return this.previous();
  }

  private isAtEnd(): boolean {
    return this.current >= this.tokens.length;
  }

  private previous(): Token {
    return this.tokens[this.current - 1];
  }

  private peek(): Token {
    return this.tokens[this.current];
  }

  private validateChapter(c: Token, chapter: number): void {
    if (this.chapter < chapter) {
      throw new ParserError.DisallowedTokenError(
        this.source,
        c.pos,
        c,
        this.chapter
      );
    }
  }

  /**
   * Returns the location of a token.
   * @param token A token.
   * @returns The location of the token.
   */
  private toLocation(token: Token): Location {
    return new Location(token.pos, token.endPos);
  }

  /**
   * Helper function used to destructure a list into its elements and terminator.
   * An optional verifier is used if there are restrictions on the elements of the list.
   */
  private destructureList(
    list: Datum[],
    verifier = (_x: any) => {}
  ): [Expression[], Expression | undefined] {
    // check if the list is an empty list
    if (list.length === 0) {
      return [[], undefined];
    }

    // check if the list is a list of length 1
    if (list.length === 1) {
      verifier(list[0]);
      return [[this.parseExpression(list[0])], undefined];
    }

    // we now know that the list is at least of length 2

    // check for a dotted list
    // it is if the second last element is a dot
    const potentialDot = list.at(-2) as Datum;

    if (isToken(potentialDot) && potentialDot.type === TokenType.DOT) {
      const cdrElement = list.at(-1)!;
      const listElements = list.slice(0, -2);
      verifier(cdrElement);
      listElements.forEach(verifier);
      return [
        listElements.map(this.parseExpression.bind(this)),
        this.parseExpression(cdrElement),
      ];
    }

    // we now know that it is a proper list
    const listElements = list;
    listElements.forEach(verifier);
    return [listElements.map(this.parseExpression.bind(this)), undefined];
  }

  /**
   * Returns a group of associated tokens.
   * Tokens are grouped by level of parentheses.
   *
   * @param openparen The opening parenthesis, if one exists.
   * @returns A group of tokens or groups of tokens.
   */
  private grouping(openparen?: Token): Group | undefined {
    const elements: Datum[] = [];
    let inList = false;
    if (openparen) {
      inList = true;
      elements.push(openparen);
    }
    do {
      const c = this.advance();
      switch (c.type) {
        case TokenType.LEFT_PAREN:
        case TokenType.LEFT_BRACKET:
          // the next group is not empty, especially because it
          // has an open parenthesis
          const innerGroup = this.grouping(c) as Group;
          elements.push(innerGroup);
          break;
        case TokenType.RIGHT_PAREN:
        case TokenType.RIGHT_BRACKET:
          if (!inList) {
            throw new ParserError.UnexpectedFormError(this.source, c.pos, c);
          }
          // add the parenthesis to the current group
          elements.push(c);
          inList = false;
          break;
        case TokenType.APOSTROPHE: // Quoting syntax (short form)
        case TokenType.BACKTICK:
        case TokenType.COMMA:
        case TokenType.COMMA_AT:
        case TokenType.HASH_VECTOR: // Vector syntax
          // these cases modify only the next element
          // so we group up the next element and use this
          // token on it
          let nextGrouping;
          do {
            nextGrouping = this.grouping();
          } while (!nextGrouping);
          elements.push(this.affect(c, nextGrouping));
          break;
        case TokenType.QUOTE: // Quoting syntax
        case TokenType.QUASIQUOTE:
        case TokenType.UNQUOTE:
        case TokenType.UNQUOTE_SPLICING:
        case TokenType.IDENTIFIER: // Atomics
        case TokenType.NUMBER:
        case TokenType.BOOLEAN:
        case TokenType.STRING:
        case TokenType.DOT:

        case TokenType.DEFINE: // Chapter 1
        case TokenType.IF:
        case TokenType.ELSE:
        case TokenType.COND:
        case TokenType.LAMBDA:
        case TokenType.LET:
        case TokenType.SET: // Chapter 3
        case TokenType.BEGIN:
        case TokenType.DELAY:
        case TokenType.IMPORT:
        case TokenType.EXPORT:
        case TokenType.DEFINE_SYNTAX:
        case TokenType.SYNTAX_RULES: // Chapter 4
          elements.push(c);
          break;
        case TokenType.HASH_SEMICOLON:
          // a datum comment
          // get the next NON-EMPTY grouping
          // and ignore it
          while (!this.grouping()) {}
          break;
        case TokenType.EOF:
          // We should be unable to reach this point at top level as parse()
          // should prevent the grouping of the singular EOF token.
          // However, with any element that ranges beyond the end of the
          // file without its corresponding delemiter, we can reach this point.
          throw new ParserError.UnexpectedEOFError(this.source, c.pos);
        default:
          throw new ParserError.UnexpectedFormError(this.source, c.pos, c);
      }
    } while (inList);
    if (elements.length === 0) {
      return;
    }

    try {
      return Group.build(elements);
    } catch (e) {
      if (e instanceof ParserError.ExpectedFormError) {
        throw new ParserError.ExpectedFormError(
          this.source,
          e.loc,
          e.form,
          e.expected
        );
      }
      throw e;
    }
  }

  /**
   * Groups an affector token with its target.
   */
  private affect(affector: Token, target: Datum): Group {
    return Group.build([affector, target]);
  }

  /**
   * Parse an expression.
   * @param expr A token or a group of tokens.
   * @returns
   */
  private parseExpression(expr: Datum): Expression {
    // Discern the type of expression
    if (isToken(expr)) {
      return this.parseToken(expr);
    }

    // We now know it is a group

    // Due to group invariants we can determine if it represents a
    // single token instead
    if (expr.isSingleIdentifier()) {
      return this.parseToken(expr.unwrap()[0] as Token);
    }

    return this.parseGroup(expr);
  }

  private parseToken(token: Token): Expression {
    switch (token.type) {
      case TokenType.IDENTIFIER:
        return this.quoteMode === QuoteMode.NONE
          ? new Atomic.Identifier(this.toLocation(token), token.lexeme)
          : new Atomic.Symbol(this.toLocation(token), token.lexeme);
      // all of these are self evaluating, and so can be left alone regardless of quote mode
      case TokenType.NUMBER:
        return new Atomic.NumericLiteral(
          this.toLocation(token),
          token.literal as string
        );
      case TokenType.BOOLEAN:
        return new Atomic.BooleanLiteral(
          this.toLocation(token),
          token.literal as boolean
        );
      case TokenType.STRING:
        return new Atomic.StringLiteral(
          this.toLocation(token),
          token.literal as string
        );
      default:
        // if in a quoting context, or when dealing with the macro chapter,
        // any keyword is instead treated as a symbol
        if (
          this.quoteMode !== QuoteMode.NONE ||
          this.chapter >= MACRO_CHAPTER
        ) {
          return new Atomic.Symbol(this.toLocation(token), token.lexeme);
        }
        throw new ParserError.UnexpectedFormError(
          this.source,
          token.pos,
          token
        );
    }
  }

  private parseGroup(group: Group): Expression {
    // No need to check if group represents a single token as well
    if (!group.isParenthesized()) {
      // The only case left is the unparenthesized case
      // of a single affector token and a target group
      // Form: <affector token> <group>
      return this.parseAffectorGroup(group);
    }
    // Now we have fallen through to the generic group
    // case - a parenthesized group of tokens.
    switch (this.quoteMode) {
      case QuoteMode.NONE:
        return this.parseNormalGroup(group);
      case QuoteMode.QUOTE:
      case QuoteMode.QUASIQUOTE:
        return this.parseQuotedGroup(group);
    }
  }

  /**
   * Parse a group of tokens affected by an affector.
   * Important case as affector changes quotation mode.
   *
   * @param group A group of tokens, verified to be an affector and a target.
   * @returns An expression.
   */
  parseAffectorGroup(group: Group): Expression {
    const [affector, target] = group.unwrap();
    // Safe to cast affector due to group invariants
    switch ((<Token>affector).type) {
      case TokenType.APOSTROPHE:
      case TokenType.QUOTE:
        this.validateChapter(<Token>affector, QUOTING_CHAPTER);
        if (this.quoteMode !== QuoteMode.NONE) {
          const innerGroup = this.parseExpression(target);
          const newSymbol = new Atomic.Symbol(
            this.toLocation(<Token>affector),
            "quote"
          );

          const newLocation = newSymbol.location.merge(innerGroup.location);
          // wrap the entire expression in a list
          return new Extended.List(newLocation, [newSymbol, innerGroup]);
        }
        this.quoteMode = QuoteMode.QUOTE;
        const quotedExpression = this.parseExpression(target);
        this.quoteMode = QuoteMode.NONE;
        return quotedExpression;
      case TokenType.BACKTICK:
      case TokenType.QUASIQUOTE:
        this.validateChapter(<Token>affector, QUOTING_CHAPTER);
        if (this.quoteMode !== QuoteMode.NONE) {
          const innerGroup = this.parseExpression(target);
          const newSymbol = new Atomic.Symbol(
            this.toLocation(<Token>affector),
            "quasiquote"
          );

          const newLocation = newSymbol.location.merge(innerGroup.location);
          // wrap the entire expression in a list
          return new Extended.List(newLocation, [newSymbol, innerGroup]);
        }
        this.quoteMode = QuoteMode.QUASIQUOTE;
        const quasiquotedExpression = this.parseExpression(target);
        this.quoteMode = QuoteMode.NONE;
        return quasiquotedExpression;
      case TokenType.COMMA:
      case TokenType.UNQUOTE:
        this.validateChapter(<Token>affector, QUOTING_CHAPTER);
        const preUnquoteMode = this.quoteMode;
        if (preUnquoteMode === QuoteMode.NONE) {
          throw new ParserError.UnsupportedTokenError(
            this.source,
            (<Token>affector).pos,
            <Token>affector
          );
        }
        if (preUnquoteMode === QuoteMode.QUOTE) {
          const innerGroup = this.parseExpression(target);
          const newSymbol = new Atomic.Symbol(
            this.toLocation(<Token>affector),
            "unquote"
          );

          const newLocation = newSymbol.location.merge(innerGroup.location);
          // wrap the entire expression in a list
          return new Extended.List(newLocation, [newSymbol, innerGroup]);
        }
        this.quoteMode = QuoteMode.NONE;
        const unquotedExpression = this.parseExpression(target);
        this.quoteMode = preUnquoteMode;
        return unquotedExpression;
      case TokenType.COMMA_AT:
      case TokenType.UNQUOTE_SPLICING:
        this.validateChapter(<Token>affector, QUOTING_CHAPTER);
        const preUnquoteSplicingMode = this.quoteMode;
        if (preUnquoteSplicingMode === QuoteMode.NONE) {
          throw new ParserError.UnexpectedFormError(
            this.source,
            (<Token>affector).pos,
            <Token>affector
          );
        }
        if (preUnquoteSplicingMode === QuoteMode.QUOTE) {
          const innerGroup = this.parseExpression(target);
          const newSymbol = new Atomic.Symbol(
            this.toLocation(<Token>affector),
            "unquote-splicing"
          );

          const newLocation = newSymbol.location.merge(innerGroup.location);
          // wrap the entire expression in a list
          return new Extended.List(newLocation, [newSymbol, innerGroup]);
        }
        this.quoteMode = QuoteMode.NONE;
        const unquoteSplicedExpression = this.parseExpression(target);
        this.quoteMode = preUnquoteSplicingMode;
        const newLocation = this.toLocation(<Token>affector).merge(
          unquoteSplicedExpression.location
        );
        return new Atomic.SpliceMarker(newLocation, unquoteSplicedExpression);
      case TokenType.HASH_VECTOR:
        // vectors quote over all elements inside.
        this.validateChapter(<Token>affector, VECTOR_CHAPTER);
        const preVectorQuoteMode = this.quoteMode;
        this.quoteMode = QuoteMode.QUOTE;
        const vector = this.parseVector(group);
        this.quoteMode = preVectorQuoteMode;
        return vector;
      default:
        throw new ParserError.UnexpectedFormError(
          this.source,
          (<Token>affector).pos,
          <Token>affector
        );
    }
  }

  private parseNormalGroup(group: Group): Expression {
    // it is an error if the group is empty in a normal context
    if (group.length() === 0) {
      if (this.chapter >= MACRO_CHAPTER) {
        // disable any verification for the empty group
        // the CSET machine will verify its validity
        return new Atomic.Nil(group.location);
      }
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "non-empty group"
      );
    }

    // get the first element
    const firstElement = group.unwrap()[0];

    // If the first element is a token, it may be a keyword or a procedure call
    if (isToken(firstElement)) {
      switch (firstElement.type) {
        // Scheme chapter 1
        case TokenType.LAMBDA:
          this.validateChapter(firstElement, BASIC_CHAPTER);
          return this.parseLambda(group);
        case TokenType.DEFINE:
          this.validateChapter(firstElement, BASIC_CHAPTER);
          return this.parseDefinition(group);
        case TokenType.IF:
          this.validateChapter(firstElement, BASIC_CHAPTER);
          return this.parseConditional(group);
        case TokenType.LET:
          this.validateChapter(firstElement, BASIC_CHAPTER);
          return this.parseLet(group);
        case TokenType.COND:
          this.validateChapter(firstElement, BASIC_CHAPTER);
          return this.parseExtendedCond(group);

        // Scheme chapter 2
        case TokenType.QUOTE:
        case TokenType.APOSTROPHE:
        case TokenType.QUASIQUOTE:
        case TokenType.BACKTICK:
        case TokenType.UNQUOTE:
        case TokenType.COMMA:
        case TokenType.UNQUOTE_SPLICING:
        case TokenType.COMMA_AT:
          this.validateChapter(firstElement, QUOTING_CHAPTER);
          // we can reuse the affector group method to control the quote mode
          return this.parseAffectorGroup(group);

        // Scheme chapter 3
        case TokenType.BEGIN:
          this.validateChapter(firstElement, MUTABLE_CHAPTER);
          return this.parseBegin(group);
        case TokenType.DELAY:
          this.validateChapter(firstElement, MUTABLE_CHAPTER);
          return this.parseDelay(group);
        case TokenType.SET:
          this.validateChapter(firstElement, MUTABLE_CHAPTER);
          return this.parseSet(group);

        // Scheme full (macros)
        case TokenType.DEFINE_SYNTAX:
          this.validateChapter(firstElement, MACRO_CHAPTER);
          return this.parseDefineSyntax(group);
        case TokenType.SYNTAX_RULES:
          // should not be called outside of define-syntax!
          throw new ParserError.UnexpectedFormError(
            this.source,
            firstElement.pos,
            firstElement
          );

        // Scm-slang misc
        case TokenType.IMPORT:
          this.validateChapter(firstElement, BASIC_CHAPTER);
          return this.parseImport(group);
        case TokenType.EXPORT:
          this.validateChapter(firstElement, BASIC_CHAPTER);
          return this.parseExport(group);
        case TokenType.VECTOR:
          this.validateChapter(firstElement, VECTOR_CHAPTER);
          // same as above, this is an affector group
          return this.parseAffectorGroup(group);

        default:
          // It's a procedure call
          return this.parseApplication(group);
      }
    }
    // Form: (<group> <expr>*)
    // It's a procedure call
    return this.parseApplication(group);
  }

  /**
   * We are parsing a list/dotted list.
   */
  private parseQuotedGroup(group: Group): Expression {
    // check if the group is an empty list
    if (group.length() === 0) {
      return new Atomic.Nil(group.location);
    }

    // check if the group is a list of length 1
    if (group.length() === 1) {
      const elem = [this.parseExpression(group.unwrap()[0])];
      return new Extended.List(group.location, elem);
    }

    // we now know that the group is at least of length 2

    const groupElements = group.unwrap();

    const [listElements, cdrElement] = this.destructureList(groupElements);

    return new Extended.List(group.location, listElements, cdrElement);
  }

  // _____________________CHAPTER 1_____________________

  /**
   * Parse a lambda expression.
   * @param group
   * @returns
   */
  private parseLambda(group: Group): Atomic.Lambda {
    // Form: (lambda (<identifier>*) <body>+)
    //     | (lambda (<identifier>* . <rest-identifier>) <body>+)
    // ensure that the group has at least 3 elements
    if (group.length() < 3) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(lambda (<identifier>* . <rest-identifier>?) <body>+) | (lambda <rest-identifer> <body>+)"
      );
    }
    const elements = group.unwrap();
    const formals = elements[1];
    const body = elements.slice(2);

    // Formals should be a group of identifiers or a single identifier
    let convertedFormals: Atomic.Identifier[] = [];
    // if a rest element is detected,
    let convertedRest: Atomic.Identifier | undefined = undefined;
    if (isToken(formals)) {
      if (formals.type !== TokenType.IDENTIFIER) {
        throw new ParserError.ExpectedFormError(
          this.source,
          formals.pos,
          formals,
          "<rest-identifier>"
        );
      }
      convertedRest = new Atomic.Identifier(
        this.toLocation(formals),
        formals.lexeme
      );
    } else {
      // it is a group
      const formalsElements = formals.unwrap();
      [convertedFormals, convertedRest] = this.destructureList(
        formalsElements,
        // pass in a verifier that checks if the elements are identifiers
        formal => {
          if (!isToken(formal)) {
            throw new ParserError.ExpectedFormError(
              this.source,
              formal.pos,
              formal,
              "<identifier>"
            );
          }
          if (formal.type !== TokenType.IDENTIFIER) {
            throw new ParserError.ExpectedFormError(
              this.source,
              formal.pos,
              formal,
              "<identifier>"
            );
          }
        }
      ) as [Atomic.Identifier[], Atomic.Identifier | undefined];
    }

    // Body is treated as a group of expressions
    const convertedBody = body.map(
      this.parseExpression.bind(this)
    ) as Expression[];

    // assert that body is not empty
    if (convertedBody.length < 1) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(lambda ... <body>+)"
      );
    }

    if (convertedBody.length === 1) {
      return new Atomic.Lambda(
        group.location,
        convertedBody[0],
        convertedFormals,
        convertedRest
      );
    }

    const newLocation = convertedBody
      .at(0)!
      .location.merge(convertedBody.at(-1)!.location);
    const bodySequence = new Atomic.Sequence(newLocation, convertedBody);
    return new Atomic.Lambda(
      group.location,
      bodySequence,
      convertedFormals,
      convertedRest
    );
  }

  /**
   * Parse a define expression.
   * @param group
   * @returns
   */
  private parseDefinition(
    group: Group
  ): Atomic.Definition | Extended.FunctionDefinition {
    // Form: (define <identifier> <expr>)
    //     | (define (<identifier> <formals>) <body>)
    //     | (define (<identifier> <formals>) <body> <body>*)
    // ensure that the group has at least 3 elements
    if (group.length() < 3) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(define <identifier> <expr>) | (define (<identifier> <formals>) <body>+)"
      );
    }
    const elements = group.unwrap();
    const identifier = elements[1];
    const expr = elements.slice(2);

    let convertedIdentifier: Atomic.Identifier;
    let convertedFormals: Atomic.Identifier[] = [];
    let convertedRest: Atomic.Identifier | undefined = undefined;
    let isFunctionDefinition = false;

    // Identifier may be a token or a group of identifiers
    if (isGroup(identifier)) {
      // its a function definition
      isFunctionDefinition = true;
      const identifierElements = identifier.unwrap();
      const functionName = identifierElements[0];
      const formals = identifierElements.splice(1);

      // verify that the first element is an identifier
      if (!isToken(functionName)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          functionName.location.start,
          functionName,
          "<identifier>"
        );
      }
      if (functionName.type !== TokenType.IDENTIFIER) {
        throw new ParserError.ExpectedFormError(
          this.source,
          functionName.pos,
          functionName,
          "<identifier>"
        );
      }

      // convert the first element to an identifier
      convertedIdentifier = new Atomic.Identifier(
        this.toLocation(functionName),
        functionName.lexeme
      );

      // Formals should be a group of identifiers
      [convertedFormals, convertedRest] = this.destructureList(
        formals,
        formal => {
          if (!isToken(formal)) {
            throw new ParserError.ExpectedFormError(
              this.source,
              formal.pos,
              formal,
              "<identifier>"
            );
          }
          if (formal.type !== TokenType.IDENTIFIER) {
            throw new ParserError.ExpectedFormError(
              this.source,
              formal.pos,
              formal,
              "<identifier>"
            );
          }
        }
      ) as [Atomic.Identifier[], Atomic.Identifier | undefined];
    } else if (identifier.type !== TokenType.IDENTIFIER) {
      throw new ParserError.ExpectedFormError(
        this.source,
        identifier.pos,
        identifier,
        "<identifier>"
      );
    } else {
      // its a normal definition
      convertedIdentifier = new Atomic.Identifier(
        this.toLocation(identifier),
        identifier.lexeme
      );
      isFunctionDefinition = false;
    }

    // expr cannot be empty
    if (expr.length < 1) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(define ... <body>+)"
      );
    }

    if (isFunctionDefinition) {
      // Body is treated as a group of expressions
      const convertedBody = expr.map(
        this.parseExpression.bind(this)
      ) as Expression[];

      if (convertedBody.length === 1) {
        return new Extended.FunctionDefinition(
          group.location,
          convertedIdentifier,
          convertedBody[0],
          convertedFormals,
          convertedRest
        );
      }

      const newLocation = convertedBody
        .at(0)!
        .location.merge(convertedBody.at(-1)!.location);
      const bodySequence = new Atomic.Sequence(newLocation, convertedBody);

      return new Extended.FunctionDefinition(
        group.location,
        convertedIdentifier,
        bodySequence,
        convertedFormals,
        convertedRest
      );
    }

    // its a normal definition

    if (expr.length > 1) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(define <identifier> <expr>)"
      );
    }

    // Expr is treated as a single expression
    const convertedExpr = this.parseExpression(expr[0]);

    return new Atomic.Definition(
      group.location,
      convertedIdentifier,
      convertedExpr
    );
  }

  /**
   * Parse a conditional expression.
   * @param group
   * @returns
   */
  private parseConditional(group: Group): Atomic.Conditional {
    // Form: (if <pred> <cons> <alt>)
    //     | (if <pred> <cons>)

    // ensure that the group has 3 or 4 elements
    if (group.length() < 3 || group.length() > 4) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(if <pred> <cons> <alt>?)"
      );
    }
    const elements = group.unwrap();
    const test = elements[1];
    const consequent = elements[2];
    const alternate = group.length() > 3 ? elements[3] : undefined;

    // Test is treated as a single expression
    const convertedTest = this.parseExpression(test);

    // Consequent is treated as a single expression
    const convertedConsequent = this.parseExpression(consequent);

    // Alternate is treated as a single expression

    const convertedAlternate = alternate
      ? this.parseExpression(alternate)
      : new Atomic.Identifier(group.location, "undefined");

    return new Atomic.Conditional(
      group.location,
      convertedTest,
      convertedConsequent,
      convertedAlternate
    );
  }

  /**
   * Parse an application expression.
   */
  private parseApplication(group: Group): Atomic.Application {
    // Form: (<func> <args>*)
    // ensure that the group has at least 1 element
    if (group.length() < 1) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(<func> <args>*)"
      );
    }
    const elements = group.unwrap();
    const operator = elements[0];
    const operands = elements.splice(1);

    // Operator is treated as a single expression
    const convertedOperator = this.parseExpression(operator);

    // Operands are treated as a group of expressions
    const convertedOperands: Expression[] = [];
    for (const operand of operands) {
      convertedOperands.push(this.parseExpression(operand));
    }

    return new Atomic.Application(
      group.location,
      convertedOperator,
      convertedOperands
    );
  }

  /**
   * Parse a let expression.
   * @param group
   * @returns
   */
  private parseLet(group: Group): Extended.Let {
    if (this.chapter >= MACRO_CHAPTER) {
      // disable any verification for the let expression
      const groupItems = group.unwrap().slice(1);
      groupItems.forEach(item => {
        this.parseExpression(item);
      });
      return new Extended.Let(
        group.location,
        [],
        [],
        new Atomic.Identifier(group.location, "undefined")
      );
    }
    // Form: (let ((<identifier> <value>)*) <body>+)
    // ensure that the group has at least 3 elements
    if (group.length() < 3) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(let ((<identifier> <value>)*) <body>+)"
      );
    }
    const elements = group.unwrap();
    const bindings = elements[1];
    const body = elements.slice(2);

    // Verify bindings is a group
    if (!isGroup(bindings)) {
      throw new ParserError.ExpectedFormError(
        this.source,
        bindings.pos,
        bindings,
        "((<identifier> <value>)*)"
      );
    }

    // Bindings are treated as a group of grouped identifiers and values
    const convertedIdentifiers: Atomic.Identifier[] = [];
    const convertedValues: Expression[] = [];

    const bindingElements = bindings.unwrap();
    for (const bindingElement of bindingElements) {
      // Verify bindingElement is a group of size 2
      if (!isGroup(bindingElement)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          bindingElement.pos,
          bindingElement,
          "(<identifier> <value>)"
        );
      }
      if (bindingElement.length() !== 2) {
        throw new ParserError.ExpectedFormError(
          this.source,
          bindingElement.location.start,
          bindingElement,
          "(<identifier> <value>)"
        );
      }

      const [identifier, value] = bindingElement.unwrap();

      // Verify identifier is a token and an identifier
      if (!isToken(identifier)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          identifier.location.start,
          identifier,
          "<identifier>"
        );
      }
      if (identifier.type !== TokenType.IDENTIFIER) {
        throw new ParserError.ExpectedFormError(
          this.source,
          identifier.pos,
          identifier,
          "<identifier>"
        );
      }
      convertedIdentifiers.push(
        new Atomic.Identifier(this.toLocation(identifier), identifier.lexeme)
      );
      convertedValues.push(this.parseExpression(value));
    }

    // Body is treated as a group of expressions
    const convertedBody = body.map(
      this.parseExpression.bind(this)
    ) as Expression[];

    // assert that body is not empty
    if (convertedBody.length < 1) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(let ... <body>+)"
      );
    }

    if (convertedBody.length === 1) {
      return new Extended.Let(
        group.location,
        convertedIdentifiers,
        convertedValues,
        convertedBody[0]
      );
    }

    const newLocation = convertedBody
      .at(0)!
      .location.merge(convertedBody.at(-1)!.location);
    const bodySequence = new Atomic.Sequence(newLocation, convertedBody);

    return new Extended.Let(
      group.location,
      convertedIdentifiers,
      convertedValues,
      bodySequence
    );
  }

  /**
   * Parse an extended cond expression.
   * @param group
   * @returns
   */
  private parseExtendedCond(group: Group): Extended.Cond {
    if (this.chapter >= MACRO_CHAPTER) {
      // disable any verification for the cond expression
      const groupItems = group.unwrap().slice(1);
      groupItems.forEach(item => {
        this.parseExpression(item);
      });
      return new Extended.Cond(
        group.location,
        [],
        [],
        new Atomic.Identifier(group.location, "undefined")
      );
    }
    // Form: (cond (<pred> <body>)*)
    //     | (cond (<pred> <body>)* (else <val>))
    // ensure that the group has at least 2 elements
    if (group.length() < 2) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(cond (<pred> <body>*)* (else <val>)?)"
      );
    }
    const elements = group.unwrap();
    const clauses = elements.splice(1);
    // safe to cast because of the check above
    const lastClause = <Datum>clauses.pop();

    // Clauses are treated as a group of groups of expressions
    // Form: (<pred> <body>*)
    const convertedClauses: Expression[] = [];
    const convertedConsequents: Expression[] = [];

    for (const clause of clauses) {
      // Verify clause is a group with size no less than 1
      if (!isGroup(clause)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          clause.pos,
          clause,
          "(<pred> <body>*)"
        );
      }
      if (clause.length() < 1) {
        throw new ParserError.ExpectedFormError(
          this.source,
          clause.firstToken().pos,
          clause.firstToken(),
          "(<pred> <body>*)"
        );
      }

      const [test, ...consequent] = clause.unwrap();

      // verify that test is NOT an else token
      if (isToken(test) && test.type === TokenType.ELSE) {
        throw new ParserError.ExpectedFormError(
          this.source,
          test.pos,
          test,
          "<predicate>"
        );
      }

      // Test is treated as a single expression
      const convertedTest = this.parseExpression(test);

      // Consequent is treated as a group of expressions
      const consequentExpressions = consequent.map(
        this.parseExpression.bind(this)
      ) as Expression[];
      const consequentLocation =
        consequent.length < 1
          ? convertedTest.location
          : consequentExpressions
              .at(0)!
              .location.merge(consequentExpressions.at(-1)!.location);

      // if consequent is empty, the test itself is treated
      // as the value returned.
      // if consequent is more than length one, there is a sequence.
      const convertedConsequent =
        consequent.length < 1
          ? convertedTest
          : consequent.length < 2
            ? consequentExpressions[0]
            : new Atomic.Sequence(consequentLocation, consequentExpressions);

      convertedClauses.push(convertedTest);
      convertedConsequents.push(convertedConsequent);
    }

    // Check last clause
    // Verify lastClause is a group with size at least 2
    if (!isGroup(lastClause)) {
      throw new ParserError.ExpectedFormError(
        this.source,
        lastClause.pos,
        lastClause,
        "(<pred> <body>+) | (else <val>)"
      );
    }

    if (lastClause.length() < 2) {
      throw new ParserError.ExpectedFormError(
        this.source,
        lastClause.firstToken().pos,
        lastClause.firstToken(),
        "(<pred> <body>+) | (else <val>)"
      );
    }

    const [test, ...consequent] = lastClause.unwrap();

    let isElse = false;

    // verify that test is an else token
    if (isToken(test) && test.type === TokenType.ELSE) {
      isElse = true;
      // verify that consequent is of length 1
      if (consequent.length !== 1) {
        throw new ParserError.ExpectedFormError(
          this.source,
          lastClause.location.start,
          lastClause,
          "(else <val>)"
        );
      }
    }

    // verify that consequent is at least 1 expression
    if (consequent.length < 1) {
      throw new ParserError.ExpectedFormError(
        this.source,
        lastClause.location.start,
        lastClause,
        "(<pred> <body>+)"
      );
    }

    // Consequent is treated as a group of expressions
    const consequentExpressions = consequent.map(
      this.parseExpression.bind(this)
    ) as Expression[];
    const consequentLocation = consequentExpressions
      .at(0)!
      .location.merge(consequentExpressions.at(-1)!.location);
    const lastConsequent =
      consequent.length === 1
        ? consequentExpressions[0]
        : new Atomic.Sequence(consequentLocation, consequentExpressions);

    if (isElse) {
      return new Extended.Cond(
        group.location,
        convertedClauses,
        convertedConsequents,
        lastConsequent
      );
    }

    // If the last clause is not an else clause, we treat it as a normal cond clause instead
    const lastTest = this.parseExpression(test);

    // Test
    convertedClauses.push(lastTest);
    convertedConsequents.push(lastConsequent);

    return new Extended.Cond(
      group.location,
      convertedClauses,
      convertedConsequents
    );
  }

  // _____________________CHAPTER 3_____________________

  /**
   * Parse a reassignment expression.
   * @param group
   * @returns
   */
  private parseSet(group: Group): Atomic.Reassignment {
    // Form: (set! <identifier> <expr>)
    // ensure that the group has 3 elements
    if (group.length() !== 3) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(set! <identifier> <expr>)"
      );
    }
    const elements = group.unwrap();
    const identifier = elements[1];
    const expr = elements[2];

    // Identifier is treated as a single identifier
    if (isGroup(identifier)) {
      throw new ParserError.ExpectedFormError(
        this.source,
        identifier.location.start,
        identifier,
        "<identifier>"
      );
    }
    if (identifier.type !== TokenType.IDENTIFIER) {
      throw new ParserError.ExpectedFormError(
        this.source,
        identifier.pos,
        identifier,
        "<identifier>"
      );
    }
    const convertedIdentifier = new Atomic.Identifier(
      this.toLocation(identifier),
      identifier.lexeme
    );
    const convertedExpr = this.parseExpression(expr);
    return new Atomic.Reassignment(
      group.location,
      convertedIdentifier,
      convertedExpr
    );
  }

  /**
   * Parse a begin expression.
   * @param group
   * @returns
   */
  private parseBegin(group: Group): Extended.Begin {
    // Form: (begin <body>+)
    // ensure that the group has 2 or more elements
    if (group.length() < 2) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(begin <body>+)"
      );
    }
    const sequence = group.unwrap();
    const sequenceElements = sequence.slice(1);
    const convertedExpressions: Expression[] = [];
    for (const sequenceElement of sequenceElements) {
      convertedExpressions.push(this.parseExpression(sequenceElement));
    }
    return new Extended.Begin(group.location, convertedExpressions);
  }

  /**
   * Parse a delay expression.
   * @param group
   * @returns
   */
  private parseDelay(group: Group): Extended.Delay {
    if (this.chapter >= MACRO_CHAPTER) {
      // disable any verification for the delay expression
      const groupItems = group.unwrap().slice(1);
      groupItems.forEach(item => {
        this.parseExpression(item);
      });
      return new Extended.Delay(
        group.location,
        new Atomic.Identifier(group.location, "undefined")
      );
    }
    // Form: (delay <expr>)
    // ensure that the group has 2 elements
    if (group.length() !== 2) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(delay <expr>)"
      );
    }
    const elements = group.unwrap();
    const expr = elements[1];

    // Expr is treated as a single expression
    const convertedExpr = this.parseExpression(expr);

    return new Extended.Delay(group.location, convertedExpr);
  }

  // _____________________CHAPTER 3_____________________

  /**
   * Parse a define-syntax expression.
   * @param group
   * @returns nothing, this is for verification only.
   */
  private parseDefineSyntax(group: Group): Atomic.DefineSyntax {
    // Form: (define-syntax <identifier> <transformer>)
    // ensure that the group has 3 elements
    if (group.length() !== 3) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(define-syntax <identifier> <transformer>)"
      );
    }
    const elements = group.unwrap();
    const identifier = elements[1];
    const transformer = elements[2];

    // parse the identifier using quote mode
    // (to capture redefinitions of syntax)
    this.quoteMode = QuoteMode.QUOTE;
    const convertedIdentifier = this.parseExpression(
      identifier
    ) as Atomic.Identifier;
    this.quoteMode = QuoteMode.NONE;

    if (!(convertedIdentifier instanceof Atomic.Symbol)) {
      throw new ParserError.ExpectedFormError(
        this.source,
        convertedIdentifier.location.start,
        identifier,
        "<identifier>"
      );
    }

    // Transformer is treated as a group
    // it should be syntax-rules
    if (!isGroup(transformer)) {
      throw new ParserError.ExpectedFormError(
        this.source,
        transformer.pos,
        transformer,
        "<transformer>"
      );
    }

    if (transformer.length() < 2) {
      throw new ParserError.ExpectedFormError(
        this.source,
        transformer.firstToken().pos,
        transformer,
        "(syntax-rules ...)"
      );
    }
    const transformerToken = transformer.unwrap()[0];
    if (!isToken(transformer.unwrap()[0])) {
      throw new ParserError.ExpectedFormError(
        this.source,
        transformer.firstToken().pos,
        transformerToken,
        "syntax-rules"
      );
    }

    if ((transformerToken as Token).type !== TokenType.SYNTAX_RULES) {
      throw new ParserError.ExpectedFormError(
        this.source,
        (transformerToken as Token).pos,
        transformerToken,
        "syntax-rules"
      );
    }

    // parse the transformer
    const convertedTransformer = this.parseSyntaxRules(
      transformer
    ) as Atomic.SyntaxRules;

    return new Atomic.DefineSyntax(
      group.location,
      convertedIdentifier,
      convertedTransformer
    );
  }

  /**
   * Helper function to verify the validity of a pattern.
   * @param pattern
   * @returns validity of the pattern
   */
  private isValidPattern(pattern: Expression): boolean {
    // a pattern is either a symbol, a literal or
    // a list (<pattern>+), (<pattern>+ . <pattern>), (<pattern>+ ... <pattern>*)
    // or (<pattern>+ ... <pattern>+ . <pattern>)
    if (pattern instanceof Extended.List) {
      // check if the list is a proper list
      const isProper = pattern.terminator === undefined;
      if (isProper) {
        // scan to make sure that only one ellipsis is present
        const ellipsisCount = pattern.elements.filter(
          item => item instanceof Atomic.Symbol && item.value === "..."
        ).length;

        if (ellipsisCount > 1) {
          return false;
        }

        const ellipsisIndex = pattern.elements.findIndex(
          item => item instanceof Atomic.Symbol && item.value === "..."
        );

        if (ellipsisIndex != -1) {
          // check if the ellipsis is behind any other element
          // (ie it's not the first element)
          if (ellipsisIndex === 0) {
            return false;
          }
        }

        // recursively check the elements
        for (const element of pattern.elements) {
          if (!this.isValidPattern(element)) {
            return false;
          }
        }

        return true;
      } else {
        // scan to make sure that only one ellipsis is present
        const ellipsisCount = pattern.elements.filter(
          item => item instanceof Atomic.Symbol && item.value === "..."
        ).length;

        if (ellipsisCount > 1) {
          return false;
        }

        const ellipsisIndex = pattern.elements.findIndex(
          item => item instanceof Atomic.Symbol && item.value === "..."
        );

        if (ellipsisIndex != -1) {
          // check if the ellipsis is behind any other element
          // (ie it's not the first element)
          if (ellipsisIndex === 0) {
            return false;
          }

          // since this is an improper list, the ellipsis must not
          // be the last element either
          if (ellipsisIndex === pattern.elements.length - 1) {
            return false;
          }
        }

        // recursively check the elements
        for (const element of pattern.elements) {
          if (!this.isValidPattern(element)) {
            return false;
          }
        }

        return this.isValidPattern(pattern.terminator as Expression);
      }
    } else if (
      pattern instanceof Atomic.Symbol ||
      pattern instanceof Atomic.BooleanLiteral ||
      pattern instanceof Atomic.NumericLiteral ||
      pattern instanceof Atomic.StringLiteral ||
      pattern instanceof Atomic.Nil
    ) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Helper function to verify the validity of a template.
   * @param template
   * @returns validity of the template
   */
  private isValidTemplate(template: Expression): boolean {
    // a template is either a symbol, a literal or
    // a list (<element>+), (<element>+ . <template>), (... <template>)
    // where <element> is a template optionally followed by ...
    if (template instanceof Extended.List) {
      // check if the list is a proper list
      const isProper = template.terminator === undefined;
      if (isProper) {
        // should have at least 1 element
        if (template.elements.length === 0) {
          return false;
        }

        // (... <template>) case
        if (
          template.elements.length === 2 &&
          template.elements[0] instanceof Atomic.Symbol &&
          template.elements[0].value === "..."
        ) {
          return this.isValidTemplate(template.elements[1]);
        }

        let ellipsisWorksOnLastElement = false;
        // check each element for validity except for ellipses.
        // for those, check if they follow a valid template.
        for (let i = 0; i < template.elements.length; i++) {
          const element = template.elements[i];
          if (element instanceof Atomic.Symbol && element.value === "...") {
            if (ellipsisWorksOnLastElement) {
              ellipsisWorksOnLastElement = false;
              continue;
            }
            // either consecutive ellipses or the first element is an ellipsis
            return false;
          } else {
            if (!this.isValidTemplate(element)) {
              return false;
            }
            ellipsisWorksOnLastElement = true;
          }
        }
        return true;
      } else {
        if (template.elements.length === 0) {
          return false;
        }

        let ellipsisWorksOnLastElement = false;
        // check each element for validity except for ellipses.
        // for those, check if they follow a valid template.
        for (let i = 0; i < template.elements.length; i++) {
          const element = template.elements[i];
          if (element instanceof Atomic.Symbol && element.value === "...") {
            if (ellipsisWorksOnLastElement) {
              ellipsisWorksOnLastElement = false;
              continue;
            }
            // either consecutive ellipses or the first element is an ellipsis
            return false;
          } else {
            if (!this.isValidTemplate(element)) {
              return false;
            }
            ellipsisWorksOnLastElement = true;
          }
        }
        return this.isValidTemplate(template.terminator as Expression);
      }
    } else if (
      template instanceof Atomic.Symbol ||
      template instanceof Atomic.BooleanLiteral ||
      template instanceof Atomic.NumericLiteral ||
      template instanceof Atomic.StringLiteral ||
      template instanceof Atomic.Nil
    ) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Parse a syntax-rules expression.
   * @param group
   * @returns nothing, this is for verification only.
   */
  private parseSyntaxRules(group: Group): Atomic.SyntaxRules {
    // syntax rules is of form
    // (syntax-rules (<literal>*) <syntax-rule>+)
    // where syntax-rule is of form
    // (<pattern> <template>)
    // ensure that the group has at least 3 elements
    if (group.length() < 3) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.location.start,
        group,
        "(syntax-rules (<literal>*) <syntax-rule>+)"
      );
    }

    const elements = group.unwrap();
    const literals = elements[1];
    const rules = elements.slice(2);

    const finalLiterals: Atomic.Symbol[] = [];
    // verify that literals is a group
    if (!isGroup(literals)) {
      throw new ParserError.ExpectedFormError(
        this.source,
        literals.pos,
        literals,
        "(<literal>*)"
      );
    }

    // parse each literal as a symbol
    this.quoteMode = QuoteMode.QUOTE;
    for (const literal of literals.unwrap()) {
      if (!isToken(literal)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          literal.location.start,
          literal,
          "<literal>"
        );
      }

      const convertedLiteral = this.parseExpression(literal);
      if (!(convertedLiteral instanceof Atomic.Symbol)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          literal.pos,
          literal,
          "<literal>"
        );
      }
      finalLiterals.push(convertedLiteral);
    }

    const finalRules: [Expression, Expression][] = [];

    // each rule is a group of size 2
    for (const rule of rules) {
      if (!isGroup(rule)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          rule.pos,
          rule,
          "(<pattern> <template>)"
        );
      }
      if (rule.length() !== 2) {
        throw new ParserError.ExpectedFormError(
          this.source,
          rule.location.start,
          rule,
          "(<pattern> <template>)"
        );
      }
      // verify the validity of the pattern and template
      const [pattern, template] = rule.unwrap();

      const convertedPattern = this.parseExpression(pattern);
      const convertedTemplate = this.parseExpression(template);

      if (!this.isValidPattern(convertedPattern)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          convertedPattern.location.start,
          pattern,
          "<symbol> | <literal> | (<pattern>+) | (<pattern>+ ... <pattern>*) | (<pattern>+ ... <pattern>+ . <pattern>)"
        );
      }

      if (!this.isValidTemplate(convertedTemplate)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          convertedTemplate.location.start,
          template,
          "<symbol> | <literal> | (<element>+) | (<element>+ . <template>) | (... <template>)"
        );
      }

      finalRules.push([convertedPattern, convertedTemplate]);
    }

    this.quoteMode = QuoteMode.NONE;
    return new Atomic.SyntaxRules(group.location, finalLiterals, finalRules);
  }

  // ___________________MISCELLANEOUS___________________

  /**
   * Parse an import expression.
   * @param group
   * @returns
   */
  private parseImport(group: Group): Atomic.Import {
    // Form: (import "<source>" (<identifier>*))
    // ensure that the group has 3 elements
    if (group.length() !== 3) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.firstToken().pos,
        group.firstToken(),
        '(import "<source>" (<identifier>*))'
      );
    }
    const elements = group.unwrap();
    const source = elements[1];
    const identifiers = elements[2];

    // source is treated as a single string
    if (!isToken(source)) {
      throw new ParserError.ExpectedFormError(
        this.source,
        source.location.start,
        source,
        '"<source>"'
      );
    }
    if (source.type !== TokenType.STRING) {
      throw new ParserError.ExpectedFormError(
        this.source,
        source.pos,
        source,
        '"<source>"'
      );
    }

    // Identifiers are treated as a group of identifiers
    if (!isGroup(identifiers)) {
      throw new ParserError.ExpectedFormError(
        this.source,
        identifiers.pos,
        identifiers,
        "(<identifier>*)"
      );
    }
    const identifierElements = identifiers.unwrap();
    const convertedIdentifiers: Atomic.Identifier[] = [];
    for (const identifierElement of identifierElements) {
      if (!isToken(identifierElement)) {
        throw new ParserError.ExpectedFormError(
          this.source,
          identifierElement.location.start,
          identifierElement,
          "<identifier>"
        );
      }
      if (identifierElement.type !== TokenType.IDENTIFIER) {
        throw new ParserError.ExpectedFormError(
          this.source,
          identifierElement.pos,
          identifierElement,
          "<identifier>"
        );
      }
      convertedIdentifiers.push(
        new Atomic.Identifier(
          this.toLocation(identifierElement),
          identifierElement.lexeme
        )
      );
    }
    const convertedSource = new Atomic.StringLiteral(
      this.toLocation(source),
      source.literal
    );
    return new Atomic.Import(
      group.location,
      convertedSource,
      convertedIdentifiers
    );
  }

  /**
   * Parse an export expression.
   * @param group
   * @returns
   */
  private parseExport(group: Group): Atomic.Export {
    // Form: (export (<definition>))
    // ensure that the group has 2 elements
    if (group.length() !== 2) {
      throw new ParserError.ExpectedFormError(
        this.source,
        group.firstToken().pos,
        group.firstToken(),
        "(export (<definition>))"
      );
    }
    const elements = group.unwrap();
    const definition = elements[1];

    // assert that definition is a group
    if (!isGroup(definition)) {
      throw new ParserError.ExpectedFormError(
        this.source,
        definition.pos,
        definition,
        "(<definition>)"
      );
    }

    const convertedDefinition = this.parseExpression(definition);
    // assert that convertedDefinition is a definition
    if (
      !(
        convertedDefinition instanceof Atomic.Definition ||
        convertedDefinition instanceof Extended.FunctionDefinition
      )
    ) {
      throw new ParserError.ExpectedFormError(
        this.source,
        definition.location.start,
        definition,
        "(<definition>)"
      );
    }

    return new Atomic.Export(group.location, convertedDefinition);
  }

  /**
   * Parses a vector expression
   */
  private parseVector(group: Group): Atomic.Vector {
    // Because of the group invariants, we can safely assume that the group
    // is strictly of size 2.
    // Additionally, we can safely assume that the second element is a group
    // because token HASH_VECTOR expects a parenthesis as the next immediate
    // token.
    const elements = group.unwrap()[1] as Group;

    // Vectors will be treated normally regardless of the quote mode.
    // but interior expressions will be affected by the mode.
    const convertedElements = elements
      .unwrap()
      .map(this.parseExpression.bind(this)) as Expression[];

    return new Atomic.Vector(group.location, convertedElements);
  }

  // ___________________________________________________

  /** Parses a sequence of tokens into an AST.
   *
   * @param group A group of tokens.
   * @returns An AST.
   */
  parse(reparseAsSexpr: boolean = false): Expression[] {
    if (reparseAsSexpr) {
      this.quoteMode = QuoteMode.QUOTE;
      this.current = 0;
    }
    // collect all top-level elements
    const topElements: Expression[] = [];
    while (!this.isAtEnd()) {
      if (this.peek().type === TokenType.EOF) {
        break;
      }
      const currentElement = this.grouping();
      if (!currentElement) {
        continue;
      }
      const convertedElement = this.parseExpression(currentElement);
      topElements.push(convertedElement);
    }
    // if we are in the macro chapter,
    // everything we have done so far was only to verify the program.
    // we return everything as an s-expression - that is, we quote the
    // entire program.
    if (this.chapter >= MACRO_CHAPTER && !reparseAsSexpr) {
      // so, redo the entire parsing, but now with the quote mode on.
      // we do need to remove the imports from the top level elements,
      // and append them here.

      // assumption - all imports are top level forms. We will hoist all imports to the top.
      // TODO: Figure out how to assert imports as top level forms.
      const importElements: Expression[] = topElements.filter(
        e => e instanceof Atomic.Import
      );
      const sexprElements = this.parse(true);

      // we remove all of the quoted imports from the sexprElements.
      // an import can be detected as a list
      // that is not empty
      // whose first element is a symbol
      // in which the name is "import".
      const restElements = sexprElements.filter(
        e =>
          !(
            e instanceof Extended.List &&
            e.elements &&
            e.elements[0] instanceof Atomic.Symbol &&
            e.elements[0].value === "import"
          )
      );

      return [...importElements, ...restElements];
    }
    return topElements;
  }
}
</file>

<file path="src/scheme_parser/utils/estree-nodes.ts">
/* Library for building ESTree nodes. */

import {
  Program,
  Expression,
  Statement,
  ExpressionStatement,
  BlockStatement,
  ArrayExpression,
  VariableDeclaration,
  CallExpression,
  ArrowFunctionExpression,
  Literal,
  Identifier,
  SourceLocation,
  ConditionalExpression,
  AssignmentExpression,
  ImportSpecifier,
  ModuleDeclaration,
  RestElement,
} from "estree";

export function makeProgram(body: Statement[] = []): Program {
  // generate a good location based on the start of the first element of the body
  // and its last, as long as the body is not empty
  const loc =
    body.length > 0
      ? {
          start: body[0].loc!.start,
          end: body[body.length - 1].loc!.end,
        }
      : {
          start: { line: 1, column: 0 },
          end: { line: 1, column: 0 },
        };
  return {
    type: "Program",
    body,
    sourceType: "module",
    loc: loc,
  };
}

export function makeDeclaration(
  kind: "var" | "let" | "const",
  id: Identifier,
  init: Expression,
  loc?: SourceLocation
): VariableDeclaration {
  return {
    type: "VariableDeclaration",
    kind,
    declarations: [
      {
        type: "VariableDeclarator",
        id,
        init,
      },
    ],
    loc: loc ? loc : id.loc,
  };
}

export function makeIdentifier(name: string, loc?: SourceLocation): Identifier {
  return {
    type: "Identifier",
    name,
    loc,
  };
}

export function makeLiteral(
  value: string | number | boolean | null | undefined,
  loc?: SourceLocation
): Literal {
  return {
    type: "Literal",
    value,
    raw: `"${value}"`,
    loc,
  } as Literal;
}

export function makeArrowFunctionExpression(
  params: (Identifier | RestElement)[],
  body: Expression | BlockStatement,
  loc?: SourceLocation
): ArrowFunctionExpression {
  return {
    type: "ArrowFunctionExpression",
    params,
    body,
    async: false,
    expression: body.type !== "BlockStatement",
    loc: loc ? loc : body.loc,
  };
}

export function makeBlockStatement(
  body: Statement[],
  loc?: SourceLocation
): BlockStatement {
  return {
    type: "BlockStatement",
    body,
    loc: loc
      ? loc
      : {
          start: body[0].loc!.start,
          end: body[body.length - 1].loc!.end,
        },
  };
}

export function makeCallExpression(
  callee: Expression,
  args: Expression[],
  loc?: SourceLocation
): CallExpression {
  return {
    type: "CallExpression",
    optional: false,
    callee,
    arguments: args,
    loc: loc
      ? loc
      : {
          start: callee.loc!.start,
          end: args[args.length - 1].loc!.end,
        },
  };
}

export function makeConditionalExpression(
  test: Expression,
  consequent: Expression,
  alternate: Expression,
  loc?: SourceLocation
): ConditionalExpression {
  return {
    type: "ConditionalExpression",
    test,
    consequent,
    alternate,
    loc: loc
      ? loc
      : {
          start: test.loc!.start,
          end: alternate.loc!.end,
        },
  };
}

export function makeAssignmentExpression(
  left: Identifier,
  right: Expression,
  loc?: SourceLocation
): AssignmentExpression {
  return {
    type: "AssignmentExpression",
    operator: "=",
    left,
    right,
    loc: loc
      ? loc
      : {
          start: left.loc!.start,
          end: right.loc!.end,
        },
  };
}

export function makeExpressionStatement(
  expression: Expression,
  loc?: SourceLocation
): ExpressionStatement {
  return {
    type: "ExpressionStatement",
    expression,
    loc: loc ? loc : expression.loc,
  };
}

export function makeReturnStatement(
  argument: Expression,
  loc?: SourceLocation
): Statement {
  return {
    type: "ReturnStatement",
    argument,
    loc: loc ? loc : argument.loc,
  };
}

export function makeRestElement(
  argument: Identifier,
  loc?: SourceLocation
): RestElement {
  return {
    type: "RestElement",
    argument,
    loc: loc ? loc : argument.loc,
  };
}

export function makeArrayExpression(
  elements: Expression[],
  loc?: SourceLocation
): ArrayExpression {
  return {
    type: "ArrayExpression",
    elements,
    loc: loc
      ? loc
      : {
          start: elements[0].loc!.start,
          end: elements[elements.length - 1].loc!.end,
        },
  };
}

export function makeImportSpecifier(
  imported: Identifier,
  local: Identifier,
  loc?: SourceLocation
): ImportSpecifier {
  return {
    type: "ImportSpecifier",
    imported,
    local,
    loc: loc ? loc : imported.loc,
  };
}

export function makeImportDeclaration(
  specifiers: ImportSpecifier[],
  source: Literal,
  loc?: SourceLocation
): ModuleDeclaration {
  return {
    type: "ImportDeclaration",
    specifiers,
    source,
    attributes: [],
    loc: loc
      ? loc
      : {
          start: specifiers[0].loc!.start,
          end: source.loc!.end,
        },
  };
}

export function makeExportNamedDeclaration(
  declaration: VariableDeclaration,
  loc?: SourceLocation
): ModuleDeclaration {
  return {
    type: "ExportNamedDeclaration",
    specifiers: [],
    source: null,
    declaration,
    attributes: [],
    loc: loc ? loc : declaration.loc,
  };
}
</file>

<file path="src/scheme_parser/core-math.ts">
// The core library of scm-slang,
// different from the base library,
// this library contains all methods required
// for the language to function properly.

// This file contains the minimum subset
// required for arithmetic to work.
// which includes the numeric tower,
// as well as the regex forms used to detect numbers.

export type SchemeNumber =
  | SchemeInteger
  | SchemeRational
  | SchemeReal
  | SchemeComplex;

// define here the functions used to check and split the number into its parts

export enum NumberType {
  INTEGER = 1,
  RATIONAL = 2,
  REAL = 3,
  COMPLEX = 4,
}

export abstract class Match {
  constructor(public result: boolean) {}
  abstract build(): SchemeNumber;
}

class IntegerMatch extends Match {
  constructor(
    public result: boolean,
    public value?: string
  ) {
    super(result);
  }

  isSigned(): boolean {
    return this.result
      ? this.value![0] === "+" || this.value![0] === "-"
      : false;
  }

  build(): SchemeInteger {
    return SchemeInteger.build(this.value!);
  }
}

class RationalMatch extends Match {
  constructor(
    public result: boolean,
    public numerator?: string,
    public denominator?: string
  ) {
    super(result);
  }

  build(): SchemeInteger | SchemeRational {
    return SchemeRational.build(this.numerator!, this.denominator!);
  }
}

class RealMatch extends Match {
  constructor(
    public result: boolean,
    public integer?: string,
    public decimal?: string,
    public exponent?: Match
  ) {
    super(result);
  }

  build(): SchemeReal {
    if (this.integer?.includes("inf")) {
      return this.integer!.includes("-")
        ? SchemeReal.NEG_INFINITY
        : SchemeReal.INFINITY;
    }

    if (this.integer?.includes("nan")) {
      return SchemeReal.NAN;
    }

    // recursively build the exponent
    const exponent = (
      this.exponent ? this.exponent.build() : SchemeReal.INEXACT_ZERO
    ).coerce();

    // we are assured that either part exists
    let value = Number(
      (this.integer ? this.integer : "0") +
        "." +
        (this.decimal ? this.decimal : "0")
    );

    // apply the exponent
    value *= Math.pow(10, exponent);

    return SchemeReal.build(value);
  }
}

class ComplexMatch extends Match {
  constructor(
    public result: boolean,
    public real?: Match,
    public sign?: string,
    public imaginary?: Match
  ) {
    super(result);
  }
  build(): SchemeNumber {
    const real = this.real
      ? (this.real.build() as SchemeInteger | SchemeRational | SchemeReal)
      : SchemeInteger.EXACT_ZERO;
    const imaginary = this.imaginary!.build() as
      | SchemeInteger
      | SchemeRational
      | SchemeReal;

    if (this.sign && this.sign === "-") {
      return SchemeComplex.build(real, imaginary.negate());
    }

    return SchemeComplex.build(real, imaginary);
  }
}

// these are used to determine the type of the number and to separate it into its parts as well
export function isInteger(value: string): IntegerMatch {
  // <integer> = [+-]?<digit>+
  // check if the value is an integer. if it is, return true and the value.
  // if not, return false and an empty array.
  const integerRegex = new RegExp(`^([+-]?)(\\d+)$`);
  const match = integerRegex.exec(value);
  if (match) {
    return new IntegerMatch(true, match[0]);
  }
  return new IntegerMatch(false);
}

export function isRational(value: string): RationalMatch {
  // <rational> = <integer>/<integer>
  // both sides of the rational should parse as integers
  // we can split the rational into two parts and check if both are integers
  // make sure there is a /
  const count = (value.match(/\//g) || []).length;
  if (count !== 1) {
    return new RationalMatch(false);
  }
  const parts = value.split("/");
  if (parts.length !== 2) {
    return new RationalMatch(false);
  }
  const [numerator, denominator] = parts;
  const numeratorMatch = isInteger(numerator);
  const denominatorMatch = isInteger(denominator);

  if (!(numeratorMatch.result && denominatorMatch.result)) {
    return new RationalMatch(false);
  }

  return new RationalMatch(true, numerator, denominator);
}

export function isReal(value: string): RealMatch {
  // <real> = <basic> | <extended>
  // <basic>: [+-]?a.b | [+-]?a | [+-]?.b | [+-]?a.
  // <extended>: <basic>[eE]<integer | rational | real>
  // where a = <digit>+ | inf | nan
  //       b = <digit>+
  //
  // keep in mind that the value matches an integer too! but
  // by the point of time this is called, we have already checked for an integer
  function checkBasicReal(value: string): RealMatch {
    // checks if the value is one of the 4 forms of special numbers
    function isSpecialNumber(value: string): boolean {
      return (
        value === "+inf.0" ||
        value === "-inf.0" ||
        value === "+nan.0" ||
        value === "-nan.0"
      );
    }

    // check if the value is a special number
    if (isSpecialNumber(value)) {
      return new RealMatch(true, value);
    }

    // check for the presence of a dot
    const count = (value.match(/\./g) || []).length;
    if (count > 1) {
      return new RealMatch(false);
    }

    if (count === 0) {
      const result = isInteger(value);
      return new RealMatch(result.result, result.value);
    }

    // check for a basic real number
    const [integerPart, decimalPart] = value.split(".");
    const integerMatch = isInteger(integerPart);
    const decimalMatch = isInteger(decimalPart);

    const properInteger = integerMatch.result || integerPart === "";
    const properDecimal = decimalMatch.result || decimalPart === "";

    // if the integer part is just a sign, the decimal part should be non-empty
    if (integerPart === "+" || integerPart === "-") {
      if (decimalPart === "") {
        return new RealMatch(false);
      }
      return new RealMatch(true, `${integerPart}0`, value);
    }

    // at least one of the parts should be non-empty
    if (
      !(
        (integerMatch.result && properDecimal) ||
        (properInteger && decimalMatch.result)
      )
    ) {
      return new RealMatch(false);
    }

    // if there is a decimal match, there should have no sign
    if (decimalMatch.result && decimalMatch.isSigned()) {
      return new RealMatch(false);
    }

    return new RealMatch(true, integerMatch.value, decimalMatch.value);
  }

  function checkExtendedReal(value: string): RealMatch {
    // split the value into two parts by e/E
    const first_e_index = value.indexOf("e");
    const first_E_index = value.indexOf("E");
    if (first_e_index === -1 && first_E_index === -1) {
      return new RealMatch(false);
    }

    const exponentIndex = first_e_index === -1 ? first_E_index : first_e_index;

    const basicRealPart = value.substring(0, exponentIndex);
    const exponentPart = value.substring(exponentIndex + 1);

    // both should not be empty
    if (basicRealPart === "" || exponentPart == "") {
      return new RealMatch(false);
    }

    // parse each part
    const basicRealMatch = checkBasicReal(basicRealPart);

    if (!basicRealMatch.result) {
      return new RealMatch(false);
    }

    // match the exponent part across types up to real
    const exponentMatch = universalMatch(exponentPart, NumberType.REAL);
    if (!exponentMatch.result) {
      return new RealMatch(false);
    }

    return new RealMatch(
      true,
      basicRealMatch.integer,
      basicRealMatch.decimal,
      exponentMatch
    );
  }

  // check for the presence of e/E
  const count = (value.match(/[eE]/g) || []).length;

  if (count === 0) {
    // check for a basic real number
    return checkBasicReal(value);
  }

  // check for an extended real number
  return checkExtendedReal(value);
}

export function isComplex(value: string): ComplexMatch {
  // <basic-num> = <integer> | <rational> | <real>
  // <complex> = <basic-num>[+-]<basic-num>i
  // check if the value is a complex number. if it is, return true and the value.
  // if not, return a failed match.
  const count = (value.match(/i/g) || []).length;
  if (count < 1) {
    return new ComplexMatch(false);
  }

  if (value[value.length - 1] !== "i") {
    return new ComplexMatch(false);
  }

  // find the first + or - that is not at the start of the string
  // this is the split point
  const splitPoint = value.search(/(?<!^)[+-]/);

  // if no such point was found,
  if (splitPoint === -1) {
    // the value may be purely imaginary

    const imaginaryPart = value.slice(0, -1);

    const imaginaryMatch = universalMatch(imaginaryPart, NumberType.REAL);

    if (imaginaryMatch.result) {
      return new ComplexMatch(true, undefined, undefined, imaginaryMatch);
    }

    return new ComplexMatch(false);
  }

  const realPart = value.slice(0, splitPoint);
  let imaginaryPart = value.slice(splitPoint + 1, -1);

  // if imaginaryPart doesn't start with a sign, add one
  // this lets us properly parse expressions such as 1+inf.0i
  // even if the + belongs to the complex number
  if (imaginaryPart[0] !== "+" && imaginaryPart[0] !== "-") {
    imaginaryPart = "+" + imaginaryPart;
  }
  const realMatch = universalMatch(realPart, NumberType.REAL);
  const imaginaryMatch = universalMatch(imaginaryPart, NumberType.REAL);

  if (!(realMatch.result && imaginaryMatch.result)) {
    return new ComplexMatch(false);
  }

  return new ComplexMatch(true, realMatch, value[splitPoint], imaginaryMatch);
}

// tests the value across all possible types
// only limited by the finalWillingType of
function universalMatch(value: string, finalWillingType: NumberType): Match {
  const integerMatch = isInteger(value);
  if (integerMatch.result && finalWillingType >= NumberType.INTEGER) {
    return integerMatch;
  }
  const rationalMatch = isRational(value);
  if (rationalMatch.result && finalWillingType >= NumberType.RATIONAL) {
    return rationalMatch;
  }
  const realMatch = isReal(value);
  if (realMatch.result && finalWillingType >= NumberType.REAL) {
    return realMatch;
  }
  const complexMatch = isComplex(value);
  if (complexMatch.result && finalWillingType >= NumberType.COMPLEX) {
    return complexMatch;
  }
  return new IntegerMatch(false) as Match;
}

// for the lexer.
export function stringIsSchemeNumber(value: string): boolean {
  const match = universalMatch(value, NumberType.COMPLEX);
  return match.result;
}

// Each class has a numberType property that is used to determine the type of the number.
// If another instance's numbertype is higher in an operation, it will "promote" itself to the higher type.

// Each class also has a convert method that converts the number back into a javascript number.
// This is used when the number is used in a context where a javascript number is expected.
// If used in contexts where the values are too extreme for a javascript number, it will throw an error.
// This includes attempting to convert a complex number to a javascript number.

// If a simplified rational number has a denominator of 1, it will convert to an integer.

// We are assured that the string passed to this function is a valid number.
export const make_number = (value: string): SchemeNumber => {
  const match = universalMatch(value, NumberType.COMPLEX);
  if (!match.result) {
    throw new Error("Invalid number");
  }
  return match.build();
};

export class SchemeInteger {
  readonly numberType = NumberType.INTEGER;
  private readonly value: bigint;
  static readonly EXACT_ZERO = new SchemeInteger(0n);

  private constructor(value: bigint) {
    this.value = value;
  }

  // Factory method for creating a new SchemeInteger instance.
  // Force prevents automatic downcasting to a lower type.
  static build(
    value: number | string | bigint,
    _force: boolean = false
  ): SchemeInteger {
    const val = BigInt(value);
    if (val === 0n) {
      return SchemeInteger.EXACT_ZERO;
    }
    return new SchemeInteger(val);
  }

  promote(nType: NumberType): SchemeNumber {
    switch (nType) {
      case NumberType.INTEGER:
        return this;
      case NumberType.RATIONAL:
        return SchemeRational.build(this.value, 1n, true);
      case NumberType.REAL:
        return SchemeReal.build(this.coerce(), true);
      case NumberType.COMPLEX:
        return SchemeComplex.build(this, SchemeInteger.EXACT_ZERO, true);
    }
  }

  equals(other: any): boolean {
    return other instanceof SchemeInteger && this.value === other.value;
  }

  greaterThan(other: SchemeInteger): boolean {
    return this.value > other.value;
  }

  negate(): SchemeInteger {
    if (this === SchemeInteger.EXACT_ZERO) {
      return this;
    }
    return SchemeInteger.build(-this.value);
  }

  multiplicativeInverse(): SchemeInteger | SchemeRational {
    if (this === SchemeInteger.EXACT_ZERO) {
      throw new Error("Division by zero");
    }
    return SchemeRational.build(1n, this.value, false);
  }

  add(other: SchemeInteger): SchemeInteger {
    return SchemeInteger.build(this.value + other.value);
  }

  multiply(other: SchemeInteger): SchemeInteger {
    return SchemeInteger.build(this.value * other.value);
  }

  getBigInt(): bigint {
    return this.value;
  }

  coerce(): number {
    if (this.value > Number.MAX_SAFE_INTEGER) {
      return Infinity;
    }

    if (this.value < Number.MIN_SAFE_INTEGER) {
      return -Infinity;
    }

    return Number(this.value);
  }

  toString(): string {
    return this.value.toString();
  }
}

export class SchemeRational {
  readonly numberType = NumberType.RATIONAL;
  private readonly numerator: bigint;
  private readonly denominator: bigint;

  private constructor(numerator: bigint, denominator: bigint) {
    this.numerator = numerator;
    this.denominator = denominator;
  }

  // Builds a rational number.
  // Force prevents automatic downcasting to a lower type.
  static build(
    numerator: number | string | bigint,
    denominator: number | string | bigint,
    force: boolean = false
  ): SchemeRational | SchemeInteger {
    return SchemeRational.simplify(
      BigInt(numerator),
      BigInt(denominator),
      force
    );
  }

  private static simplify(
    numerator: bigint,
    denominator: bigint,
    force: boolean = false
  ): SchemeRational | SchemeInteger {
    const gcd = (a: bigint, b: bigint): bigint => {
      if (b === 0n) {
        return a;
      }
      return gcd(b, a.valueOf() % b.valueOf());
    };
    const divisor = gcd(numerator, denominator);
    const numeratorSign = numerator < 0n ? -1n : 1n;
    const denominatorSign = denominator < 0n ? -1n : 1n;
    // determine the sign of the result
    const sign = numeratorSign * denominatorSign;
    // remove the sign from the numerator and denominator
    numerator = numerator * numeratorSign;
    denominator = denominator * denominatorSign;
    // if the denominator is 1, we can return an integer
    if (denominator === 1n && !force) {
      return SchemeInteger.build(sign * numerator);
    }
    return new SchemeRational(
      (sign * numerator) / divisor,
      denominator / divisor
    );
  }

  getNumerator(): bigint {
    return this.numerator;
  }

  getDenominator(): bigint {
    return this.denominator;
  }

  promote(nType: NumberType): SchemeNumber {
    switch (nType) {
      case NumberType.RATIONAL:
        return this;
      case NumberType.REAL:
        return SchemeReal.build(this.coerce(), true);
      case NumberType.COMPLEX:
        return SchemeComplex.build(this, SchemeInteger.EXACT_ZERO, true);
      default:
        throw new Error("Unable to demote rational");
    }
  }

  equals(other: any): boolean {
    return (
      other instanceof SchemeRational &&
      this.numerator === other.numerator &&
      this.denominator === other.denominator
    );
  }

  greaterThan(other: SchemeRational): boolean {
    return (
      this.numerator * other.denominator > other.numerator * this.denominator
    );
  }

  negate(): SchemeRational {
    return SchemeRational.build(
      -this.numerator,
      this.denominator
    ) as SchemeRational;
  }

  multiplicativeInverse(): SchemeInteger | SchemeRational {
    if (this.numerator === 0n) {
      throw new Error("Division by zero");
    }
    return SchemeRational.build(this.denominator, this.numerator);
  }

  add(other: SchemeRational): SchemeInteger | SchemeRational {
    const newNumerator =
      this.numerator * other.denominator + other.numerator * this.denominator;
    const newDenominator = this.denominator * other.denominator;
    return SchemeRational.build(newNumerator, newDenominator);
  }

  multiply(other: SchemeRational): SchemeInteger | SchemeRational {
    const newNumerator = this.numerator * other.numerator;
    const newDenominator = this.denominator * other.denominator;
    return SchemeRational.build(newNumerator, newDenominator);
  }

  coerce(): number {
    const workingNumerator =
      this.numerator < 0n ? -this.numerator : this.numerator;
    let converterDenominator = this.denominator;

    // we can take the whole part directly
    const wholePart = Number(workingNumerator / converterDenominator);

    if (wholePart > Number.MAX_VALUE) {
      return this.numerator < 0n ? -Infinity : Infinity;
    }
    // remainder should be lossily converted below safe levels
    let remainder = workingNumerator % converterDenominator;

    // we lossily convert both values below safe number thresholds
    while (
      remainder > Number.MAX_SAFE_INTEGER ||
      converterDenominator > Number.MAX_SAFE_INTEGER
    ) {
      remainder = remainder / 2n;
      converterDenominator = converterDenominator / 2n;
    }

    // coerce the now safe parts into a remainder number
    const remainderPart = Number(remainder) / Number(converterDenominator);

    return this.numerator < 0n
      ? -(wholePart + remainderPart)
      : wholePart + remainderPart;
  }

  toString(): string {
    return `${this.numerator}/${this.denominator}`;
  }
}

// it is allowable to represent the Real number using
// float/double representation, and so we shall do that.
// the current schemeReal implementation is fully based
// on JavaScript numbers.
export class SchemeReal {
  readonly numberType = NumberType.REAL;
  private readonly value: number;

  public static INEXACT_ZERO = new SchemeReal(0);
  public static INEXACT_NEG_ZERO = new SchemeReal(-0);
  public static INFINITY = new SchemeReal(Infinity);
  public static NEG_INFINITY = new SchemeReal(-Infinity);
  public static NAN = new SchemeReal(NaN);

  static build(value: number, _force: boolean = false): SchemeReal {
    if (value === Infinity) {
      return SchemeReal.INFINITY;
    } else if (value === -Infinity) {
      return SchemeReal.NEG_INFINITY;
    } else if (isNaN(value)) {
      return SchemeReal.NAN;
    } else if (value === 0) {
      return SchemeReal.INEXACT_ZERO;
    } else if (value === -0) {
      return SchemeReal.INEXACT_NEG_ZERO;
    }
    return new SchemeReal(value);
  }

  private constructor(value: number) {
    this.value = value;
  }

  promote(nType: NumberType): SchemeNumber {
    switch (nType) {
      case NumberType.REAL:
        return this;
      case NumberType.COMPLEX:
        return SchemeComplex.build(this, SchemeInteger.EXACT_ZERO, true);
      default:
        throw new Error("Unable to demote real");
    }
  }

  equals(other: any): boolean {
    return other instanceof SchemeReal && this.value === other.value;
  }

  greaterThan(other: SchemeReal): boolean {
    return this.value > other.value;
  }

  negate(): SchemeReal {
    return SchemeReal.build(-this.value);
  }

  multiplicativeInverse(): SchemeReal {
    if (
      this === SchemeReal.INEXACT_ZERO ||
      this === SchemeReal.INEXACT_NEG_ZERO
    ) {
      throw new Error("Division by zero");
    }
    return SchemeReal.build(1 / this.value);
  }

  add(other: SchemeReal): SchemeReal {
    return SchemeReal.build(this.value + other.value);
  }

  multiply(other: SchemeReal): SchemeReal {
    return SchemeReal.build(this.value * other.value);
  }

  coerce(): number {
    return this.value;
  }

  toString(): string {
    if (this === SchemeReal.INFINITY) {
      return "+inf.0";
    }
    if (this === SchemeReal.NEG_INFINITY) {
      return "-inf.0";
    }
    if (this === SchemeReal.NAN) {
      return "+nan.0";
    }
    return this.value.toString();
  }
}

export class SchemeComplex {
  readonly numberType = NumberType.COMPLEX;
  private readonly real: SchemeInteger | SchemeRational | SchemeReal;
  private readonly imaginary: SchemeInteger | SchemeRational | SchemeReal;

  static build(
    real: SchemeReal | SchemeRational | SchemeInteger,
    imaginary: SchemeReal | SchemeRational | SchemeInteger,
    force: boolean = false
  ): SchemeNumber {
    return SchemeComplex.simplify(new SchemeComplex(real, imaginary), force);
  }

  private constructor(
    real: SchemeReal | SchemeRational | SchemeInteger,
    imaginary: SchemeReal | SchemeRational | SchemeInteger
  ) {
    this.real = real;
    this.imaginary = imaginary;
  }

  private static simplify(
    complex: SchemeComplex,
    force: boolean
  ): SchemeNumber {
    if (!force && atomic_equals(complex.imaginary, SchemeInteger.EXACT_ZERO)) {
      return complex.real;
    }
    return complex;
  }

  promote(nType: NumberType): SchemeNumber {
    switch (nType) {
      case NumberType.COMPLEX:
        return this;
      default:
        throw new Error("Unable to demote complex");
    }
  }

  negate(): SchemeNumber {
    return SchemeComplex.build(this.real.negate(), this.imaginary.negate());
  }

  equals(other: SchemeComplex): boolean {
    return (
      atomic_equals(this.real, other.real) &&
      atomic_equals(this.imaginary, other.imaginary)
    );
  }

  greaterThan(other: SchemeComplex): boolean {
    return (
      atomic_greater_than(this.real, other.real) &&
      atomic_greater_than(this.imaginary, other.imaginary)
    );
  }

  multiplicativeInverse(): SchemeNumber {
    // inverse of a + bi = a - bi / a^2 + b^2
    // in this case, we use a / a^2 + b^2 and -b / a^2 + b^2 as the new values required
    const denominator = atomic_add(
      atomic_multiply(this.real, this.real),
      atomic_multiply(this.imaginary, this.imaginary)
    ) as SchemeInteger | SchemeRational | SchemeReal;
    return SchemeComplex.build(
      atomic_multiply(denominator.multiplicativeInverse(), this.real) as
        | SchemeInteger
        | SchemeRational
        | SchemeReal,
      atomic_multiply(
        denominator.multiplicativeInverse(),
        this.imaginary.negate()
      ) as SchemeInteger | SchemeRational | SchemeReal
    );
  }

  add(other: SchemeComplex): SchemeNumber {
    return SchemeComplex.build(
      atomic_add(this.real, other.real) as
        | SchemeInteger
        | SchemeRational
        | SchemeReal,
      atomic_add(this.imaginary, other.imaginary) as
        | SchemeInteger
        | SchemeRational
        | SchemeReal
    );
  }

  multiply(other: SchemeComplex): SchemeNumber {
    // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
    const realPart = atomic_subtract(
      atomic_multiply(this.real, other.real),
      atomic_multiply(this.imaginary, other.imaginary)
    ) as SchemeInteger | SchemeRational | SchemeReal;
    const imaginaryPart = atomic_add(
      atomic_multiply(this.real, other.imaginary),
      atomic_multiply(this.imaginary, other.real)
    ) as SchemeInteger | SchemeRational | SchemeReal;
    return SchemeComplex.build(realPart, imaginaryPart);
  }

  getReal(): SchemeInteger | SchemeRational | SchemeReal {
    return this.real;
  }

  getImaginary(): SchemeInteger | SchemeRational | SchemeReal {
    return this.imaginary;
  }

  coerce(): number {
    throw new Error("Cannot coerce a complex number to a javascript number");
  }

  toPolar(): SchemePolar {
    // force both the real and imaginary parts to be inexact
    const real = this.real.promote(NumberType.REAL) as SchemeReal;
    const imaginary = this.imaginary.promote(NumberType.REAL) as SchemeReal;

    // schemeReals can be reasoned with using the same logic as javascript numbers
    // r = sqrt(a^2 + b^2)
    const magnitude = SchemeReal.build(
      Math.sqrt(
        real.coerce() * real.coerce() + imaginary.coerce() * imaginary.coerce()
      )
    );
    // theta = atan(b / a)
    const angle = SchemeReal.build(
      Math.atan2(imaginary.coerce(), real.coerce())
    );
    return SchemePolar.build(magnitude, angle);
  }

  toString(): string {
    return `${this.real}+${this.imaginary}i`;
  }
}

// an alternative form of the complex number.
// only used in intermediate steps, will be converted back at the end of the operation.
// current scm-slang will force any polar complex numbers to be made
// inexact, hence we opt to limit the use of polar form as much as possible.
class SchemePolar {
  readonly magnitude: SchemeReal;
  readonly angle: SchemeReal;

  private constructor(magnitude: SchemeReal, angle: SchemeReal) {
    this.magnitude = magnitude;
    this.angle = angle;
  }

  static build(magnitude: SchemeReal, angle: SchemeReal): SchemePolar {
    return new SchemePolar(magnitude, angle);
  }

  // converts the polar number back to a cartesian complex number
  toCartesian(): SchemeNumber {
    // a + bi = r * cos(theta) + r * sin(theta)i
    // a = r * cos(theta)
    // b = r * sin(theta)
    const real = SchemeReal.build(
      this.magnitude.coerce() * Math.cos(this.angle.coerce())
    );
    const imaginary = SchemeReal.build(
      this.magnitude.coerce() * Math.sin(this.angle.coerce())
    );
    return SchemeComplex.build(real, imaginary);
  }
}

export const infinity = SchemeReal.INFINITY;
export const nan = SchemeReal.NAN;

// this function is used to convert a number to a javascript number.
// it should only be limited to numbers used for indexing, integers.
export function coerce_to_number(a: SchemeNumber): number {
  return a.coerce();
}

// these functions deal with checking the type of a number.
export function is_number(a: any): boolean {
  return (
    a.numberType !== undefined &&
    Object.values(NumberType).includes(a.numberType)
  );
}

export function is_integer(a: any): boolean {
  return is_number(a) && a.numberType <= 1;
}

export function is_rational(a: any): boolean {
  return is_number(a) && a.numberType <= 2;
}

export function is_real(a: any): boolean {
  return is_number(a) && a.numberType <= 3;
}

export function is_complex(a: any): boolean {
  return is_number(a) && a.numberType <= 4;
}

export function is_exact(a: any): boolean {
  // if the number is a complex number, we need to check both the real and imaginary parts
  return is_number(a)
    ? a.numberType === 4
      ? is_exact(a.real) && is_exact(a.imaginary)
      : a.numberType <= 2
    : false;
}

export function is_inexact(a: any): boolean {
  // defined in terms of is_exact
  return is_number(a) && !is_exact(a);
}

// the functions below are used to perform operations on numbers

function simplify(a: SchemeNumber): SchemeNumber {
  switch (a.numberType) {
    case NumberType.INTEGER:
      return a;
    case NumberType.RATIONAL:
      return (a as SchemeRational).getDenominator() === 1n
        ? SchemeInteger.build(a.getNumerator())
        : a;
    case NumberType.REAL:
      return a;
    case NumberType.COMPLEX:
      // safe to cast as simplify never promotes a number
      return SchemeComplex.build(
        simplify((a as SchemeComplex).getReal()) as
          | SchemeInteger
          | SchemeRational
          | SchemeReal,
        simplify((a as SchemeComplex).getImaginary()) as
          | SchemeInteger
          | SchemeRational
          | SchemeReal
      );
  }
}

/**
 * This function takes two numbers and brings them to the same level.
 */
function equalify(
  a: SchemeNumber,
  b: SchemeNumber
): [SchemeNumber, SchemeNumber] {
  if (a.numberType > b.numberType) {
    return [a, b.promote(a.numberType)];
  } else if (a.numberType < b.numberType) {
    return [a.promote(b.numberType), b];
  }
  return [a, b];
}

export function atomic_negate(a: SchemeNumber): SchemeNumber {
  return a.negate();
}

export function atomic_inverse(a: SchemeNumber): SchemeNumber {
  return a.multiplicativeInverse();
}

export function atomic_equals(a: SchemeNumber, b: SchemeNumber): boolean {
  const [newA, newB] = equalify(a, b);
  // safe to cast as we are assured they are of the same type
  return newA.equals(newB as any);
}

export function atomic_less_than(a: SchemeNumber, b: SchemeNumber): boolean {
  return !atomic_greater_than(a, b) && !atomic_equals(a, b);
}

export function atomic_less_than_or_equals(
  a: SchemeNumber,
  b: SchemeNumber
): boolean {
  return !atomic_greater_than(a, b);
}

export function atomic_greater_than(a: SchemeNumber, b: SchemeNumber): boolean {
  const [newA, newB] = equalify(a, b);
  // safe to cast as we are assured they are of the same type
  return newA.greaterThan(newB as any);
}

export function atomic_greater_than_or_equals(
  a: SchemeNumber,
  b: SchemeNumber
): boolean {
  return atomic_greater_than(a, b) || atomic_equals(a, b);
}

export function atomic_add(a: SchemeNumber, b: SchemeNumber): SchemeNumber {
  const [newA, newB] = equalify(a, b);
  // safe to cast as we are assured they are of the same type
  return simplify(newA.add(newB as any));
}

export function atomic_multiply(
  a: SchemeNumber,
  b: SchemeNumber
): SchemeNumber {
  const [newA, newB] = equalify(a, b);
  // safe to cast as we are assured they are of the same type
  return simplify(newA.multiply(newB as any));
}

export function atomic_subtract(
  a: SchemeNumber,
  b: SchemeNumber
): SchemeNumber {
  return atomic_add(a, atomic_negate(b));
}

export function atomic_divide(a: SchemeNumber, b: SchemeNumber): SchemeNumber {
  return atomic_multiply(a, atomic_inverse(b));
}

/**
 * Important constants
 */
export const PI = SchemeReal.build(Math.PI);
export const E = SchemeReal.build(Math.E);
export const SQRT2 = SchemeReal.build(Math.SQRT2);
export const LN2 = SchemeReal.build(Math.LN2);
export const LN10 = SchemeReal.build(Math.LN10);
export const LOG2E = SchemeReal.build(Math.LOG2E);
export const LOG10E = SchemeReal.build(Math.LOG10E);
export const SQRT1_2 = SchemeReal.build(Math.SQRT1_2);

// other important functions

export const numerator = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("numerator: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    // always return an integer
    return is_exact(n) ? SchemeInteger.build(1) : SchemeReal.build(1);
  }
  if (!is_rational(n)) {
    // is real number
    // get the value of the number
    const val = n.coerce();
    // if the value is a defined special case, return accordingly
    if (val === Infinity) {
      return SchemeReal.build(1);
    }
    if (val === -Infinity) {
      return SchemeReal.build(1);
    }
    if (isNaN(val)) {
      return SchemeReal.NAN;
    }
    // if the value is an integer, return it
    if (Number.isInteger(val)) {
      return SchemeReal.build(val);
    }
    // else if the value is a float,
    // multiply it till it becomes an integer
    let multiplier = 1;
    while (!Number.isInteger(val * multiplier)) {
      multiplier *= 10;
    }
    let numerator = val * multiplier;
    const denominator = multiplier;
    // simplify the fraction
    const gcd = (a: number, b: number): number => {
      if (b === 0) {
        return a;
      }
      return gcd(b, a % b);
    };
    const divisor = gcd(numerator, denominator);
    numerator = numerator / divisor;
    return SchemeReal.build(numerator);
  }
  return SchemeInteger.build(
    (n.promote(NumberType.RATIONAL) as SchemeRational).getNumerator()
  );
};

export const denominator = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("denominator: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    // always return an integer
    return is_exact(n) ? SchemeInteger.build(1) : SchemeReal.build(1);
  }
  if (!is_rational(n)) {
    // is real number
    // get the value of the number
    const val = n.coerce();
    // if the value is a defined special case, return accordingly
    if (val === Infinity) {
      return SchemeReal.INEXACT_ZERO;
    }
    if (val === -Infinity) {
      return SchemeReal.INEXACT_ZERO;
    }
    if (isNaN(val)) {
      return SchemeReal.NAN;
    }
    // if the value is an integer, return 1
    if (Number.isInteger(val)) {
      return SchemeReal.build(1);
    }
    // else if the value is a float,
    // multiply it till it becomes an integer
    let multiplier = 1;
    while (!Number.isInteger(val * multiplier)) {
      multiplier *= 10;
    }
    const numerator = val * multiplier;
    let denominator = multiplier;
    // simplify the fraction
    const gcd = (a: number, b: number): number => {
      if (b === 0) {
        return a;
      }
      return gcd(b, a % b);
    };
    const divisor = gcd(numerator, denominator);
    denominator = denominator / divisor;
    return SchemeReal.build(denominator);
  }
  return SchemeInteger.build(
    (n.promote(NumberType.RATIONAL) as SchemeRational).getDenominator()
  );
};

export const exact = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("exact: expected number");
  }
  if (is_exact(n)) {
    return n;
  }
  if (is_real(n)) {
    // if the number is a real number, we can convert it to a rational number
    // by multiplying it by a power of 10 until it becomes an integer
    // and then dividing by the same power of 10
    let multiplier = 1;
    const val = n.coerce();
    while (!Number.isInteger(val * multiplier)) {
      multiplier *= 10;
    }
    return SchemeRational.build(val * multiplier, multiplier);
  }
  // if the number is a complex number, we can convert both the real and imaginary parts
  // to exact numbers
  return SchemeComplex.build(
    exact((n as SchemeComplex).getReal()) as SchemeInteger | SchemeRational,
    exact((n as SchemeComplex).getImaginary()) as SchemeInteger | SchemeRational
  );
};

export const inexact = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("inexact: expected number");
  }
  if (is_inexact(n)) {
    return n;
  }
  if (is_real(n)) {
    // if the number is a real number, we can convert it to a float
    return SchemeReal.build(n.coerce());
  }
  // if the number is a complex number, we can convert both the real and imaginary parts
  // to inexact numbers
  return SchemeComplex.build(
    inexact((n as SchemeComplex).getReal()) as SchemeReal,
    inexact((n as SchemeComplex).getImaginary()) as SchemeReal
  );
};

// for now, exponentials, square roots and the like will be treated as
// inexact functions, and will return inexact results. this allows us to
// leverage on the inbuilt javascript Math library.
// additional logic is required to handle complex numbers, which we can do with
// our polar form representation.

export const expt = (n: SchemeNumber, e: SchemeNumber): SchemeNumber => {
  if (!is_number(n) || !is_number(e)) {
    throw new Error("expt: expected numbers");
  }
  if (!is_real(n) || !is_real(e)) {
    // complex number case
    // we can convert both parts to polar form and use the
    // polar form exponentiation formula.

    // given a * e^(bi) and c * e^(di),
    // (a * e^(bi)) ^ (c * e^(di)) can be represented by
    // the general formula for complex exponentiation:
    // (a^c * e^(-bd)) * e^(i(bc * ln(a) + ad))

    // convert both numbers to polar form
    const nPolar = (n.promote(NumberType.COMPLEX) as SchemeComplex).toPolar();
    const ePolar = (e.promote(NumberType.COMPLEX) as SchemeComplex).toPolar();

    const a = nPolar.magnitude.coerce();
    const b = nPolar.angle.coerce();
    const c = ePolar.magnitude.coerce();
    const d = ePolar.angle.coerce();

    // we can construct a new polar form following the formula above
    const mag = SchemeReal.build(a ** c * Math.E ** (-b * d));
    const angle = SchemeReal.build(b * c * Math.log(a) + a * d);

    return SchemePolar.build(mag, angle).toCartesian();
  }
  // coerce both numbers to javascript numbers
  const base = n.coerce();
  const exponent = e.coerce();

  // there are probably cases here i am not considering yet.
  // for now, we will just use the javascript Math library and hope for the best.
  return SchemeReal.build(Math.pow(base, exponent));
};

export const exp = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("exp: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    throw new Error("exp: expected real number");
  }
  return SchemeReal.build(Math.exp(n.coerce()));
};

export const log = (n: SchemeNumber, base: SchemeNumber = E): SchemeNumber => {
  if (!is_number(n) || !is_number(base)) {
    throw new Error("log: expected numbers");
  }
  if (!is_real(n) || !is_real(base)) {
    // complex number case
    // we can convert both parts to polar form and use the
    // polar form logarithm formula.
    // where log(a * e^(bi)) = log(a) + bi
    // and log(c * e^(di)) = log(c) + di
    // and so result is log(a) + bi / log(c) + di
    // which is just (log(a) - log(c)) + (b / d) i

    // convert both numbers to polar form
    const nPolar = (n.promote(NumberType.COMPLEX) as SchemeComplex).toPolar();
    const basePolar = (
      base.promote(NumberType.COMPLEX) as SchemeComplex
    ).toPolar();
    const a = nPolar.magnitude.coerce();
    const b = nPolar.angle.coerce();
    const c = basePolar.magnitude.coerce();
    const d = basePolar.angle.coerce();

    return SchemeComplex.build(
      SchemeReal.build(Math.log(a) - Math.log(c)),
      SchemeReal.build(b / d)
    );
  }
  return SchemeReal.build(Math.log(n.coerce()) / Math.log(base.coerce()));
};

export const sqrt = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("sqrt: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    const polar = (n.promote(NumberType.COMPLEX) as SchemeComplex).toPolar();
    const mag = polar.magnitude;
    const angle = polar.angle;

    // the square root of a complex number is given by
    // the square root of the magnitude and half the angle
    const newMag = sqrt(mag) as SchemeReal;
    const newAngle = SchemeReal.build(angle.coerce() / 2);

    return SchemePolar.build(newMag, newAngle).toCartesian();
  }
  const value = n.coerce();

  if (value < 0) {
    return SchemeComplex.build(
      SchemeReal.INEXACT_ZERO,
      SchemeReal.build(Math.sqrt(-value))
    );
  }

  return SchemeReal.build(Math.sqrt(n.coerce()));
};

export const sin = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("sin: expected number");
  }
  if (!is_real(n)) {
    // complex number case

    // we can use euler's formula to find sin(x) for a complex number x = a + bi
    // e^(ix) = cos(x) + i * sin(x)
    // that can be rearranged into
    // sin(x) = (e^(ix) - e^(-ix)) / 2i
    // and finally into
    // sin(x) = (sin(a) * (e^(-b) + e^(b)) / 2) + i * (cos(a) * (e^(-b) - e^(b)) / 2)
    const complex = n.promote(NumberType.COMPLEX) as SchemeComplex;
    const real = complex.getReal();
    const imaginary = complex.getImaginary();
    const a = real.coerce();
    const b = imaginary.coerce();
    return SchemeComplex.build(
      SchemeReal.build((Math.sin(a) * (Math.exp(-b) + Math.exp(b))) / 2),
      SchemeReal.build((Math.cos(a) * (Math.exp(-b) - Math.exp(b))) / 2)
    );
  }
  return SchemeReal.build(Math.sin(n.coerce()));
};

export const cos = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("cos: expected number");
  }
  if (!is_real(n)) {
    // complex number case

    // we can use euler's formula to find cos(x) for a complex number x = a + bi
    // e^(ix) = cos(x) + i * sin(x)
    // that can be rearranged into
    // cos(x) = (e^(ix) + e^(-ix)) / 2
    // and finally into
    // cos(x) = (cos(a) * (e^(-b) + e^(b)) / 2) - i * (sin(a) * (e^(-b) - e^(b)) / 2)
    const complex = n.promote(NumberType.COMPLEX) as SchemeComplex;
    const real = complex.getReal();
    const imaginary = complex.getImaginary();
    const a = real.coerce();
    const b = imaginary.coerce();
    return SchemeComplex.build(
      SchemeReal.build((Math.cos(a) * (Math.exp(-b) + Math.exp(b))) / 2),
      SchemeReal.build((-Math.sin(a) * (Math.exp(-b) - Math.exp(b))) / 2)
    );
  }
  return SchemeReal.build(Math.cos(n.coerce()));
};

export const tan = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("tan: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    const sinValue = sin(n);
    const cosValue = cos(n);
    return atomic_divide(sinValue, cosValue);
  }
  return SchemeReal.build(Math.tan(n.coerce()));
};

export const asin = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("asin: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    // asin(n) = -i * ln(i * n + sqrt(1 - n^2))
    // we already have the building blocks needed to compute this
    const i = SchemeComplex.build(
      SchemeInteger.EXACT_ZERO,
      SchemeInteger.build(1)
    );
    return atomic_multiply(
      atomic_negate(i),
      log(
        atomic_add(
          atomic_multiply(i, n),
          sqrt(atomic_subtract(SchemeInteger.build(1), atomic_multiply(n, n)))
        )
      )
    );
  }
  return SchemeReal.build(Math.asin(n.coerce()));
};

export const acos = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("acos: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    // acos(n) = -i * ln(n + sqrt(n^2 - 1))
    // again, we have the building blocks needed to compute this
    const i = SchemeComplex.build(
      SchemeInteger.EXACT_ZERO,
      SchemeInteger.build(1)
    );
    return atomic_multiply(
      atomic_negate(i),
      log(
        atomic_add(
          n,
          sqrt(atomic_subtract(atomic_multiply(n, n), SchemeInteger.build(1)))
        )
      )
    );
  }
  return SchemeReal.build(Math.acos(n.coerce()));
};

export const atan = (n: SchemeNumber, m?: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("atan: expected number");
  }

  if (m !== undefined) {
    // two argument case, we construct a complex number with n + mi
    // if neither n nor m are real, it's an error
    if (!is_real(n) || !is_real(m)) {
      throw new Error("atan: expected real numbers");
    }
    return atan(
      SchemeComplex.build(
        n as SchemeInteger | SchemeRational | SchemeReal,
        m as SchemeInteger | SchemeRational | SchemeReal
      )
    );
  }

  if (!is_real(n)) {
    // complex number case
    // atan(n) = 1/2 * i * ln((1 - i * n) / (1 + i * n))
    const i = SchemeComplex.build(
      SchemeInteger.EXACT_ZERO,
      SchemeInteger.build(1)
    );
    return atomic_multiply(
      // multiply is associative so the order here doesn't matter
      atomic_multiply(SchemeRational.build(1, 2), i),
      log(
        atomic_divide(
          atomic_subtract(SchemeInteger.build(1), atomic_multiply(i, n)),
          atomic_add(SchemeInteger.build(1), atomic_multiply(i, n))
        )
      )
    );
  }
  return SchemeReal.build(Math.atan(n.coerce()));
};

export const floor = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("floor: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    throw new Error("floor: expected real number");
  }
  if (n.numberType === NumberType.INTEGER) {
    return n;
  }
  if (n.numberType === NumberType.RATIONAL) {
    // floor is numerator // denominator
    const rational = n as SchemeRational;
    const numerator = rational.getNumerator();
    const denominator = rational.getDenominator();
    return SchemeInteger.build(numerator / denominator);
  }
  return SchemeReal.build(Math.floor(n.coerce()));
};

export const ceiling = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("ceiling: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    throw new Error("ceiling: expected real number");
  }
  if (n.numberType === NumberType.INTEGER) {
    return n;
  }
  if (n.numberType === NumberType.RATIONAL) {
    // ceiling is (numerator + denominator - 1) // denominator
    const rational = n as SchemeRational;
    const numerator = rational.getNumerator();
    const denominator = rational.getDenominator();
    return SchemeInteger.build((numerator + denominator - 1n) / denominator);
  }
  return SchemeReal.build(Math.ceil(n.coerce()));
};

export const truncate = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("truncate: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    throw new Error("truncate: expected real number");
  }
  if (n.numberType === NumberType.INTEGER) {
    return n;
  }
  if (n.numberType === NumberType.RATIONAL) {
    // truncate is also just numerator // denominator
    // exactly like floor
    const rational = n as SchemeRational;
    const numerator = rational.getNumerator();
    const denominator = rational.getDenominator();
    return SchemeInteger.build(numerator / denominator);
  }
  return SchemeReal.build(Math.trunc(n.coerce()));
};

export const round = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("round: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    throw new Error("round: expected real number");
  }
  if (n.numberType === NumberType.INTEGER) {
    return n;
  }
  if (n.numberType === NumberType.RATIONAL) {
    // round is numerator + denominator // 2 * denominator
    const rational = n as SchemeRational;
    const numerator = rational.getNumerator();
    const denominator = rational.getDenominator();
    return SchemeInteger.build((numerator + denominator / 2n) / denominator);
  }
  return SchemeReal.build(Math.round(n.coerce()));
};

export const make$45$rectangular = (
  a: SchemeNumber,
  b: SchemeNumber
): SchemeNumber => {
  if (!is_number(a) || !is_number(b)) {
    throw new Error("make-rectangular: expected numbers");
  }
  if (!is_real(a) || !is_real(b)) {
    // complex number case
    throw new Error("make-rectangular: expected real numbers");
  }
  return SchemeComplex.build(
    a as SchemeReal | SchemeRational | SchemeInteger,
    b as SchemeReal | SchemeRational | SchemeInteger
  );
};

export const make$45$polar = (
  a: SchemeNumber,
  b: SchemeNumber
): SchemeNumber => {
  if (!is_number(a) || !is_number(b)) {
    throw new Error("make-polar: expected numbers");
  }
  if (!is_real(a) || !is_real(b)) {
    // complex number case
    throw new Error("make-polar: expected real numbers");
  }
  return SchemePolar.build(
    a.promote(NumberType.REAL) as SchemeReal,
    b.promote(NumberType.REAL) as SchemeReal
  ).toCartesian();
};

export const real$45$part = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("real-part: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    return (n as SchemeComplex).getReal();
  }
  return n;
};

export const imag$45$part = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("imag-part: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    return (n as SchemeComplex).getImaginary();
  }
  return SchemeInteger.EXACT_ZERO;
};

export const magnitude = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("magnitude: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    return (n as SchemeComplex).toPolar().magnitude;
  }
  // abs is not defined here so we should just use direct comparison
  if (atomic_less_than(n, SchemeInteger.EXACT_ZERO)) {
    return atomic_negate(n);
  }
  return n;
};

export const angle = (n: SchemeNumber): SchemeNumber => {
  if (!is_number(n)) {
    throw new Error("angle: expected number");
  }
  if (!is_real(n)) {
    // complex number case
    return (n as SchemeComplex).toPolar().angle;
  }
  if (atomic_less_than(n, SchemeInteger.EXACT_ZERO)) {
    return PI;
  }
  return SchemeInteger.EXACT_ZERO;
};

export const odd$63$ = (n: SchemeInteger): boolean => {
  if (!is_number(n)) {
    throw new Error("odd?: expected integer");
  }

  if (!is_integer(n)) {
    throw new Error("odd?: expected integer");
  }

  return n.getBigInt() % 2n === 1n;
};

export const even$63$ = (n: SchemeInteger): boolean => {
  if (!is_number(n)) {
    throw new Error("even?: expected integer");
  }

  if (!is_integer(n)) {
    throw new Error("even?: expected integer");
  }

  return n.getBigInt() % 2n === 0n;
};
</file>

<file path="src/standalone.ts">
import { evaluatePie } from './pie_interpreter/main.js';

// Standalone entry point for the Pie interpreter
console.log("Pie Interpreter - Standalone Mode");

// Test with a simple Pie expression
const testCode = `
(claim zero Nat)
(define zero zero)

(claim one Nat) 
(define one (add1 zero))

(claim two Nat)
(define two (add1 one))

(claim addNat (-> Nat Nat Nat)) 
(define addNat 
  (lambda (x y) 
    (ind-Nat x 
      (lambda (x) Nat)
      y 
      (lambda (n-1 ih) (add1 ih)))))

(addNat two one)
`;

try {
  console.log("\n--- Evaluating Pie Code ---");
  const result = evaluatePie(testCode);
  console.log(result);
} catch (error) {
  console.error("Error:", error instanceof Error ? error.message : String(error));
  if (error instanceof Error && error.stack) {
    console.error("Stack:", error.stack);
  }
}
</file>

<file path="web/lsp/lsp-client-simple.js">
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Simple LSP client that connects Monaco Editor to our browser-based language server
 * without using monaco-languageclient (to avoid version conflicts).
 */
export class PieLanguageClient {
    constructor(monacoInstance, editorInstance) {
        this.worker = null;
        this.disposables = [];
        this.debouncedValidate = null;
        this.diagnostics = [];
        this.monaco = monacoInstance;
        this.editor = editorInstance;
    }
    /**
     * Initialize the language client and connect it to the language server worker.
     */
    async start() {
        this.worker = new Worker(new URL('./pie-lsp-worker-bundle.js', import.meta.url), { type: 'module' });
        this.worker.onmessage = (event) => {
            this.handleWorkerMessage(event.data);
        };
        this.worker.onerror = (error) => {
            console.error('LSP Worker error:', error);
        };
        const model = this.editor?.getModel?.();
        if (!model) {
            return;
        }
        this.debouncedValidate = this.debounce(() => {
            if (!this.worker) {
                return;
            }
            const source = model.getValue();
            this.worker.postMessage({ type: 'validate', source });
        }, 220);
        const changeDisposable = this.editor?.onDidChangeModelContent?.(() => {
            if (this.debouncedValidate) {
                this.debouncedValidate();
            }
        });
        if (changeDisposable) {
            this.disposables.push(changeDisposable);
        }
        const hoverDisposable = this.monaco.languages.registerHoverProvider('pie', {
            provideHover: (model, position) => this.provideHover(model, position)
        });
        this.disposables.push(hoverDisposable);
        // Register completion provider
        const completionDisposable = this.monaco.languages.registerCompletionItemProvider('pie', {
            provideCompletionItems: (model, position) => this.provideCompletionItems(model, position)
        });
        this.disposables.push(completionDisposable);
        // Register definition provider
        const definitionDisposable = this.monaco.languages.registerDefinitionProvider('pie', {
            provideDefinition: (model, position) => this.provideDefinition(model, position)
        });
        this.disposables.push(definitionDisposable);
        if (this.debouncedValidate) {
            this.debouncedValidate();
        }
    }
    /**
     * Stop the language client and terminate the worker.
     */
    async stop() {
        this.clearMarkers();
        this.disposables.forEach(disposable => {
            if (disposable && typeof disposable.dispose === 'function') {
                disposable.dispose();
            }
        });
        this.disposables = [];
        this.debouncedValidate = null;
        this.diagnostics = [];
        if (this.worker) {
            this.worker.terminate();
            this.worker = null;
        }
    }
    /**
     * Check if the client is running.
     */
    isRunning() {
        return this.worker !== null;
    }
    handleWorkerMessage(message) {
        if (!message) {
            return;
        }
        if (message.type === 'validation-result') {
            this.updateDiagnostics(message.diagnostics ?? []);
        }
        else if (message.type === 'validation-error') {
            this.updateDiagnostics([
                {
                    severity: 'error',
                    startLine: 1,
                    startColumn: 1,
                    endLine: 1,
                    endColumn: 2,
                    message: message.error
                }
            ]);
        }
    }
    updateDiagnostics(diagnostics) {
        this.diagnostics = diagnostics;
        const model = this.editor?.getModel?.();
        if (!model) {
            return;
        }
        const markers = diagnostics.map((diag) => {
            const startLine = this.ensurePositiveNumber(diag.startLine, 1);
            const endLine = this.ensurePositiveNumber(diag.endLine, startLine);
            const startColumn = this.ensurePositiveNumber(diag.startColumn, 1);
            const endColumn = this.ensurePositiveNumber(diag.endColumn, startColumn + 1);
            return {
                startLineNumber: startLine,
                startColumn,
                endLineNumber: endLine,
                endColumn,
                message: diag.message,
                severity: diag.severity === 'warning'
                    ? this.monaco.MarkerSeverity.Warning
                    : this.monaco.MarkerSeverity.Error
            };
        });
        this.monaco.editor.setModelMarkers(model, 'pie-lsp', markers);
    }
    async provideHover(model, position) {
        if (!this.worker) {
            return null;
        }
        // First, check if there's a diagnostic at this position
        const diagnostic = this.diagnostics.find((diag) => {
            const startLine = this.ensurePositiveNumber(diag.startLine, position.lineNumber);
            const endLine = this.ensurePositiveNumber(diag.endLine, startLine);
            const startColumn = this.ensurePositiveNumber(diag.startColumn, 1);
            const endColumn = this.ensurePositiveNumber(diag.endColumn, startColumn + 1);
            if (position.lineNumber < startLine || position.lineNumber > endLine) {
                return false;
            }
            if (position.lineNumber === startLine && position.column < startColumn) {
                return false;
            }
            if (position.lineNumber === endLine && position.column > endColumn) {
                return false;
            }
            return true;
        });
        if (diagnostic) {
            const startLine = this.ensurePositiveNumber(diagnostic.startLine, position.lineNumber);
            const endLine = this.ensurePositiveNumber(diagnostic.endLine, startLine);
            const startColumn = this.ensurePositiveNumber(diagnostic.startColumn, 1);
            const endColumn = this.ensurePositiveNumber(diagnostic.endColumn, startColumn + 1);
            return {
                contents: [
                    { value: `**${diagnostic.severity === 'warning' ? 'Warning' : 'Error'}**\n\n${diagnostic.message}` }
                ],
                range: {
                    startLineNumber: startLine,
                    startColumn,
                    endLineNumber: endLine,
                    endColumn
                }
            };
        }
        // If no diagnostic, request hover info from worker
        return new Promise((resolve) => {
            const handleHover = (event) => {
                const message = event.data;
                if (message.type === 'hover-result') {
                    this.worker?.removeEventListener('message', handleHover);
                    if (!message.hoverInfo) {
                        resolve(null);
                        return;
                    }
                    const info = message.hoverInfo;
                    let markdownContent = `**${info.title}**\n\n${info.summary}`;
                    if (info.details) {
                        markdownContent += `\n\n${info.details}`;
                    }
                    if (info.examples) {
                        markdownContent += `\n\n**Examples:**\n\`\`\`pie\n${info.examples}\n\`\`\``;
                    }
                    resolve({
                        contents: [
                            { value: markdownContent }
                        ]
                    });
                }
            };
            if (this.worker) {
                this.worker.addEventListener('message', handleHover);
                const source = model.getValue();
                this.worker.postMessage({
                    type: 'hover',
                    source,
                    line: position.lineNumber - 1,
                    column: position.column - 1
                });
            }
            // Timeout fallback
            setTimeout(() => {
                this.worker?.removeEventListener('message', handleHover);
                resolve(null);
            }, 1000);
        });
    }
    async provideCompletionItems(model, position) {
        if (!this.worker) {
            return { suggestions: [] };
        }
        return new Promise((resolve) => {
            const handleCompletion = (event) => {
                const message = event.data;
                if (message.type === 'completion-result') {
                    this.worker?.removeEventListener('message', handleCompletion);
                    // Calculate the range to replace based on word boundaries
                    const wordRange = message.wordRange;
                    const range = wordRange ? {
                        startLineNumber: position.lineNumber,
                        startColumn: wordRange.start + 1, // Monaco uses 1-based columns
                        endLineNumber: position.lineNumber,
                        endColumn: wordRange.end + 1
                    } : {
                        startLineNumber: position.lineNumber,
                        startColumn: position.column,
                        endLineNumber: position.lineNumber,
                        endColumn: position.column
                    };
                    const suggestions = message.completions.map((item) => {
                        // Map kind strings to Monaco CompletionItemKind
                        let kind = this.monaco.languages.CompletionItemKind.Text;
                        switch (item.kind) {
                            case 'Keyword':
                                kind = this.monaco.languages.CompletionItemKind.Keyword;
                                break;
                            case 'Function':
                                kind = this.monaco.languages.CompletionItemKind.Function;
                                break;
                            case 'Variable':
                                kind = this.monaco.languages.CompletionItemKind.Variable;
                                break;
                            case 'TypeParameter':
                                kind = this.monaco.languages.CompletionItemKind.Class;
                                break;
                            case 'Value':
                                kind = this.monaco.languages.CompletionItemKind.Value;
                                break;
                            case 'Snippet':
                                kind = this.monaco.languages.CompletionItemKind.Snippet;
                                break;
                        }
                        return {
                            label: item.label,
                            kind,
                            detail: item.detail,
                            insertText: item.label,
                            range
                        };
                    });
                    resolve({ suggestions });
                }
            };
            if (this.worker) {
                this.worker.addEventListener('message', handleCompletion);
                const source = model.getValue();
                this.worker.postMessage({
                    type: 'completion',
                    source,
                    line: position.lineNumber - 1,
                    column: position.column - 1
                });
            }
            // Timeout fallback
            setTimeout(() => {
                this.worker?.removeEventListener('message', handleCompletion);
                resolve({ suggestions: [] });
            }, 1000);
        });
    }
    async provideDefinition(model, position) {
        if (!this.worker) {
            return null;
        }
        return new Promise((resolve) => {
            const handleDefinition = (event) => {
                const message = event.data;
                if (message.type === 'definition-result') {
                    this.worker?.removeEventListener('message', handleDefinition);
                    if (message.location) {
                        resolve({
                            uri: model.uri,
                            range: {
                                startLineNumber: message.location.line + 1,
                                startColumn: message.location.startColumn + 1,
                                endLineNumber: message.location.line + 1,
                                endColumn: message.location.endColumn + 1
                            }
                        });
                    }
                    else {
                        resolve(null);
                    }
                }
            };
            if (this.worker) {
                this.worker.addEventListener('message', handleDefinition);
                const source = model.getValue();
                this.worker.postMessage({
                    type: 'definition',
                    source,
                    line: position.lineNumber - 1,
                    column: position.column - 1
                });
            }
            // Timeout fallback
            setTimeout(() => {
                this.worker?.removeEventListener('message', handleDefinition);
                resolve(null);
            }, 1000);
        });
    }
    clearMarkers() {
        const model = this.editor?.getModel?.();
        if (model) {
            this.monaco.editor.setModelMarkers(model, 'pie-lsp', []);
        }
    }
    ensurePositiveNumber(value, fallback) {
        if (typeof value !== 'number' || Number.isNaN(value)) {
            return fallback;
        }
        return value < 1 ? fallback : value;
    }
    debounce(fn, delay) {
        let handle = null;
        return () => {
            if (handle !== null) {
                window.clearTimeout(handle);
            }
            handle = window.setTimeout(() => {
                handle = null;
                fn();
            }, delay);
        };
    }
}
/**
 * Register the Pie language with Monaco Editor with syntax highlighting.
 */
export function registerPieLanguage(monaco) {
    // Register a new language
    monaco.languages.register({ id: 'pie' });
    // Register language configuration
    monaco.languages.setLanguageConfiguration('pie', {
        comments: {
            lineComment: ';',
            blockComment: ['#|', '|#']
        },
        brackets: [
            ['(', ')'],
            ['[', ']'],
            ['{', '}']
        ],
        autoClosingPairs: [
            { open: '(', close: ')' },
            { open: '[', close: ']' },
            { open: '{', close: '}' },
            { open: '"', close: '"' }
        ],
        surroundingPairs: [
            { open: '(', close: ')' },
            { open: '[', close: ']' },
            { open: '{', close: '}' },
            { open: '"', close: '"' }
        ]
    });
    // Register a tokens provider for syntax highlighting
    monaco.languages.setMonarchTokensProvider('pie', {
        defaultToken: '',
        tokenPostfix: '.pie',
        keywords: [
            'lambda', 'λ', 'Pi', 'Π', 'Sigma', 'Σ',
            'define', 'claim', 'the', 'check-same',
            'define-tactically', 'TODO',
            'U', 'Universe', 'Nat', 'Atom', 'List', 'Vec', 'Either',
            'zero', 'add1', 'nil', 'cons', 'car', 'cdr',
            'ind-Nat', 'rec-Nat', 'iter-Nat',
            'ind-List', 'rec-List',
            'ind-Vec', 'rec-Vec',
            'ind-Either',
            'replace', 'trans', 'cong', 'symm', 'same',
            'left', 'right', 'ind-Either',
            'vecnil', 'vec::'
        ],
        operators: [
            '->', '→', '=', '::'
        ],
        // Common regular expressions
        symbols: /[=><!~?:&|+\-*/^%]+/,
        // Tokenizer rules
        tokenizer: {
            root: [
                // Whitespace
                { include: '@whitespace' },
                // Special forms and keywords
                [/\((?:lambda|λ|Pi|Π|Sigma|Σ|define|claim|the|check-same|define-tactically)\b/, 'keyword'],
                // Identifiers and keywords
                [/[a-zA-Z][a-zA-Z0-9\-_!?*+=<>λΠΣ→]*/, {
                        cases: {
                            '@keywords': 'keyword',
                            '@default': 'identifier'
                        }
                    }],
                // Numbers
                [/\d+/, 'number'],
                // Strings
                [/"([^"\\]|\\.)*$/, 'string.invalid'],
                [/"/, 'string', '@string'],
                // Quoted atoms
                [/'[a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*/, 'string.quoted'],
                // Delimiters and operators
                [/[()[\]]/, '@brackets'],
                [/@symbols/, {
                        cases: {
                            '@operators': 'operator',
                            '@default': ''
                        }
                    }],
            ],
            whitespace: [
                [/[ \t\r\n]+/, 'white'],
                [/;.*$/, 'comment'],
                [/#\|/, 'comment', '@comment'],
            ],
            comment: [
                [/[^#|]+/, 'comment'],
                [/\|#/, 'comment', '@pop'],
                [/[#|]/, 'comment']
            ],
            string: [
                [/[^\\"]+/, 'string'],
                [/\\./, 'string.escape'],
                [/"/, 'string', '@pop']
            ],
        },
    });
}
</file>

<file path="web/lsp/lsp-client-simple.ts">
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-explicit-any */

interface WorkerDiagnostic {
  severity: 'error' | 'warning';
  startLine: number;
  startColumn: number;
  endLine: number;
  endColumn: number;
  message: string;
}

interface ValidationResultMessage {
  type: 'validation-result';
  diagnostics: WorkerDiagnostic[];
}

interface ValidationErrorMessage {
  type: 'validation-error';
  error: string;
}

type WorkerResponse = ValidationResultMessage | ValidationErrorMessage;

type MonacoDisposable = { dispose(): void };

/**
 * Simple LSP client that connects Monaco Editor to our browser-based language server
 * without using monaco-languageclient (to avoid version conflicts).
 */
export class PieLanguageClient {
  private worker: Worker | null = null;
  private readonly monaco: any;
  private readonly editor: any;
  private disposables: MonacoDisposable[] = [];
  private debouncedValidate: (() => void) | null = null;
  private diagnostics: WorkerDiagnostic[] = [];

  constructor(monacoInstance: any, editorInstance: any) {
    this.monaco = monacoInstance;
    this.editor = editorInstance;
  }

  /**
   * Initialize the language client and connect it to the language server worker.
   */
  async start(): Promise<void> {
    this.worker = new Worker(new URL('./pie-lsp-worker-bundle.js', import.meta.url), { type: 'module' });

    this.worker.onmessage = (event: MessageEvent<WorkerResponse>) => {
      this.handleWorkerMessage(event.data);
    };
    this.worker.onerror = (error) => {
      console.error('LSP Worker error:', error);
    };

    const model = this.editor?.getModel?.();
    if (!model) {
      return;
    }

    this.debouncedValidate = this.debounce(() => {
      if (!this.worker) {
        return;
      }
      const source = model.getValue();
      this.worker.postMessage({ type: 'validate', source });
    }, 220);

    const changeDisposable = this.editor?.onDidChangeModelContent?.(() => {
      if (this.debouncedValidate) {
        this.debouncedValidate();
      }
    });
    if (changeDisposable) {
      this.disposables.push(changeDisposable);
    }

    const hoverDisposable = this.monaco.languages.registerHoverProvider('pie', {
      provideHover: (model: any, position: any) => this.provideHover(model, position)
    });
    this.disposables.push(hoverDisposable);

    // Register completion provider
    const completionDisposable = this.monaco.languages.registerCompletionItemProvider('pie', {
      provideCompletionItems: (model: any, position: any) => this.provideCompletionItems(model, position)
    });
    this.disposables.push(completionDisposable);

    // Register definition provider
    const definitionDisposable = this.monaco.languages.registerDefinitionProvider('pie', {
      provideDefinition: (model: any, position: any) => this.provideDefinition(model, position)
    });
    this.disposables.push(definitionDisposable);

    if (this.debouncedValidate) {
      this.debouncedValidate();
    }
  }

  /**
   * Stop the language client and terminate the worker.
   */
  async stop(): Promise<void> {
    this.clearMarkers();

    this.disposables.forEach(disposable => {
      if (disposable && typeof disposable.dispose === 'function') {
        disposable.dispose();
      }
    });
    this.disposables = [];
    this.debouncedValidate = null;
    this.diagnostics = [];

    if (this.worker) {
      this.worker.terminate();
      this.worker = null;
    }
  }

  /**
   * Check if the client is running.
   */
  isRunning(): boolean {
    return this.worker !== null;
  }

  private handleWorkerMessage(message: WorkerResponse): void {
    if (!message) {
      return;
    }

    if (message.type === 'validation-result') {
      this.updateDiagnostics(message.diagnostics ?? []);
    } else if (message.type === 'validation-error') {
      this.updateDiagnostics([
        {
          severity: 'error',
          startLine: 1,
          startColumn: 1,
          endLine: 1,
          endColumn: 2,
          message: message.error
        }
      ]);
    }
  }

  private updateDiagnostics(diagnostics: WorkerDiagnostic[]): void {
    this.diagnostics = diagnostics;
    const model = this.editor?.getModel?.();
    if (!model) {
      return;
    }

    const markers = diagnostics.map((diag) => {
      const startLine = this.ensurePositiveNumber(diag.startLine, 1);
      const endLine = this.ensurePositiveNumber(diag.endLine, startLine);
      const startColumn = this.ensurePositiveNumber(diag.startColumn, 1);
      const endColumn = this.ensurePositiveNumber(diag.endColumn, startColumn + 1);
      return {
        startLineNumber: startLine,
        startColumn,
        endLineNumber: endLine,
        endColumn,
        message: diag.message,
        severity: diag.severity === 'warning'
          ? this.monaco.MarkerSeverity.Warning
          : this.monaco.MarkerSeverity.Error
      };
    });

    this.monaco.editor.setModelMarkers(model, 'pie-lsp', markers);
  }

  private async provideHover(model: any, position: { lineNumber: number; column: number; }) {
    if (!this.worker) {
      return null;
    }

    // First, check if there's a diagnostic at this position
    const diagnostic = this.diagnostics.find((diag) => {
      const startLine = this.ensurePositiveNumber(diag.startLine, position.lineNumber);
      const endLine = this.ensurePositiveNumber(diag.endLine, startLine);
      const startColumn = this.ensurePositiveNumber(diag.startColumn, 1);
      const endColumn = this.ensurePositiveNumber(diag.endColumn, startColumn + 1);

      if (position.lineNumber < startLine || position.lineNumber > endLine) {
        return false;
      }
      if (position.lineNumber === startLine && position.column < startColumn) {
        return false;
      }
      if (position.lineNumber === endLine && position.column > endColumn) {
        return false;
      }
      return true;
    });

    if (diagnostic) {
      const startLine = this.ensurePositiveNumber(diagnostic.startLine, position.lineNumber);
      const endLine = this.ensurePositiveNumber(diagnostic.endLine, startLine);
      const startColumn = this.ensurePositiveNumber(diagnostic.startColumn, 1);
      const endColumn = this.ensurePositiveNumber(diagnostic.endColumn, startColumn + 1);

      return {
        contents: [
          { value: `**${diagnostic.severity === 'warning' ? 'Warning' : 'Error'}**\n\n${diagnostic.message}` }
        ],
        range: {
          startLineNumber: startLine,
          startColumn,
          endLineNumber: endLine,
          endColumn
        }
      };
    }

    // If no diagnostic, request hover info from worker
    return new Promise((resolve) => {
      const handleHover = (event: MessageEvent) => {
        const message = event.data;
        if (message.type === 'hover-result') {
          this.worker?.removeEventListener('message', handleHover);

          if (!message.hoverInfo) {
            resolve(null);
            return;
          }

          const info = message.hoverInfo;
          let markdownContent = `**${info.title}**\n\n${info.summary}`;

          if (info.details) {
            markdownContent += `\n\n${info.details}`;
          }

          if (info.examples) {
            markdownContent += `\n\n**Examples:**\n\`\`\`pie\n${info.examples}\n\`\`\``;
          }

          resolve({
            contents: [
              { value: markdownContent }
            ]
          });
        }
      };

      if (this.worker) {
        this.worker.addEventListener('message', handleHover);

        const source = model.getValue();
        this.worker.postMessage({
          type: 'hover',
          source,
          line: position.lineNumber - 1,
          column: position.column - 1
        });
      }

      // Timeout fallback
      setTimeout(() => {
        this.worker?.removeEventListener('message', handleHover);
        resolve(null);
      }, 1000);
    });
  }

  private async provideCompletionItems(model: any, position: any): Promise<any> {
    if (!this.worker) {
      return { suggestions: [] };
    }

    return new Promise((resolve) => {
      const handleCompletion = (event: MessageEvent) => {
        const message = event.data;
        if (message.type === 'completion-result') {
          this.worker?.removeEventListener('message', handleCompletion);

          // Calculate the range to replace based on word boundaries
          const wordRange = message.wordRange;
          const range = wordRange ? {
            startLineNumber: position.lineNumber,
            startColumn: wordRange.start + 1, // Monaco uses 1-based columns
            endLineNumber: position.lineNumber,
            endColumn: wordRange.end + 1
          } : {
            startLineNumber: position.lineNumber,
            startColumn: position.column,
            endLineNumber: position.lineNumber,
            endColumn: position.column
          };

          const suggestions = message.completions.map((item: any) => {
            // Map kind strings to Monaco CompletionItemKind
            let kind = this.monaco.languages.CompletionItemKind.Text;
            switch (item.kind) {
              case 'Keyword':
                kind = this.monaco.languages.CompletionItemKind.Keyword;
                break;
              case 'Function':
                kind = this.monaco.languages.CompletionItemKind.Function;
                break;
              case 'Variable':
                kind = this.monaco.languages.CompletionItemKind.Variable;
                break;
              case 'TypeParameter':
                kind = this.monaco.languages.CompletionItemKind.Class;
                break;
              case 'Value':
                kind = this.monaco.languages.CompletionItemKind.Value;
                break;
              case 'Snippet':
                kind = this.monaco.languages.CompletionItemKind.Snippet;
                break;
            }

            return {
              label: item.label,
              kind,
              detail: item.detail,
              insertText: item.label,
              range
            };
          });

          resolve({ suggestions });
        }
      };

      if (this.worker) {
        this.worker.addEventListener('message', handleCompletion);

        const source = model.getValue();
        this.worker.postMessage({
          type: 'completion',
          source,
          line: position.lineNumber - 1,
          column: position.column - 1
        });
      }

      // Timeout fallback
      setTimeout(() => {
        this.worker?.removeEventListener('message', handleCompletion);
        resolve({ suggestions: [] });
      }, 1000);
    });
  }

  private async provideDefinition(model: any, position: any): Promise<any> {
    if (!this.worker) {
      return null;
    }

    return new Promise((resolve) => {
      const handleDefinition = (event: MessageEvent) => {
        const message = event.data;
        if (message.type === 'definition-result') {
          this.worker?.removeEventListener('message', handleDefinition);

          if (message.location) {
            resolve({
              uri: model.uri,
              range: {
                startLineNumber: message.location.line + 1,
                startColumn: message.location.startColumn + 1,
                endLineNumber: message.location.line + 1,
                endColumn: message.location.endColumn + 1
              }
            });
          } else {
            resolve(null);
          }
        }
      };

      if (this.worker) {
        this.worker.addEventListener('message', handleDefinition);

        const source = model.getValue();
        this.worker.postMessage({
          type: 'definition',
          source,
          line: position.lineNumber - 1,
          column: position.column - 1
        });
      }

      // Timeout fallback
      setTimeout(() => {
        this.worker?.removeEventListener('message', handleDefinition);
        resolve(null);
      }, 1000);
    });
  }

  private clearMarkers(): void {
    const model = this.editor?.getModel?.();
    if (model) {
      this.monaco.editor.setModelMarkers(model, 'pie-lsp', []);
    }
  }

  private ensurePositiveNumber(value: number | null | undefined, fallback: number): number {
    if (typeof value !== 'number' || Number.isNaN(value)) {
      return fallback;
    }
    return value < 1 ? fallback : value;
  }

  private debounce(fn: () => void, delay: number): () => void {
    let handle: number | null = null;
    return () => {
      if (handle !== null) {
        window.clearTimeout(handle);
      }
      handle = window.setTimeout(() => {
        handle = null;
        fn();
      }, delay);
    };
  }
}

/**
 * Register the Pie language with Monaco Editor with syntax highlighting.
 */
export function registerPieLanguage(monaco: any): void {
  // Register a new language
  monaco.languages.register({ id: 'pie' });

  // Register language configuration
  monaco.languages.setLanguageConfiguration('pie', {
    comments: {
      lineComment: ';',
      blockComment: ['#|', '|#']
    },
    brackets: [
      ['(', ')'],
      ['[', ']'],
      ['{', '}']
    ],
    autoClosingPairs: [
      { open: '(', close: ')' },
      { open: '[', close: ']' },
      { open: '{', close: '}' },
      { open: '"', close: '"' }
    ],
    surroundingPairs: [
      { open: '(', close: ')' },
      { open: '[', close: ']' },
      { open: '{', close: '}' },
      { open: '"', close: '"' }
    ]
  });

  // Register a tokens provider for syntax highlighting
  monaco.languages.setMonarchTokensProvider('pie', {
    defaultToken: '',
    tokenPostfix: '.pie',

    keywords: [
      'lambda', 'λ', 'Pi', 'Π', 'Sigma', 'Σ',
      'define', 'claim', 'the', 'check-same',
      'define-tactically', 'TODO',
      'U', 'Universe', 'Nat', 'Atom', 'List', 'Vec', 'Either',
      'zero', 'add1', 'nil', 'cons', 'car', 'cdr',
      'ind-Nat', 'rec-Nat', 'iter-Nat',
      'ind-List', 'rec-List',
      'ind-Vec', 'rec-Vec',
      'ind-Either',
      'replace', 'trans', 'cong', 'symm', 'same',
      'left', 'right', 'ind-Either',
      'vecnil', 'vec::'
    ],

    operators: [
      '->', '→', '=', '::'
    ],

    // Common regular expressions
    symbols: /[=><!~?:&|+\-*/^%]+/,

    // Tokenizer rules
    tokenizer: {
      root: [
        // Whitespace
        { include: '@whitespace' },

        // Special forms and keywords
        [/\((?:lambda|λ|Pi|Π|Sigma|Σ|define|claim|the|check-same|define-tactically)\b/, 'keyword'],

        // Identifiers and keywords
        [/[a-zA-Z][a-zA-Z0-9\-_!?*+=<>λΠΣ→]*/, {
          cases: {
            '@keywords': 'keyword',
            '@default': 'identifier'
          }
        }],

        // Numbers
        [/\d+/, 'number'],

        // Strings
        [/"([^"\\]|\\.)*$/, 'string.invalid'],
        [/"/, 'string', '@string'],

        // Quoted atoms
        [/'[a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*/, 'string.quoted'],

        // Delimiters and operators
        [/[()[\]]/, '@brackets'],
        [/@symbols/, {
          cases: {
            '@operators': 'operator',
            '@default': ''
          }
        }],
      ],

      whitespace: [
        [/[ \t\r\n]+/, 'white'],
        [/;.*$/, 'comment'],
        [/#\|/, 'comment', '@comment'],
      ],

      comment: [
        [/[^#|]+/, 'comment'],
        [/\|#/, 'comment', '@pop'],
        [/[#|]/, 'comment']
      ],

      string: [
        [/[^\\"]+/, 'string'],
        [/\\./, 'string.escape'],
        [/"/, 'string', '@pop']
      ],
    },
  });
}
</file>

<file path="web/lsp/pie_hover_info.ts">
// Built-in Pie symbols with hover information
export const PIE_HOVER_INFO = new Map([
  // Natural numbers
  ['Nat', {
    summary: 'Natural numbers',
    details: 'The type of natural numbers (0, 1, 2, ...)',
    examples: '(the Nat 5)'
  }],
  ['zero', {
    summary: 'Zero',
    details: 'The natural number zero.',
    examples: '(the Nat zero)'
  }],
  ['add1', {
    summary: 'Add one',
    details: 'Adds one to a natural number.',
    examples: '(add1 3) ; evaluates to 4'
  }],
  // Nat's elimination forms
  ['which-Nat', {
    summary: 'Case analysis on natural numbers',
    details: 'Performs case analysis on a natural number.',
    examples: '(which-Nat n base step)'
  }],
  ['iter-Nat', {
    summary: 'Iteration on natural numbers',
    details: 'Performs iteration on a natural number.',
    examples: '(iter-Nat n base step)'
  }],
  ['rec-Nat', {
    summary: 'Recursion on natural numbers',
    details: 'Performs recursion on a natural number.',
    examples: '(rec-Nat n base step)'
  }],
  ['ind-Nat', {
    summary: 'Induction on natural numbers',
    details: 'Performs induction on a natural number.',
    examples: '(ind-Nat n motive base step)'
  }],

  // Atoms
  ['Atom', {
    summary: 'Atomic values',
    details: 'The type of indivisible values (quoted symbols).',
    examples: "(the Atom 'hello)"
  }],
  ['quote', {
    summary: 'Quote an atom',
    details: 'Creates an atomic value.',
    examples: "(quote hello) ; same as 'hello"
  }],

  // Lists
  ['List', {
    summary: 'Lists',
    details: 'A list type constructor.',
    examples: '(List Nat) ; type of lists of natural numbers'
  }],
  ['nil', {
    summary: 'Empty list',
    details: 'The empty list.',
    examples: '(the (List Nat) nil)'
  }],
  ['::',  {
    summary: 'List constructor',
    details: 'Adds an element to the front of a list.',
    examples: '(:: 1 (:: 2 nil))'
  }],
  ['rec-List', {
    summary: 'Recursion on lists',
    details: 'Performs recursion on a list.',
    examples: '(rec-List lst base step)'
  }],
  ['ind-List', {
    summary: 'Induction on lists',
    details: 'Performs induction on a list.',
    examples: '(ind-List lst motive base step)'/*  */
  }],

  // Functions
  ['lambda', {
    summary: 'Lambda expression',
    details: 'Creates an anonymous function.',
    examples: '(lambda (x) (add1 x))'
  }],
  ['λ', {
    summary: 'Lambda expression (Unicode)',
    details: 'Unicode version of lambda.',
    examples: '(λ (x) (add1 x))'
  }],

  // Types
  ['the', {
    summary: 'Type annotation',
    details: 'Asserts that an expression has a particular type.',
    examples: '(the Nat 5)'
  }],
  ['->', {
    summary: 'Function type',
    details: 'Non-dependent function type.',
    examples: '(the (-> Nat Nat) (lambda (x) (add1 x)))'
  }],
  ['→', {
    summary: 'Function type (Unicode)',
    details: 'Unicode version of ->.',
    examples: '(the (→ Nat Nat) (λ (x) (add1 x)))'
  }],
  ['Universe', {
    summary: 'Type of types',
    details: 'The type of types.',
    examples: '(the Universe Nat)'
  }],
  ['U', {
    summary: 'Type of types (short)',
    details: 'Short form of Universe.',
    examples: '(the U Nat)'
  }],

  // Dependent types
  ['Pi', {
    summary: 'Dependent function type',
    details: 'Creates a dependent function type.',
    examples: '(Pi ((n Nat)) (Vec Nat n))'
  }],
  ['Π', {
    summary: 'Dependent function type (Unicode)',
    details: 'Unicode version of Pi.',
    examples: '(Π ((n Nat)) (Vec Nat n))'
  }],
  ['Sigma', {
    summary: 'Dependent pair type',
    details: 'Creates a dependent pair type.',
    examples: '(Sigma ((A U)) (List A))'
  }],
  ['Σ', {
    summary: 'Dependent pair type (Unicode)',
    details: 'Unicode version of Sigma.',
    examples: '(Σ ((A U)) (List A))'
  }],

  // Pairs
  ['Pair', {
    summary: 'Pair type',
    details: 'Type of pairs (non-dependent).',
    examples: '(Pair Nat Atom)'
  }],
  ['cons', {
    summary: 'Pair constructor',
    details: 'Creates a pair.',
    examples: '(cons 1 2)'
  }],
  ['car', {
    summary: 'First element of pair',
    details: 'Extracts the first element of a pair.',
    examples: '(car (cons 1 2)) ; evaluates to 1'
  }],
  ['cdr', {
    summary: 'Second element of pair',
    details: 'Extracts the second element of a pair.',
    examples: '(cdr (cons 1 2)) ; evaluates to 2'
  }],

  // Eithers
  ['Either', {
    summary: 'Either type',
    details: 'Type representing a value that can be one of two types.',
    examples: '(Either Nat Atom)'
  }],
  ['left', {
    summary: 'Left constructor for Either',
    details: 'Creates a left value of an Either type.',
    examples: '(left 5) ; if Either is (Either Nat Atom)'
  }],
  ['right', {
    summary: 'Right constructor for Either',
    details: 'Creates a right value of an Either type.',
    examples: "(right 'hello) ; if Either is (Either Nat Atom)"
  }],
  ['ind-Either', {
    summary: 'Induction on Either type',
    details: 'Performs induction on an Either value.',
    examples: '(ind-Either e motive left-case right-case)'
  }],

  // Vectors
  ['Vec', {
    summary: 'Vectors',
    details: 'Type of vectors (lists with fixed length).',
    examples: '(Vec Nat 3) ; type of vectors of 3 natural numbers'
  }],
  ['vecnil', {
    summary: 'Empty vector',
    details: 'The empty vector.',
    examples: '(the (Vec Nat 0) vecnil)'
  }],
  ['vec::',  {
    summary: 'Vector constructor',
    details: 'Adds an element to the front of a vector.',
    examples: '(vec:: 1 (vec:: 2 vecnil))'
  }],
  ['ind-Vec', {
    summary: 'Induction on vectors',
    details: 'Performs induction on a vector.',
    examples: '(ind-Vec v len motive base step)'
  }],

  // Equality
  ['=', {
    summary: 'Equality type',
    details: 'Type of equality proofs.',
    examples: '(= Nat 1 1)'
  }],
  ['same', {
    summary: 'Reflexivity of equality',
    details: 'Proof that something equals itself.',
    examples: '(same 5)'
  }],
  ['replace', {
    summary: 'Substitution of equals for equals',
    details: 'Uses an equality proof to replace equals for equals.',
    examples: '(replace proof-a=b target motive)'
  }],
  ['trans', {
    summary: 'Transitivity of equality',
    details: 'Combines two equality proofs.',
    examples: '(trans proof-a=b proof-b=c)'
  }],
  ['cong', {
    summary: 'Congruence of equality',
    details: 'Applies a function to both sides of an equality.',
    examples: '(cong proof-a=b function)'
  }],
  ['symm', {
    summary: 'Symmetry of equality',
    details: 'Reverses an equality proof.',
    examples: '(symm proof-a=b)'
  }],
  ['ind-=', {
    summary: 'Induction on equality',
    details: 'Performs induction on an equality proof.',
    examples: '(ind-= proof-a=b proof-b=c)'
  }],


  // Special
  ['TODO', {
    summary: 'Placeholder for incomplete code',
    details: 'Indicates a hole to be filled in later.',
    examples: '(define my-function TODO)'
  }],
  ['Absurd', {
    summary: 'Absurd type',
    details: 'A type with no elements, representing falsehood.',
    examples: 'Absurd has no elements'
  }],
  ['Trivial', {
    summary: 'Trivial type',
    details: 'A type with exactly one element.',
    examples: '(the Trivial 5)'
  }],

  // Keywords
  ['define', {
    summary: 'Define a value',
    details: 'Defines a named value or function.',
    examples: '(define my-nat 5)\n(define add-two (lambda (x) (add1 (add1 x))))'
  }],
  ['claim', {
    summary: 'Claim the type of a name',
    details: 'Declares the type of a name before defining it.',
    examples: '(claim my-nat Nat)\n(define my-nat 5)'
  }],
  ['define-tactically', {
    summary: 'Define using tactics',
    details: 'Defines a value using the tactic system.',
    examples: '(define-tactically my-proof ...)'
  }],
  ['check-same', {
    summary: 'Check that two expressions are the same',
    details: 'Verifies that two expressions evaluate to the same value.',
    examples: '(check-same Nat (add1 2) 3)'
  }],
]);
</file>

<file path="web/lsp/README.md">
# Browser-Based Language Server for Pie

This directory contains a browser-compatible version of the Pie language server that can be used in the web interface deployed on GitHub Pages.

## Overview

The browser-based language server provides language support features for Pie code directly in the browser:

- **Syntax Highlighting**: Full syntax highlighting for Pie language constructs
- **Diagnostics**: Real-time error checking and type checking as you type
- **Language Features** (in progress): Hover tooltips, go-to-definition, code completion

## Architecture

The implementation consists of two main components:

### 1. Language Server Worker (`pie-language-server-simple.worker.ts`)

A Web Worker that runs the Pie type checker and provides diagnostics. It:
- Parses Pie source code
- Performs type checking using the Pie interpreter
- Returns diagnostics (errors and warnings) with line/column information

**Built as**: `pie-lsp-worker-bundle.js` (175KB)

### 2. LSP Client (`lsp-client-simple.ts`)

A client that:
- Registers the Pie language with Monaco Editor
- Provides syntax highlighting configuration
- Manages the language server worker
- Will integrate LSP features when Monaco supports them

**Built as**: `lsp-client-bundle.js` (2.2KB)

## Usage

The language server is automatically loaded in the web interface (`web/app.js`):

```javascript
// In app.js:
async function initializeLSP() {
  try {
    const { PieLanguageClient, registerPieLanguage } = await import('./lsp/lsp-client-bundle.js');

    // Register Pie language for Monaco
    registerPieLanguage(window.monaco);

    // Start LSP client (manages the worker)
    const lspClient = new PieLanguageClient();
    await lspClient.start();

    return lspClient;
  } catch (error) {
    console.error('Failed to initialize LSP client:', error);
    return null;
  }
}
```

## Building

The bundles are automatically built when you run:

```bash
npm run build
```

This uses Rollup to create browser-compatible bundles from TypeScript source.

## Features

### Current Features

✅ **Syntax Highlighting**
- Keywords: `lambda`, `λ`, `Pi`, `Π`, `Sigma`, `Σ`, `define`, `claim`, etc.
- Types: `Nat`, `Atom`, `List`, `Vec`, `Either`, etc.
- Operators: `->`, `→`, `=`, `::`
- Comments: Line comments (`;`) and block comments (`#| |#`)

✅ **Type Checking via Worker**
- Real-time validation as you type
- Proper error messages with locations
- Support for all Pie constructs

### Future Enhancements

🔄 **LSP Protocol Integration**
- Full Language Server Protocol support
- Hover information for built-in and user-defined symbols
- Go-to-definition for user-defined functions
- Auto-completion suggestions

## Files

- `pie-language-server-simple.worker.ts` - Worker implementation
- `lsp-client-simple.ts` - Client implementation
- `pie-lsp-worker-bundle.js` - Built worker bundle
- `lsp-client-bundle.js` - Built client bundle

## Dependencies

- Monaco Editor (loaded via CDN)
- Pie interpreter modules (bundled)

## Notes

This is a simplified implementation that doesn't use the full `monaco-languageclient` library to avoid version conflicts and reduce bundle size. The current diagnostics are provided through the existing diagnostics worker, while the LSP client focuses on syntax highlighting and language registration.

For full LSP features (hover, completion, etc.), the language server worker would need to implement the Language Server Protocol message passing, which can be added incrementally.
</file>

<file path="web/proof-tree/CollapsibleTypeTree.ts">
/**
 * Collapsible tree renderer for type visualization.
 * Renders parsed S-expressions as interactive expandable/collapsible nodes.
 */

import { TypeNode } from './types';
import { parseSExpression, getTypeCategory } from './SExpressionParser';

/**
 * Interactive collapsible tree component for displaying complex types.
 */
export class CollapsibleTypeTree {
  private container: HTMLElement;
  private rootNode: TypeNode | null = null;
  private nodeStates: Map<string, boolean> = new Map(); // true = expanded
  private nodeIdCounter: number = 0;

  constructor(container: HTMLElement) {
    this.container = container;
    this.container.classList.add('type-tree');
  }

  /**
   * Render a type string as an interactive tree.
   */
  render(typeString: string): void {
    this.clear();
    this.nodeIdCounter = 0;

    const trimmed = typeString.trim();
    if (!trimmed) {
      this.showPlaceholder('No type to display');
      return;
    }

    try {
      this.rootNode = parseSExpression(trimmed);

      if (this.rootNode.kind === 'error') {
        // Fallback to plain text display on parse error
        this.showPlainText(trimmed);
        return;
      }

      const treeElement = this.renderNode(this.rootNode, 0);
      this.container.appendChild(treeElement);
    } catch (e) {
      // Fallback to plain text display
      this.showPlainText(trimmed);
    }
  }

  /**
   * Clear the tree display.
   */
  clear(): void {
    this.container.innerHTML = '';
    this.rootNode = null;
    this.nodeStates.clear();
    this.nodeIdCounter = 0;
  }

  /**
   * Expand all nodes.
   */
  expandAll(): void {
    this.nodeStates.forEach((_, key) => this.nodeStates.set(key, true));
    if (this.rootNode) {
      this.container.innerHTML = '';
      const treeElement = this.renderNode(this.rootNode, 0);
      this.container.appendChild(treeElement);
    }
  }

  /**
   * Collapse all nodes.
   */
  collapseAll(): void {
    this.nodeStates.forEach((_, key) => this.nodeStates.set(key, false));
    if (this.rootNode) {
      this.container.innerHTML = '';
      const treeElement = this.renderNode(this.rootNode, 0);
      this.container.appendChild(treeElement);
    }
  }

  private showPlaceholder(message: string): void {
    const placeholder = document.createElement('div');
    placeholder.className = 'type-tree__placeholder';
    placeholder.textContent = message;
    this.container.appendChild(placeholder);
  }

  private showPlainText(text: string): void {
    const pre = document.createElement('pre');
    pre.className = 'type-tree__fallback';
    pre.textContent = text;
    this.container.appendChild(pre);
  }

  private renderNode(node: TypeNode, depth: number): HTMLElement {
    const nodeId = `n${this.nodeIdCounter++}`;

    // Initialize state: deep nodes start collapsed
    if (!this.nodeStates.has(nodeId)) {
      this.nodeStates.set(nodeId, depth < 3);
    }

    const isExpanded = this.nodeStates.get(nodeId) ?? true;

    if (node.isAtom) {
      return this.renderAtom(node);
    }

    return this.renderListNode(node, nodeId, depth, isExpanded);
  }

  private renderAtom(node: TypeNode): HTMLElement {
    const span = document.createElement('span');
    span.className = 'type-node type-node--atom';

    const kindSpan = document.createElement('span');
    const category = getTypeCategory(node.kind);
    kindSpan.className = `type-node__kind type-kind--${category}`;
    kindSpan.textContent = node.value || node.kind;
    span.appendChild(kindSpan);

    return span;
  }

  private renderListNode(node: TypeNode, nodeId: string, depth: number, isExpanded: boolean): HTMLElement {
    const div = document.createElement('div');
    div.className = 'type-node type-node--list';
    div.dataset.nodeId = nodeId;

    // Skip the first child if it's the kind identifier
    const children = node.children;
    const hasKindChild = children.length > 0 && children[0].isAtom && children[0].kind === node.kind;
    const displayChildren = hasKindChild ? children.slice(1) : children;

    const hasChildren = displayChildren.length > 0;

    // Header row with toggle, kind, and binding/abbreviation
    const header = document.createElement('div');
    header.className = 'type-node__header';

    // Toggle button (only if there are children)
    if (hasChildren) {
      const toggle = document.createElement('span');
      toggle.className = 'type-node__toggle';
      toggle.textContent = isExpanded ? '▼' : '▶';
      toggle.addEventListener('click', (e) => {
        e.stopPropagation();
        this.toggleNode(nodeId);
      });
      header.appendChild(toggle);
    } else {
      // Spacer for alignment
      const spacer = document.createElement('span');
      spacer.className = 'type-node__toggle-spacer';
      header.appendChild(spacer);
    }

    // Kind label
    const kindSpan = document.createElement('span');
    const category = getTypeCategory(node.kind);
    kindSpan.className = `type-node__kind type-kind--${category}`;
    kindSpan.textContent = node.kind;
    header.appendChild(kindSpan);

    // Render based on type and expansion state
    if (this.isBindingType(node.kind) && displayChildren.length >= 2) {
      // Handle Π, Σ, λ with bindings
      const binding = displayChildren[0];
      if (!binding.isAtom && binding.children.length >= 2) {
        const bindingSpan = document.createElement('span');
        bindingSpan.className = 'type-node__binding';
        const varName = binding.children[0].value || binding.children[0].kind;
        const varType = binding.children[1].abbreviation;
        bindingSpan.textContent = ` (${varName} : ${varType})`;
        header.appendChild(bindingSpan);
      } else if (!binding.isAtom && binding.children.length === 1) {
        // Lambda with just variable name
        const bindingSpan = document.createElement('span');
        bindingSpan.className = 'type-node__binding';
        const varName = binding.children[0].value || binding.children[0].kind;
        bindingSpan.textContent = ` (${varName})`;
        header.appendChild(bindingSpan);
      }
    }

    // Show abbreviation when collapsed
    if (!isExpanded && hasChildren) {
      const abbrev = document.createElement('span');
      abbrev.className = 'type-node__abbrev';
      abbrev.textContent = ' ' + this.getCollapsedHint(node, displayChildren);
      header.appendChild(abbrev);
    }

    div.appendChild(header);

    // Children container
    if (hasChildren && isExpanded) {
      const childrenDiv = document.createElement('div');
      childrenDiv.className = 'type-node__children';

      // Determine which children to render based on type
      const childrenToRender = this.getChildrenToRender(node, displayChildren);

      for (const child of childrenToRender) {
        const childElement = this.renderNode(child, depth + 1);
        childrenDiv.appendChild(childElement);
      }

      div.appendChild(childrenDiv);
    }

    return div;
  }

  private isBindingType(kind: string): boolean {
    return kind === 'Π' || kind === 'Pi' || kind === 'Σ' || kind === 'Sigma' || kind === 'λ' || kind === 'lambda';
  }

  private getChildrenToRender(node: TypeNode, displayChildren: TypeNode[]): TypeNode[] {
    // For binding types, skip the binding and render the body
    if (this.isBindingType(node.kind) && displayChildren.length >= 2) {
      return displayChildren.slice(1);
    }
    return displayChildren;
  }

  private getCollapsedHint(node: TypeNode, displayChildren: TypeNode[]): string {
    if (displayChildren.length === 0) {
      return '';
    }

    // For binding types, hint at the body
    if (this.isBindingType(node.kind) && displayChildren.length >= 2) {
      const body = displayChildren[1];
      if (body.isAtom) {
        return body.kind;
      }
      return `→ ${body.kind} ...`;
    }

    // Generic hint
    return '...';
  }

  private toggleNode(nodeId: string): void {
    const currentState = this.nodeStates.get(nodeId) ?? true;
    this.nodeStates.set(nodeId, !currentState);

    // Re-render
    if (this.rootNode) {
      this.nodeIdCounter = 0;
      this.container.innerHTML = '';
      const treeElement = this.renderNode(this.rootNode, 0);
      this.container.appendChild(treeElement);
    }
  }
}
</file>

<file path="web/proof-tree/ContextPanel.ts">
/**
 * Context panel component that displays hypothesis entries.
 * Shows the context (variables in scope) for the selected goal.
 */

import { SerializableGoal } from './types';

export class ContextPanel {
  private container: HTMLElement;
  private currentGoal: SerializableGoal | null = null;

  constructor(container: HTMLElement) {
    this.container = container;
    this.clear();
  }

  display(goal: SerializableGoal): void {
    this.currentGoal = goal;
    this.container.innerHTML = '';

    // Header with label
    const header = document.createElement('div');
    header.className = 'panel-header';

    const title = document.createElement('div');
    title.className = 'panel-label';
    title.textContent = 'Context';
    header.appendChild(title);

    this.container.appendChild(header);

    // Context entries list
    const contentDiv = document.createElement('div');
    contentDiv.className = 'panel-content';

    if (goal.contextEntries.length > 0) {
      const contextList = document.createElement('div');
      contextList.className = 'context-list';

      for (const entry of goal.contextEntries) {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'context-entry';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'context-entry-name';
        nameSpan.textContent = entry.name;
        entryDiv.appendChild(nameSpan);

        const colonSpan = document.createElement('span');
        colonSpan.className = 'context-entry-colon';
        colonSpan.textContent = ' : ';
        entryDiv.appendChild(colonSpan);

        const typeSpan = document.createElement('span');
        typeSpan.className = 'context-entry-type';
        typeSpan.textContent = entry.type;
        entryDiv.appendChild(typeSpan);

        contextList.appendChild(entryDiv);
      }

      contentDiv.appendChild(contextList);
    } else {
      const emptyMsg = document.createElement('div');
      emptyMsg.className = 'panel-empty';
      emptyMsg.textContent = '(empty)';
      contentDiv.appendChild(emptyMsg);
    }

    this.container.appendChild(contentDiv);
  }

  clear(): void {
    this.currentGoal = null;
    this.container.innerHTML = `
      <div class="panel-placeholder">
        Select a goal
      </div>
    `;
  }

  getCurrentGoal(): SerializableGoal | null {
    return this.currentGoal;
  }
}
</file>

<file path="web/proof-tree/GoalPanel.ts">
/**
 * Goal panel component that displays the goal type.
 * Shows the goal type with collapsible tree visualization.
 */

import { SerializableGoal } from './types';
import { CollapsibleTypeTree } from './CollapsibleTypeTree';

export class GoalPanel {
  private container: HTMLElement;
  private currentGoal: SerializableGoal | null = null;
  private goalTypeTree: CollapsibleTypeTree | null = null;

  constructor(container: HTMLElement) {
    this.container = container;
    this.clear();
  }

  display(goal: SerializableGoal): void {
    this.currentGoal = goal;
    this.container.innerHTML = '';

    // Header with goal ID and status
    const header = document.createElement('div');
    header.className = 'panel-header';

    const titleRow = document.createElement('div');
    titleRow.className = 'panel-title-row';

    const title = document.createElement('div');
    title.className = 'panel-label';
    title.textContent = 'Goal';
    titleRow.appendChild(title);

    const goalId = document.createElement('span');
    goalId.className = 'panel-goal-id';
    goalId.textContent = goal.id;
    titleRow.appendChild(goalId);

    header.appendChild(titleRow);

    // Status badge
    const status = document.createElement('span');
    status.className = 'panel-status';
    if (goal.isComplete) {
      status.textContent = 'Completed';
      status.classList.add('status-completed');
    } else if (goal.isCurrent) {
      status.textContent = 'Ongoing';
      status.classList.add('status-ongoing');
    } else {
      status.textContent = 'Pending';
      status.classList.add('status-pending');
    }
    header.appendChild(status);

    this.container.appendChild(header);

    // Goal type with collapsible tree
    const contentDiv = document.createElement('div');
    contentDiv.className = 'panel-content';

    const goalTypeContainer = document.createElement('div');
    goalTypeContainer.className = 'goal-type-tree';
    this.goalTypeTree = new CollapsibleTypeTree(goalTypeContainer);
    this.goalTypeTree.render(goal.type);
    contentDiv.appendChild(goalTypeContainer);

    this.container.appendChild(contentDiv);
  }

  clear(): void {
    this.currentGoal = null;
    this.goalTypeTree = null;
    this.container.innerHTML = `
      <div class="panel-placeholder">
        Select a goal
      </div>
    `;
  }

  getCurrentGoal(): SerializableGoal | null {
    return this.currentGoal;
  }
}
</file>

<file path="web/proof-tree/ProofTreeVisualizer.ts">
/**
 * SVG-based proof tree visualizer component.
 * Renders goals as blocks with tactic labels on edges.
 */

import { ProofTreeData, SerializableGoalNode, SerializableGoal } from './types';

export interface VisualizerConfig {
  nodeWidth: number;
  nodeHeight: number;
  horizontalSpacing: number;
  verticalSpacing: number;
  colors: {
    current: string;
    completed: string;
    pending: string;
    edge: string;
    tacticLabel: string;
    background: string;
  };
}

const DEFAULT_CONFIG: VisualizerConfig = {
  nodeWidth: 180,
  nodeHeight: 60,
  horizontalSpacing: 40,
  verticalSpacing: 80,
  colors: {
    current: '#f59e0b',   // amber/orange for ongoing goal
    completed: '#34d399', // green for completed
    pending: '#64748b',   // gray for pending
    edge: '#475569',
    tacticLabel: '#94a3b8',
    background: '#0f172a'
  }
};

interface NodePosition {
  x: number;
  y: number;
  width: number;
}

export class ProofTreeVisualizer {
  private svg: SVGSVGElement | null = null;
  private config: VisualizerConfig;
  private container: HTMLElement;
  private onGoalSelect: ((goal: SerializableGoal) => void) | null = null;
  private currentData: ProofTreeData | null = null;

  constructor(container: HTMLElement, config?: Partial<VisualizerConfig>) {
    this.container = container;
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  setOnGoalSelect(callback: (goal: SerializableGoal) => void): void {
    this.onGoalSelect = callback;
  }

  render(data: ProofTreeData): void {
    this.currentData = data;
    this.clear();

    // Calculate layout
    const positions = this.calculateLayout(data.root);

    // Find bounds
    let minX = Infinity, maxX = -Infinity, maxY = 0;
    positions.forEach((pos) => {
      minX = Math.min(minX, pos.x);
      maxX = Math.max(maxX, pos.x + pos.width);
      maxY = Math.max(maxY, pos.y + this.config.nodeHeight);
    });

    const padding = 20;
    const svgWidth = maxX - minX + padding * 2;
    const svgHeight = maxY + padding * 2;
    const offsetX = -minX + padding;
    const offsetY = padding;

    // Create SVG
    this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    this.svg.setAttribute('width', String(svgWidth));
    this.svg.setAttribute('height', String(svgHeight));
    this.svg.style.display = 'block';

    // Create groups for layering (edges below nodes)
    const edgesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const nodesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    this.svg.appendChild(edgesGroup);
    this.svg.appendChild(nodesGroup);

    // Render tree recursively
    this.renderNodeRecursive(data.root, positions, offsetX, offsetY, edgesGroup, nodesGroup);

    this.container.appendChild(this.svg);
  }

  private renderNodeRecursive(
    node: SerializableGoalNode,
    positions: Map<string, NodePosition>,
    offsetX: number,
    offsetY: number,
    edgesGroup: SVGGElement,
    nodesGroup: SVGGElement
  ): void {
    const pos = positions.get(node.goal.id);
    if (!pos) return;

    const x = pos.x + offsetX;
    const y = pos.y + offsetY;

    // Render edges to children first
    for (const child of node.children) {
      const childPos = positions.get(child.goal.id);
      if (childPos) {
        const childX = childPos.x + offsetX;
        const childY = childPos.y + offsetY;
        this.renderEdge(edgesGroup, x, y, childX, childY, node.appliedTactic);
      }
    }

    // Render self-loop for completed leaf nodes
    if (node.completedBy && node.children.length === 0) {
      this.renderSelfLoop(edgesGroup, x, y, node.completedBy);
    }

    // Render this node
    this.renderNode(nodesGroup, node.goal, x, y);

    // Render children
    for (const child of node.children) {
      this.renderNodeRecursive(child, positions, offsetX, offsetY, edgesGroup, nodesGroup);
    }
  }

  private renderNode(parent: SVGGElement, goal: SerializableGoal, x: number, y: number): void {
    const { nodeWidth, nodeHeight, colors } = this.config;

    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.setAttribute('class', 'goal-node');
    group.setAttribute('data-goal-id', goal.id);
    group.style.cursor = 'pointer';

    // Determine color based on state
    let strokeColor = colors.pending;
    let fillOpacity = '0.1';
    if (goal.isCurrent) {
      strokeColor = colors.current;
      fillOpacity = '0.2';
    } else if (goal.isComplete) {
      strokeColor = colors.completed;
      fillOpacity = '0.15';
    }

    // Background rect
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', String(x));
    rect.setAttribute('y', String(y));
    rect.setAttribute('width', String(nodeWidth));
    rect.setAttribute('height', String(nodeHeight));
    rect.setAttribute('rx', '8');
    rect.setAttribute('ry', '8');
    rect.setAttribute('fill', strokeColor);
    rect.setAttribute('fill-opacity', fillOpacity);
    rect.setAttribute('stroke', strokeColor);
    rect.setAttribute('stroke-width', goal.isCurrent ? '3' : '2');
    group.appendChild(rect);

    // Goal ID label
    const idText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    idText.setAttribute('x', String(x + 10));
    idText.setAttribute('y', String(y + 18));
    idText.setAttribute('fill', strokeColor);
    idText.setAttribute('font-size', '11');
    idText.setAttribute('font-family', 'monospace');
    idText.textContent = goal.id;
    group.appendChild(idText);

    // Status indicator
    const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    statusText.setAttribute('x', String(x + nodeWidth - 10));
    statusText.setAttribute('y', String(y + 18));
    statusText.setAttribute('text-anchor', 'end');
    statusText.setAttribute('fill', strokeColor);
    statusText.setAttribute('font-size', '12');
    console.log(`Goal ${goal.id}: isComplete=${goal.isComplete}, isCurrent=${goal.isCurrent}`);
    if (goal.isComplete) {
      statusText.textContent = '\u2713'; // checkmark
    } else if (goal.isCurrent) {
      statusText.textContent = '\u2192'; // arrow for current/ongoing goal
    } else {
      statusText.textContent = '\u25CB'; // empty circle for pending
    }
    group.appendChild(statusText);

    // Goal type (truncated)
    const typeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    typeText.setAttribute('x', String(x + 10));
    typeText.setAttribute('y', String(y + 40));
    typeText.setAttribute('fill', '#e2e8f0');
    typeText.setAttribute('font-size', '12');
    typeText.setAttribute('font-family', 'monospace');
    const truncatedType = this.truncateText(goal.type, nodeWidth - 20);
    typeText.textContent = truncatedType;
    group.appendChild(typeText);

    // Click handler
    group.addEventListener('click', () => {
      if (this.onGoalSelect) {
        this.onGoalSelect(goal);
      }
    });

    // Hover effect
    group.addEventListener('mouseenter', () => {
      rect.setAttribute('fill-opacity', String(parseFloat(fillOpacity) + 0.1));
    });
    group.addEventListener('mouseleave', () => {
      rect.setAttribute('fill-opacity', fillOpacity);
    });

    parent.appendChild(group);
  }

  private renderEdge(
    parent: SVGGElement,
    fromX: number,
    fromY: number,
    toX: number,
    toY: number,
    tactic?: string
  ): void {
    const { nodeWidth, nodeHeight, colors } = this.config;

    // Calculate connection points (bottom of parent, top of child)
    const startX = fromX + nodeWidth / 2;
    const startY = fromY + nodeHeight;
    const endX = toX + nodeWidth / 2;
    const endY = toY;

    // Draw edge line
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const midY = (startY + endY) / 2;
    const d = `M ${startX} ${startY} C ${startX} ${midY}, ${endX} ${midY}, ${endX} ${endY}`;
    line.setAttribute('d', d);
    line.setAttribute('fill', 'none');
    line.setAttribute('stroke', colors.edge);
    line.setAttribute('stroke-width', '2');
    parent.appendChild(line);

    // Add tactic label if present
    if (tactic) {
      const labelX = (startX + endX) / 2;
      const labelY = midY;

      // Background for label
      const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      const labelText = this.truncateText(tactic, 100);
      const labelWidth = Math.min(labelText.length * 7 + 10, 110);
      labelBg.setAttribute('x', String(labelX - labelWidth / 2));
      labelBg.setAttribute('y', String(labelY - 10));
      labelBg.setAttribute('width', String(labelWidth));
      labelBg.setAttribute('height', '20');
      labelBg.setAttribute('rx', '4');
      labelBg.setAttribute('fill', colors.background);
      labelBg.setAttribute('fill-opacity', '0.9');
      parent.appendChild(labelBg);

      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', String(labelX));
      text.setAttribute('y', String(labelY + 4));
      text.setAttribute('text-anchor', 'middle');
      text.setAttribute('fill', colors.tacticLabel);
      text.setAttribute('font-size', '11');
      text.setAttribute('font-family', 'monospace');
      text.textContent = labelText;
      parent.appendChild(text);
    }
  }

  private renderSelfLoop(
    parent: SVGGElement,
    x: number,
    y: number,
    tactic: string
  ): void {
    const { nodeWidth, nodeHeight, colors } = this.config;

    // Draw a curved arrow that loops back to the same node (below the node)
    const centerX = x + nodeWidth / 2;
    const bottomY = y + nodeHeight;
    const loopHeight = 35;
    const loopWidth = 50;

    // Create curved path for self-loop
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const d = `M ${centerX - 15} ${bottomY}
               C ${centerX - loopWidth} ${bottomY + loopHeight},
                 ${centerX + loopWidth} ${bottomY + loopHeight},
                 ${centerX + 15} ${bottomY}`;
    path.setAttribute('d', d);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', colors.completed);
    path.setAttribute('stroke-width', '2');
    parent.appendChild(path);

    // Add arrowhead
    const arrowSize = 6;
    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    const arrowX = centerX + 15;
    const arrowY = bottomY;
    arrow.setAttribute('points',
      `${arrowX},${arrowY} ${arrowX + arrowSize},${arrowY + arrowSize} ${arrowX - arrowSize},${arrowY + arrowSize}`
    );
    arrow.setAttribute('fill', colors.completed);
    parent.appendChild(arrow);

    // Add tactic label below the loop
    const labelY = bottomY + loopHeight + 5;
    const labelText = this.truncateText(tactic, 120);
    const labelWidth = Math.min(labelText.length * 6.5 + 12, 130);

    // Background for label
    const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    labelBg.setAttribute('x', String(centerX - labelWidth / 2));
    labelBg.setAttribute('y', String(labelY - 10));
    labelBg.setAttribute('width', String(labelWidth));
    labelBg.setAttribute('height', '18');
    labelBg.setAttribute('rx', '4');
    labelBg.setAttribute('fill', colors.background);
    labelBg.setAttribute('fill-opacity', '0.9');
    parent.appendChild(labelBg);

    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    text.setAttribute('x', String(centerX));
    text.setAttribute('y', String(labelY + 3));
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('fill', colors.completed);
    text.setAttribute('font-size', '10');
    text.setAttribute('font-family', 'monospace');
    text.textContent = labelText;
    parent.appendChild(text);
  }

  private calculateLayout(root: SerializableGoalNode): Map<string, NodePosition> {
    const positions = new Map<string, NodePosition>();

    // First pass: calculate subtree widths
    const widths = new Map<string, number>();
    this.calculateSubtreeWidths(root, widths);

    // Second pass: assign positions
    this.assignPositions(root, 0, 0, widths, positions);

    return positions;
  }

  private calculateSubtreeWidths(node: SerializableGoalNode, widths: Map<string, number>): number {
    const { nodeWidth, horizontalSpacing } = this.config;

    if (node.children.length === 0) {
      widths.set(node.goal.id, nodeWidth);
      return nodeWidth;
    }

    let totalChildWidth = 0;
    for (const child of node.children) {
      totalChildWidth += this.calculateSubtreeWidths(child, widths);
    }
    totalChildWidth += (node.children.length - 1) * horizontalSpacing;

    const width = Math.max(nodeWidth, totalChildWidth);
    widths.set(node.goal.id, width);
    return width;
  }

  private assignPositions(
    node: SerializableGoalNode,
    x: number,
    y: number,
    widths: Map<string, number>,
    positions: Map<string, NodePosition>
  ): void {
    const { nodeWidth, nodeHeight, horizontalSpacing, verticalSpacing } = this.config;
    const subtreeWidth = widths.get(node.goal.id) || nodeWidth;

    // Center this node in its subtree
    const nodeX = x + (subtreeWidth - nodeWidth) / 2;
    positions.set(node.goal.id, { x: nodeX, y, width: nodeWidth });

    // Position children
    if (node.children.length > 0) {
      const childY = y + nodeHeight + verticalSpacing;
      let childX = x;

      for (const child of node.children) {
        const childWidth = widths.get(child.goal.id) || nodeWidth;
        this.assignPositions(child, childX, childY, widths, positions);
        childX += childWidth + horizontalSpacing;
      }
    }
  }

  private truncateText(text: string, maxWidth: number): string {
    // Rough estimate: 7px per character
    const maxChars = Math.floor(maxWidth / 7);
    if (text.length <= maxChars) return text;
    return text.substring(0, maxChars - 3) + '...';
  }

  clear(): void {
    if (this.svg && this.svg.parentNode) {
      this.svg.parentNode.removeChild(this.svg);
    }
    this.svg = null;
  }

  highlightGoal(goalId: string): void {
    if (!this.svg) return;

    // Remove previous highlights
    const nodes = this.svg.querySelectorAll('.goal-node');
    nodes.forEach(node => {
      node.classList.remove('highlighted');
    });

    // Add highlight to target
    const target = this.svg.querySelector(`[data-goal-id="${goalId}"]`);
    if (target) {
      target.classList.add('highlighted');
    }
  }
}
</file>

<file path="web/proof-tree/SExpressionParser.ts">
/**
 * S-expression tokenizer and parser for type visualization.
 * Parses Pie type strings into a tree structure for rendering.
 */

import { TypeNode, TypeConstructorCategory } from './types';

// Token types
type Token =
  | { type: 'LPAREN' }
  | { type: 'RPAREN' }
  | { type: 'ATOM'; value: string }
  | { type: 'EOF' };

/**
 * Tokenize an S-expression string.
 */
export function tokenize(input: string): Token[] {
  const tokens: Token[] = [];
  let i = 0;

  while (i < input.length) {
    const char = input[i];

    // Skip whitespace
    if (/\s/.test(char)) {
      i++;
      continue;
    }

    // Left parenthesis
    if (char === '(') {
      tokens.push({ type: 'LPAREN' });
      i++;
      continue;
    }

    // Right parenthesis
    if (char === ')') {
      tokens.push({ type: 'RPAREN' });
      i++;
      continue;
    }

    // Atom: read until whitespace or parenthesis
    let atom = '';
    while (i < input.length && !/[\s()]/.test(input[i])) {
      atom += input[i];
      i++;
    }
    if (atom) {
      tokens.push({ type: 'ATOM', value: atom });
    }
  }

  tokens.push({ type: 'EOF' });
  return tokens;
}

/**
 * Parser class for recursive descent parsing.
 */
class Parser {
  private tokens: Token[];
  private pos: number = 0;

  constructor(tokens: Token[]) {
    this.tokens = tokens;
  }

  private current(): Token {
    return this.tokens[this.pos] || { type: 'EOF' };
  }

  private advance(): Token {
    const token = this.current();
    this.pos++;
    return token;
  }

  private expect(type: Token['type']): Token {
    const token = this.current();
    if (token.type !== type) {
      throw new Error(`Expected ${type} but got ${token.type}`);
    }
    return this.advance();
  }

  /**
   * Parse a single expression (atom or list).
   */
  parse(): TypeNode {
    const token = this.current();

    if (token.type === 'LPAREN') {
      return this.parseList();
    } else if (token.type === 'ATOM') {
      return this.parseAtom();
    } else if (token.type === 'EOF') {
      // Empty input
      return {
        kind: '',
        value: '',
        children: [],
        isAtom: true,
        sourceText: '',
        abbreviation: ''
      };
    } else {
      throw new Error(`Unexpected token: ${token.type}`);
    }
  }

  private parseAtom(): TypeNode {
    const token = this.expect('ATOM') as { type: 'ATOM'; value: string };
    return {
      kind: token.value,
      value: token.value,
      children: [],
      isAtom: true,
      sourceText: token.value,
      abbreviation: token.value
    };
  }

  private parseList(): TypeNode {
    this.expect('LPAREN');

    const children: TypeNode[] = [];
    const sourceTokens: string[] = ['('];

    // Parse all elements until closing paren
    while (this.current().type !== 'RPAREN' && this.current().type !== 'EOF') {
      const child = this.parse();
      children.push(child);
      sourceTokens.push(child.sourceText);
    }

    this.expect('RPAREN');
    sourceTokens.push(')');

    // Determine the kind from the first child (if it's an atom)
    const kind = children.length > 0 && children[0].isAtom
      ? children[0].kind
      : 'list';

    const sourceText = sourceTokens.join(' ').replace(/\( /g, '(').replace(/ \)/g, ')');
    const abbreviation = generateAbbreviation({ kind, children, isAtom: false, sourceText, abbreviation: '' });

    return {
      kind,
      children,
      isAtom: false,
      sourceText,
      abbreviation
    };
  }
}

/**
 * Parse an S-expression string into a TypeNode tree.
 */
export function parseSExpression(input: string): TypeNode {
  const trimmed = input.trim();
  if (!trimmed) {
    return {
      kind: '',
      value: '',
      children: [],
      isAtom: true,
      sourceText: '',
      abbreviation: ''
    };
  }

  try {
    const tokens = tokenize(trimmed);
    const parser = new Parser(tokens);
    return parser.parse();
  } catch (e) {
    // Fallback: return the input as a single atom on parse error
    return {
      kind: 'error',
      value: trimmed,
      children: [],
      isAtom: true,
      sourceText: trimmed,
      abbreviation: trimmed.length > 20 ? trimmed.slice(0, 20) + '...' : trimmed
    };
  }
}

/**
 * Generate an abbreviated representation for collapsed display.
 */
export function generateAbbreviation(node: TypeNode): string {
  if (node.isAtom) {
    return node.value || '';
  }

  const kind = node.kind;
  const children = node.children;

  // Handle different type constructors
  switch (kind) {
    case 'Π':
    case 'Pi': {
      // (Π (x A) B) -> "Π (x : A) ..."
      if (children.length >= 3) {
        const binding = children[1];
        if (!binding.isAtom && binding.children.length >= 2) {
          const varName = binding.children[0].abbreviation;
          const varType = binding.children[1].abbreviation;
          return `Π (${varName} : ${varType}) ...`;
        }
      }
      return 'Π ...';
    }

    case 'Σ':
    case 'Sigma': {
      // (Σ (x A) B) -> "Σ (x : A) ..."
      if (children.length >= 3) {
        const binding = children[1];
        if (!binding.isAtom && binding.children.length >= 2) {
          const varName = binding.children[0].abbreviation;
          const varType = binding.children[1].abbreviation;
          return `Σ (${varName} : ${varType}) ...`;
        }
      }
      return 'Σ ...';
    }

    case 'Either': {
      // (Either A B) -> "Either A B"
      if (children.length >= 3) {
        return `Either ${children[1].abbreviation} ${children[2].abbreviation}`;
      }
      return 'Either ...';
    }

    case 'left':
    case 'Left': {
      if (children.length >= 2) {
        return `left ${children[1].abbreviation}`;
      }
      return 'left ...';
    }

    case 'right':
    case 'Right': {
      if (children.length >= 2) {
        return `right ${children[1].abbreviation}`;
      }
      return 'right ...';
    }

    case '=': {
      // (= A from to) -> "= A from to"
      if (children.length >= 4) {
        return `= ${children[1].abbreviation} ...`;
      }
      return '= ...';
    }

    case 'λ':
    case 'lambda': {
      // (λ (x) body) -> "λ (x) ..."
      if (children.length >= 3) {
        const param = children[1];
        if (!param.isAtom && param.children.length >= 1) {
          return `λ (${param.children[0].abbreviation}) ...`;
        }
      }
      return 'λ ...';
    }

    case 'List': {
      if (children.length >= 2) {
        return `List ${children[1].abbreviation}`;
      }
      return 'List ...';
    }

    case 'Vec': {
      if (children.length >= 3) {
        return `Vec ${children[1].abbreviation} ${children[2].abbreviation}`;
      }
      return 'Vec ...';
    }

    case 'Pair': {
      if (children.length >= 3) {
        return `Pair ${children[1].abbreviation} ${children[2].abbreviation}`;
      }
      return 'Pair ...';
    }

    case 'cons':
    case '::': {
      return `:: ...`;
    }

    case 'add1': {
      if (children.length >= 2) {
        return `add1 ${children[1].abbreviation}`;
      }
      return 'add1 ...';
    }

    default: {
      // Generic abbreviation
      if (children.length > 0) {
        const kindPart = children[0].isAtom ? children[0].abbreviation : '?';
        if (children.length === 1) {
          return `(${kindPart})`;
        }
        return `(${kindPart} ...)`;
      }
      return '(...)';
    }
  }
}

/**
 * Get the category for a type constructor (for color coding).
 */
export function getTypeCategory(kind: string): TypeConstructorCategory {
  const lowerKind = kind.toLowerCase();

  // Pi types
  if (kind === 'Π' || kind === 'Pi' || kind === '→' || kind === '->') {
    return 'pi';
  }

  // Sigma types
  if (kind === 'Σ' || kind === 'Sigma') {
    return 'sigma';
  }

  // Either and variants
  if (lowerKind === 'either' || lowerKind === 'left' || lowerKind === 'right') {
    return 'either';
  }

  // Equality types
  if (kind === '=' || lowerKind === 'same' || lowerKind === 'cong' ||
      lowerKind === 'symm' || lowerKind === 'trans' || lowerKind === 'replace') {
    return 'equality';
  }

  // List types
  if (lowerKind === 'list' || kind === '::' || lowerKind === 'nil' || lowerKind === 'cons') {
    return 'list';
  }

  // Vector types
  if (lowerKind === 'vec' || lowerKind === 'vec::' || lowerKind === 'vecnil' || lowerKind === 'head' || lowerKind === 'tail') {
    return 'vec';
  }

  // Natural numbers
  if (lowerKind === 'nat' || lowerKind === 'zero' || lowerKind === 'add1') {
    return 'nat';
  }

  // Universe types
  if (kind === 'U' || lowerKind === 'atom' || lowerKind === 'trivial' || lowerKind === 'absurd' || lowerKind === 'sole') {
    return 'universe';
  }

  // Lambda
  if (kind === 'λ' || lowerKind === 'lambda') {
    return 'lambda';
  }

  // Check if it looks like a variable (starts with lowercase, short)
  if (/^[a-z][a-z0-9_-]*$/i.test(kind) && kind.length <= 10 && kind === kind.toLowerCase()) {
    return 'variable';
  }

  return 'default';
}
</file>

<file path="web/proof-tree/types.ts">
/**
 * Serializable types for proof tree visualization.
 * These types can be safely passed between workers and the main thread.
 */

export interface ContextEntry {
  name: string;
  type: string;  // Pretty-printed type
}

export interface SerializableGoal {
  id: string;
  type: string;           // Pretty-printed goal type
  contextEntries: ContextEntry[];
  isComplete: boolean;
  isCurrent: boolean;
}

export interface SerializableGoalNode {
  goal: SerializableGoal;
  children: SerializableGoalNode[];
  appliedTactic?: string;  // Tactic that was applied to create children
  completedBy?: string;    // Tactic that directly solved this leaf goal
}

export interface ProofTreeData {
  root: SerializableGoalNode;
  isComplete: boolean;
  currentGoalId: string | null;
}

/**
 * Parsed S-expression node for type visualization.
 */
export interface TypeNode {
  kind: string;           // "Π", "Σ", "Either", "Nat", etc.
  value?: string;         // For atoms
  children: TypeNode[];
  isAtom: boolean;
  sourceText: string;     // Original text
  abbreviation: string;   // Collapsed display
}

/**
 * Categories for color-coding type constructors.
 */
export type TypeConstructorCategory =
  | 'pi'        // Π, →
  | 'sigma'     // Σ
  | 'either'    // Either, Left, Right
  | 'equality'  // =, same, cong, symm
  | 'list'      // List, ::, nil
  | 'vec'       // Vec, vec::, vecnil
  | 'nat'       // Nat, zero, add1
  | 'universe'  // U, Atom, Trivial
  | 'lambda'    // λ
  | 'variable'  // Variables
  | 'default';  // Fallback
</file>

<file path="web/app.bundle.js">
class e{constructor(e,t){this.worker=null,this.disposables=[],this.debouncedValidate=null,this.diagnostics=[],this.monaco=e,this.editor=t}async start(){this.worker=new Worker(new URL("./pie-lsp-worker-bundle.js",import.meta.url),{type:"module"}),this.worker.onmessage=e=>{this.handleWorkerMessage(e.data)},this.worker.onerror=e=>{console.error("LSP Worker error:",e)};const e=this.editor?.getModel?.();if(!e)return;this.debouncedValidate=this.debounce(()=>{if(!this.worker)return;const t=e.getValue();this.worker.postMessage({type:"validate",source:t})},220);const t=this.editor?.onDidChangeModelContent?.(()=>{this.debouncedValidate&&this.debouncedValidate()});t&&this.disposables.push(t);const n=this.monaco.languages.registerHoverProvider("pie",{provideHover:(e,t)=>this.provideHover(e,t)});this.disposables.push(n);const i=this.monaco.languages.registerCompletionItemProvider("pie",{provideCompletionItems:(e,t)=>this.provideCompletionItems(e,t)});this.disposables.push(i);const o=this.monaco.languages.registerDefinitionProvider("pie",{provideDefinition:(e,t)=>this.provideDefinition(e,t)});this.disposables.push(o),this.debouncedValidate&&this.debouncedValidate()}async stop(){this.clearMarkers(),this.disposables.forEach(e=>{e&&"function"==typeof e.dispose&&e.dispose()}),this.disposables=[],this.debouncedValidate=null,this.diagnostics=[],this.worker&&(this.worker.terminate(),this.worker=null)}isRunning(){return null!==this.worker}handleWorkerMessage(e){e&&("validation-result"===e.type?this.updateDiagnostics(e.diagnostics??[]):"validation-error"===e.type&&this.updateDiagnostics([{severity:"error",startLine:1,startColumn:1,endLine:1,endColumn:2,message:e.error}]))}updateDiagnostics(e){this.diagnostics=e;const t=this.editor?.getModel?.();if(!t)return;const n=e.map(e=>{const t=this.ensurePositiveNumber(e.startLine,1),n=this.ensurePositiveNumber(e.endLine,t),i=this.ensurePositiveNumber(e.startColumn,1);return{startLineNumber:t,startColumn:i,endLineNumber:n,endColumn:this.ensurePositiveNumber(e.endColumn,i+1),message:e.message,severity:"warning"===e.severity?this.monaco.MarkerSeverity.Warning:this.monaco.MarkerSeverity.Error}});this.monaco.editor.setModelMarkers(t,"pie-lsp",n)}async provideHover(e,t){if(!this.worker)return null;const n=this.diagnostics.find(e=>{const n=this.ensurePositiveNumber(e.startLine,t.lineNumber),i=this.ensurePositiveNumber(e.endLine,n),o=this.ensurePositiveNumber(e.startColumn,1),r=this.ensurePositiveNumber(e.endColumn,o+1);return!(t.lineNumber<n||t.lineNumber>i)&&(!(t.lineNumber===n&&t.column<o)&&!(t.lineNumber===i&&t.column>r))});if(n){const e=this.ensurePositiveNumber(n.startLine,t.lineNumber),i=this.ensurePositiveNumber(n.endLine,e),o=this.ensurePositiveNumber(n.startColumn,1),r=this.ensurePositiveNumber(n.endColumn,o+1);return{contents:[{value:`**${"warning"===n.severity?"Warning":"Error"}**\n\n${n.message}`}],range:{startLineNumber:e,startColumn:o,endLineNumber:i,endColumn:r}}}return new Promise(n=>{const i=e=>{const t=e.data;if("hover-result"===t.type){if(this.worker?.removeEventListener("message",i),!t.hoverInfo)return void n(null);const e=t.hoverInfo;let o=`**${e.title}**\n\n${e.summary}`;e.details&&(o+=`\n\n${e.details}`),e.examples&&(o+=`\n\n**Examples:**\n\`\`\`pie\n${e.examples}\n\`\`\``),n({contents:[{value:o}]})}};if(this.worker){this.worker.addEventListener("message",i);const n=e.getValue();this.worker.postMessage({type:"hover",source:n,line:t.lineNumber-1,column:t.column-1})}setTimeout(()=>{this.worker?.removeEventListener("message",i),n(null)},1e3)})}async provideCompletionItems(e,t){return this.worker?new Promise(n=>{const i=e=>{const o=e.data;if("completion-result"===o.type){this.worker?.removeEventListener("message",i);const e=o.wordRange,r=e?{startLineNumber:t.lineNumber,startColumn:e.start+1,endLineNumber:t.lineNumber,endColumn:e.end+1}:{startLineNumber:t.lineNumber,startColumn:t.column,endLineNumber:t.lineNumber,endColumn:t.column},s=o.completions.map(e=>{let t=this.monaco.languages.CompletionItemKind.Text;switch(e.kind){case"Keyword":t=this.monaco.languages.CompletionItemKind.Keyword;break;case"Function":t=this.monaco.languages.CompletionItemKind.Function;break;case"Variable":t=this.monaco.languages.CompletionItemKind.Variable;break;case"TypeParameter":t=this.monaco.languages.CompletionItemKind.Class;break;case"Value":t=this.monaco.languages.CompletionItemKind.Value;break;case"Snippet":t=this.monaco.languages.CompletionItemKind.Snippet}return{label:e.label,kind:t,detail:e.detail,insertText:e.label,range:r}});n({suggestions:s})}};if(this.worker){this.worker.addEventListener("message",i);const n=e.getValue();this.worker.postMessage({type:"completion",source:n,line:t.lineNumber-1,column:t.column-1})}setTimeout(()=>{this.worker?.removeEventListener("message",i),n({suggestions:[]})},1e3)}):{suggestions:[]}}async provideDefinition(e,t){return this.worker?new Promise(n=>{const i=t=>{const o=t.data;"definition-result"===o.type&&(this.worker?.removeEventListener("message",i),o.location?n({uri:e.uri,range:{startLineNumber:o.location.line+1,startColumn:o.location.startColumn+1,endLineNumber:o.location.line+1,endColumn:o.location.endColumn+1}}):n(null))};if(this.worker){this.worker.addEventListener("message",i);const n=e.getValue();this.worker.postMessage({type:"definition",source:n,line:t.lineNumber-1,column:t.column-1})}setTimeout(()=>{this.worker?.removeEventListener("message",i),n(null)},1e3)}):null}clearMarkers(){const e=this.editor?.getModel?.();e&&this.monaco.editor.setModelMarkers(e,"pie-lsp",[])}ensurePositiveNumber(e,t){return"number"!=typeof e||Number.isNaN(e)||e<1?t:e}debounce(e,t){let n=null;return()=>{null!==n&&window.clearTimeout(n),n=window.setTimeout(()=>{n=null,e()},t)}}}const t={nodeWidth:180,nodeHeight:60,horizontalSpacing:40,verticalSpacing:80,colors:{current:"#f59e0b",completed:"#34d399",pending:"#64748b",edge:"#475569",tacticLabel:"#94a3b8",background:"#0f172a"}};class n{constructor(e,n){this.svg=null,this.onGoalSelect=null,this.currentData=null,this.container=e,this.config={...t,...n}}setOnGoalSelect(e){this.onGoalSelect=e}render(e){this.currentData=e,this.clear();const t=this.calculateLayout(e.root);let n=1/0,i=-1/0,o=0;t.forEach(e=>{n=Math.min(n,e.x),i=Math.max(i,e.x+e.width),o=Math.max(o,e.y+this.config.nodeHeight)});const r=i-n+40,s=o+40,a=20-n;this.svg=document.createElementNS("http://www.w3.org/2000/svg","svg"),this.svg.setAttribute("width",String(r)),this.svg.setAttribute("height",String(s)),this.svg.style.display="block";const d=document.createElementNS("http://www.w3.org/2000/svg","g"),l=document.createElementNS("http://www.w3.org/2000/svg","g");this.svg.appendChild(d),this.svg.appendChild(l),this.renderNodeRecursive(e.root,t,a,20,d,l),this.container.appendChild(this.svg)}renderNodeRecursive(e,t,n,i,o,r){const s=t.get(e.goal.id);if(!s)return;const a=s.x+n,d=s.y+i;for(const r of e.children){const s=t.get(r.goal.id);if(s){const t=s.x+n,r=s.y+i;this.renderEdge(o,a,d,t,r,e.appliedTactic)}}e.completedBy&&0===e.children.length&&this.renderSelfLoop(o,a,d,e.completedBy),this.renderNode(r,e.goal,a,d);for(const s of e.children)this.renderNodeRecursive(s,t,n,i,o,r)}renderNode(e,t,n,i){const{nodeWidth:o,nodeHeight:r,colors:s}=this.config,a=document.createElementNS("http://www.w3.org/2000/svg","g");a.setAttribute("class","goal-node"),a.setAttribute("data-goal-id",t.id),a.style.cursor="pointer";let d=s.pending,l="0.1";t.isCurrent?(d=s.current,l="0.2"):t.isComplete&&(d=s.completed,l="0.15");const c=document.createElementNS("http://www.w3.org/2000/svg","rect");c.setAttribute("x",String(n)),c.setAttribute("y",String(i)),c.setAttribute("width",String(o)),c.setAttribute("height",String(r)),c.setAttribute("rx","8"),c.setAttribute("ry","8"),c.setAttribute("fill",d),c.setAttribute("fill-opacity",l),c.setAttribute("stroke",d),c.setAttribute("stroke-width",t.isCurrent?"3":"2"),a.appendChild(c);const u=document.createElementNS("http://www.w3.org/2000/svg","text");u.setAttribute("x",String(n+10)),u.setAttribute("y",String(i+18)),u.setAttribute("fill",d),u.setAttribute("font-size","11"),u.setAttribute("font-family","monospace"),u.textContent=t.id,a.appendChild(u);const h=document.createElementNS("http://www.w3.org/2000/svg","text");h.setAttribute("x",String(n+o-10)),h.setAttribute("y",String(i+18)),h.setAttribute("text-anchor","end"),h.setAttribute("fill",d),h.setAttribute("font-size","12"),console.log(`Goal ${t.id}: isComplete=${t.isComplete}, isCurrent=${t.isCurrent}`),t.isComplete?h.textContent="✓":t.isCurrent?h.textContent="→":h.textContent="○",a.appendChild(h);const m=document.createElementNS("http://www.w3.org/2000/svg","text");m.setAttribute("x",String(n+10)),m.setAttribute("y",String(i+40)),m.setAttribute("fill","#e2e8f0"),m.setAttribute("font-size","12"),m.setAttribute("font-family","monospace");const p=this.truncateText(t.type,o-20);m.textContent=p,a.appendChild(m),a.addEventListener("click",()=>{this.onGoalSelect&&this.onGoalSelect(t)}),a.addEventListener("mouseenter",()=>{c.setAttribute("fill-opacity",String(parseFloat(l)+.1))}),a.addEventListener("mouseleave",()=>{c.setAttribute("fill-opacity",l)}),e.appendChild(a)}renderEdge(e,t,n,i,o,r){const{nodeWidth:s,nodeHeight:a,colors:d}=this.config,l=t+s/2,c=n+a,u=i+s/2,h=o,m=document.createElementNS("http://www.w3.org/2000/svg","path"),p=(c+h)/2,g=`M ${l} ${c} C ${l} ${p}, ${u} ${p}, ${u} ${h}`;if(m.setAttribute("d",g),m.setAttribute("fill","none"),m.setAttribute("stroke",d.edge),m.setAttribute("stroke-width","2"),e.appendChild(m),r){const t=(l+u)/2,n=p,i=document.createElementNS("http://www.w3.org/2000/svg","rect"),o=this.truncateText(r,100),s=Math.min(7*o.length+10,110);i.setAttribute("x",String(t-s/2)),i.setAttribute("y",String(n-10)),i.setAttribute("width",String(s)),i.setAttribute("height","20"),i.setAttribute("rx","4"),i.setAttribute("fill",d.background),i.setAttribute("fill-opacity","0.9"),e.appendChild(i);const a=document.createElementNS("http://www.w3.org/2000/svg","text");a.setAttribute("x",String(t)),a.setAttribute("y",String(n+4)),a.setAttribute("text-anchor","middle"),a.setAttribute("fill",d.tacticLabel),a.setAttribute("font-size","11"),a.setAttribute("font-family","monospace"),a.textContent=o,e.appendChild(a)}}renderSelfLoop(e,t,n,i){const{nodeWidth:o,nodeHeight:r,colors:s}=this.config,a=t+o/2,d=n+r,l=document.createElementNS("http://www.w3.org/2000/svg","path"),c=`M ${a-15} ${d}\n               C ${a-50} ${d+35},\n                 ${a+50} ${d+35},\n                 ${a+15} ${d}`;l.setAttribute("d",c),l.setAttribute("fill","none"),l.setAttribute("stroke",s.completed),l.setAttribute("stroke-width","2"),e.appendChild(l);const u=document.createElementNS("http://www.w3.org/2000/svg","polygon"),h=a+15,m=d;u.setAttribute("points",`${h},${m} ${h+6},${m+6} ${h-6},${m+6}`),u.setAttribute("fill",s.completed),e.appendChild(u);const p=d+35+5,g=this.truncateText(i,120),v=Math.min(6.5*g.length+12,130),b=document.createElementNS("http://www.w3.org/2000/svg","rect");b.setAttribute("x",String(a-v/2)),b.setAttribute("y",String(p-10)),b.setAttribute("width",String(v)),b.setAttribute("height","18"),b.setAttribute("rx","4"),b.setAttribute("fill",s.background),b.setAttribute("fill-opacity","0.9"),e.appendChild(b);const f=document.createElementNS("http://www.w3.org/2000/svg","text");f.setAttribute("x",String(a)),f.setAttribute("y",String(p+3)),f.setAttribute("text-anchor","middle"),f.setAttribute("fill",s.completed),f.setAttribute("font-size","10"),f.setAttribute("font-family","monospace"),f.textContent=g,e.appendChild(f)}calculateLayout(e){const t=new Map,n=new Map;return this.calculateSubtreeWidths(e,n),this.assignPositions(e,0,0,n,t),t}calculateSubtreeWidths(e,t){const{nodeWidth:n,horizontalSpacing:i}=this.config;if(0===e.children.length)return t.set(e.goal.id,n),n;let o=0;for(const n of e.children)o+=this.calculateSubtreeWidths(n,t);o+=(e.children.length-1)*i;const r=Math.max(n,o);return t.set(e.goal.id,r),r}assignPositions(e,t,n,i,o){const{nodeWidth:r,nodeHeight:s,horizontalSpacing:a,verticalSpacing:d}=this.config,l=t+((i.get(e.goal.id)||r)-r)/2;if(o.set(e.goal.id,{x:l,y:n,width:r}),e.children.length>0){const l=n+s+d;let c=t;for(const t of e.children){const e=i.get(t.goal.id)||r;this.assignPositions(t,c,l,i,o),c+=e+a}}}truncateText(e,t){const n=Math.floor(t/7);return e.length<=n?e:e.substring(0,n-3)+"..."}clear(){this.svg&&this.svg.parentNode&&this.svg.parentNode.removeChild(this.svg),this.svg=null}highlightGoal(e){if(!this.svg)return;this.svg.querySelectorAll(".goal-node").forEach(e=>{e.classList.remove("highlighted")});const t=this.svg.querySelector(`[data-goal-id="${e}"]`);t&&t.classList.add("highlighted")}}class i{constructor(e){this.currentGoal=null,this.container=e,this.clear()}display(e){this.currentGoal=e,this.container.innerHTML="";const t=document.createElement("div");t.className="panel-header";const n=document.createElement("div");n.className="panel-label",n.textContent="Context",t.appendChild(n),this.container.appendChild(t);const i=document.createElement("div");if(i.className="panel-content",e.contextEntries.length>0){const t=document.createElement("div");t.className="context-list";for(const n of e.contextEntries){const e=document.createElement("div");e.className="context-entry";const i=document.createElement("span");i.className="context-entry-name",i.textContent=n.name,e.appendChild(i);const o=document.createElement("span");o.className="context-entry-colon",o.textContent=" : ",e.appendChild(o);const r=document.createElement("span");r.className="context-entry-type",r.textContent=n.type,e.appendChild(r),t.appendChild(e)}i.appendChild(t)}else{const e=document.createElement("div");e.className="panel-empty",e.textContent="(empty)",i.appendChild(e)}this.container.appendChild(i)}clear(){this.currentGoal=null,this.container.innerHTML='\n      <div class="panel-placeholder">\n        Select a goal\n      </div>\n    '}getCurrentGoal(){return this.currentGoal}}class o{constructor(e){this.pos=0,this.tokens=e}current(){return this.tokens[this.pos]||{type:"EOF"}}advance(){const e=this.current();return this.pos++,e}expect(e){const t=this.current();if(t.type!==e)throw new Error(`Expected ${e} but got ${t.type}`);return this.advance()}parse(){const e=this.current();if("LPAREN"===e.type)return this.parseList();if("ATOM"===e.type)return this.parseAtom();if("EOF"===e.type)return{kind:"",value:"",children:[],isAtom:!0,sourceText:"",abbreviation:""};throw new Error(`Unexpected token: ${e.type}`)}parseAtom(){const e=this.expect("ATOM");return{kind:e.value,value:e.value,children:[],isAtom:!0,sourceText:e.value,abbreviation:e.value}}parseList(){this.expect("LPAREN");const e=[],t=["("];for(;"RPAREN"!==this.current().type&&"EOF"!==this.current().type;){const n=this.parse();e.push(n),t.push(n.sourceText)}this.expect("RPAREN"),t.push(")");const n=e.length>0&&e[0].isAtom?e[0].kind:"list",i=t.join(" ").replace(/\( /g,"(").replace(/ \)/g,")"),o=function(e){const t=e.kind,n=e.children;switch(t){case"Π":case"Pi":if(n.length>=3){const e=n[1];if(!e.isAtom&&e.children.length>=2){return`Π (${e.children[0].abbreviation} : ${e.children[1].abbreviation}) ...`}}return"Π ...";case"Σ":case"Sigma":if(n.length>=3){const e=n[1];if(!e.isAtom&&e.children.length>=2){return`Σ (${e.children[0].abbreviation} : ${e.children[1].abbreviation}) ...`}}return"Σ ...";case"Either":return n.length>=3?`Either ${n[1].abbreviation} ${n[2].abbreviation}`:"Either ...";case"left":case"Left":return n.length>=2?`left ${n[1].abbreviation}`:"left ...";case"right":case"Right":return n.length>=2?`right ${n[1].abbreviation}`:"right ...";case"=":return n.length>=4?`= ${n[1].abbreviation} ...`:"= ...";case"λ":case"lambda":if(n.length>=3){const e=n[1];if(!e.isAtom&&e.children.length>=1)return`λ (${e.children[0].abbreviation}) ...`}return"λ ...";case"List":return n.length>=2?`List ${n[1].abbreviation}`:"List ...";case"Vec":return n.length>=3?`Vec ${n[1].abbreviation} ${n[2].abbreviation}`:"Vec ...";case"Pair":return n.length>=3?`Pair ${n[1].abbreviation} ${n[2].abbreviation}`:"Pair ...";case"cons":case"::":return":: ...";case"add1":return n.length>=2?`add1 ${n[1].abbreviation}`:"add1 ...";default:if(n.length>0){const e=n[0].isAtom?n[0].abbreviation:"?";return 1===n.length?`(${e})`:`(${e} ...)`}return"(...)"}}({kind:n,children:e});return{kind:n,children:e,isAtom:!1,sourceText:i,abbreviation:o}}}function r(e){const t=e.toLowerCase();return"Π"===e||"Pi"===e||"→"===e||"->"===e?"pi":"Σ"===e||"Sigma"===e?"sigma":"either"===t||"left"===t||"right"===t?"either":"="===e||"same"===t||"cong"===t||"symm"===t||"trans"===t||"replace"===t?"equality":"list"===t||"::"===e||"nil"===t||"cons"===t?"list":"vec"===t||"vec::"===t||"vecnil"===t||"head"===t||"tail"===t?"vec":"nat"===t||"zero"===t||"add1"===t?"nat":"U"===e||"atom"===t||"trivial"===t||"absurd"===t||"sole"===t?"universe":"λ"===e||"lambda"===t?"lambda":/^[a-z][a-z0-9_-]*$/i.test(e)&&e.length<=10&&e===e.toLowerCase()?"variable":"default"}class s{constructor(e){this.rootNode=null,this.nodeStates=new Map,this.nodeIdCounter=0,this.container=e,this.container.classList.add("type-tree")}render(e){this.clear(),this.nodeIdCounter=0;const t=e.trim();if(t)try{if(this.rootNode=function(e){const t=e.trim();if(!t)return{kind:"",value:"",children:[],isAtom:!0,sourceText:"",abbreviation:""};try{const e=function(e){const t=[];let n=0;for(;n<e.length;){const i=e[n];if(/\s/.test(i)){n++;continue}if("("===i){t.push({type:"LPAREN"}),n++;continue}if(")"===i){t.push({type:"RPAREN"}),n++;continue}let o="";for(;n<e.length&&!/[\s()]/.test(e[n]);)o+=e[n],n++;o&&t.push({type:"ATOM",value:o})}return t.push({type:"EOF"}),t}(t);return new o(e).parse()}catch(e){return{kind:"error",value:t,children:[],isAtom:!0,sourceText:t,abbreviation:t.length>20?t.slice(0,20)+"...":t}}}(t),"error"===this.rootNode.kind)return void this.showPlainText(t);const e=this.renderNode(this.rootNode,0);this.container.appendChild(e)}catch(e){this.showPlainText(t)}else this.showPlaceholder("No type to display")}clear(){this.container.innerHTML="",this.rootNode=null,this.nodeStates.clear(),this.nodeIdCounter=0}expandAll(){if(this.nodeStates.forEach((e,t)=>this.nodeStates.set(t,!0)),this.rootNode){this.container.innerHTML="";const e=this.renderNode(this.rootNode,0);this.container.appendChild(e)}}collapseAll(){if(this.nodeStates.forEach((e,t)=>this.nodeStates.set(t,!1)),this.rootNode){this.container.innerHTML="";const e=this.renderNode(this.rootNode,0);this.container.appendChild(e)}}showPlaceholder(e){const t=document.createElement("div");t.className="type-tree__placeholder",t.textContent=e,this.container.appendChild(t)}showPlainText(e){const t=document.createElement("pre");t.className="type-tree__fallback",t.textContent=e,this.container.appendChild(t)}renderNode(e,t){const n="n"+this.nodeIdCounter++;this.nodeStates.has(n)||this.nodeStates.set(n,t<3);const i=this.nodeStates.get(n)??!0;return e.isAtom?this.renderAtom(e):this.renderListNode(e,n,t,i)}renderAtom(e){const t=document.createElement("span");t.className="type-node type-node--atom";const n=document.createElement("span"),i=r(e.kind);return n.className=`type-node__kind type-kind--${i}`,n.textContent=e.value||e.kind,t.appendChild(n),t}renderListNode(e,t,n,i){const o=document.createElement("div");o.className="type-node type-node--list",o.dataset.nodeId=t;const s=e.children,a=s.length>0&&s[0].isAtom&&s[0].kind===e.kind?s.slice(1):s,d=a.length>0,l=document.createElement("div");if(l.className="type-node__header",d){const e=document.createElement("span");e.className="type-node__toggle",e.textContent=i?"▼":"▶",e.addEventListener("click",e=>{e.stopPropagation(),this.toggleNode(t)}),l.appendChild(e)}else{const e=document.createElement("span");e.className="type-node__toggle-spacer",l.appendChild(e)}const c=document.createElement("span"),u=r(e.kind);if(c.className=`type-node__kind type-kind--${u}`,c.textContent=e.kind,l.appendChild(c),this.isBindingType(e.kind)&&a.length>=2){const e=a[0];if(!e.isAtom&&e.children.length>=2){const t=document.createElement("span");t.className="type-node__binding";const n=e.children[0].value||e.children[0].kind,i=e.children[1].abbreviation;t.textContent=` (${n} : ${i})`,l.appendChild(t)}else if(!e.isAtom&&1===e.children.length){const t=document.createElement("span");t.className="type-node__binding";const n=e.children[0].value||e.children[0].kind;t.textContent=` (${n})`,l.appendChild(t)}}if(!i&&d){const t=document.createElement("span");t.className="type-node__abbrev",t.textContent=" "+this.getCollapsedHint(e,a),l.appendChild(t)}if(o.appendChild(l),d&&i){const t=document.createElement("div");t.className="type-node__children";const i=this.getChildrenToRender(e,a);for(const e of i){const i=this.renderNode(e,n+1);t.appendChild(i)}o.appendChild(t)}return o}isBindingType(e){return"Π"===e||"Pi"===e||"Σ"===e||"Sigma"===e||"λ"===e||"lambda"===e}getChildrenToRender(e,t){return this.isBindingType(e.kind)&&t.length>=2?t.slice(1):t}getCollapsedHint(e,t){if(0===t.length)return"";if(this.isBindingType(e.kind)&&t.length>=2){const e=t[1];return e.isAtom?e.kind:`→ ${e.kind} ...`}return"..."}toggleNode(e){const t=this.nodeStates.get(e)??!0;if(this.nodeStates.set(e,!t),this.rootNode){this.nodeIdCounter=0,this.container.innerHTML="";const e=this.renderNode(this.rootNode,0);this.container.appendChild(e)}}}class a{constructor(e){this.currentGoal=null,this.goalTypeTree=null,this.container=e,this.clear()}display(e){this.currentGoal=e,this.container.innerHTML="";const t=document.createElement("div");t.className="panel-header";const n=document.createElement("div");n.className="panel-title-row";const i=document.createElement("div");i.className="panel-label",i.textContent="Goal",n.appendChild(i);const o=document.createElement("span");o.className="panel-goal-id",o.textContent=e.id,n.appendChild(o),t.appendChild(n);const r=document.createElement("span");r.className="panel-status",e.isComplete?(r.textContent="Completed",r.classList.add("status-completed")):e.isCurrent?(r.textContent="Ongoing",r.classList.add("status-ongoing")):(r.textContent="Pending",r.classList.add("status-pending")),t.appendChild(r),this.container.appendChild(t);const a=document.createElement("div");a.className="panel-content";const d=document.createElement("div");d.className="goal-type-tree",this.goalTypeTree=new s(d),this.goalTypeTree.render(e.type),a.appendChild(d),this.container.appendChild(a)}clear(){this.currentGoal=null,this.goalTypeTree=null,this.container.innerHTML='\n      <div class="panel-placeholder">\n        Select a goal\n      </div>\n    '}getCurrentGoal(){return this.currentGoal}}const d={"Hello World":"(claim zero Nat)\n(define zero zero)\n\n(claim add1zero Nat)\n(define add1zero (add1 zero))","Natural Number Addition":"(claim +\n  (→ Nat Nat Nat))\n\n(claim step-plus\n  (→ Nat Nat))\n\n(define step-plus\n  (λ (n-1)\n    (add1 n-1)))\n\n(define +\n  (λ (n j)\n    (iter-Nat n\n      j\n      step-plus)))\n\n(claim result Nat)\n(define result (+ 2 3))","List Length":"(claim length\n  (Π ((E U))\n    (→ (List E) Nat)))\n\n(claim step-length\n  (Π ((E U))\n    (→ E (List E) Nat Nat)))\n\n(define step-length\n  (λ (E)\n    (λ (e es length-es)\n      (add1 length-es))))\n\n(define length\n  (λ (E)\n    (λ (es)\n      (rec-List es\n        0\n        (step-length E)))))\n\n(claim my-list (List Nat))\n(define my-list (:: 1 (:: 2 (:: 3 nil))))\n\n(claim list-len Nat)\n(define list-len (length Nat my-list))","Either Type":"(claim either-swap\n  (Pi ((A U) (B U))\n    (-> (Either A B)\n        (Either B A))))\n\n(define either-swap\n  (lambda (A B)\n    (lambda (e)\n      (ind-Either e\n        (lambda (x) (Either B A))\n        (lambda (a) (right a))\n        (lambda (b) (left b))))))\n\n(claim test-either (Either Nat Nat))\n(define test-either (left zero))\n\n(claim swapped (Either Nat Nat))\n(define swapped (either-swap Nat Nat test-either))","Vector Map":"(claim vec-map\n  (Π ((A U) (B U) (n Nat))\n     (-> (-> A B) (Vec A n)\n         (Vec B n))))\n\n(define vec-map\n  (λ (A B n)\n    (λ (f vs)\n      (ind-Vec n vs\n        (λ (k xs) (Vec B k))\n        vecnil\n        (λ (k x xs ih) (vec:: (f x) ih))))))\n\n(claim nat-vec (Vec Nat 3))\n(define nat-vec (vec:: 1 (vec:: 2 (vec:: 3 vecnil))))\n\n(claim add1-fn (-> Nat Nat))\n(define add1-fn (λ (n) (add1 n)))\n\n(claim incremented-vec (Vec Nat 3))\n(define incremented-vec (vec-map Nat Nat 3 add1-fn nat-vec))","Tactics: Even or Odd":'\n(claim +\n  (→ Nat Nat\n    Nat))\n\n(claim step-plus\n  (→ Nat\n    Nat))\n\n(define step-plus\n  (λ (n-1)\n    (add1 n-1 ) ))\n\n(define +\n  (λ (n j)\n    (iter-Nat n\n      j\n      step-plus )))\n\n(claim double\n  (→ Nat\n    Nat))\n\n(define double\n  (λ (n)\n    (iter-Nat n\n      0\n      (+ 2))))\n\n(claim Even\n  (→ Nat\n    U ))\n\n(define Even\n  (λ (n)\n    (Σ ((half Nat))\n      (= Nat n (double half )))))\n\n(claim Odd\n  (→ Nat\n    U ))\n\n(define Odd\n  (λ (n)\n    (Σ ((haf Nat))\n      (= Nat n (add1 (double haf )))))) \n\n(claim zero-is-even\n  (Even 0))\n\n(define zero-is-even\n  (cons 0\n    (same 0)))\n\n(claim add1-even->odd\n  (Π ((n Nat))\n    (→ (Even n)\n    (Odd (add1 n)))))\n\n(define add1-even->odd\n  (λ (n en)\n    (cons (car en)\n    (cong (cdr en) (+ 1)))))\n\n(claim add1-odd->even\n  (Π ((n Nat))\n    (→ (Odd n)\n      (Even (add1 n)))))\n\n(define add1-odd->even\n  (λ (n on)\n    (cons (add1 (car on))\n      (cong (cdr on) (+ 1)))))\n\n(claim even-or-odd\n  (Π ((n Nat))\n    (Either (Even n) (Odd n))))\n\n;; This is the proof in The Little Typer\n;; (claim mot-even-or-odd\n;;   (→ Nat U )) \n\n;; (define mot-even-or-odd\n;;   (λ (k) (Either (Even k) (Odd k))))\n\n;; (claim step-even-or-odd\n;;   (Π ((n-1 Nat))\n;;      (→ (mot-even-or-odd n-1)\n;;      (mot-even-or-odd (add1 n-1)))))\n\n;; (define step-even-or-odd\n;;   (λ (n-1)\n;;     (λ (e-or-on-1)\n;;        (ind-Either e-or-on-1\n;;     (λ (e-or-on-1)\n;;        (mot-even-or-odd (add1 n-1)))\n;;        (λ (en-1)\n;;          (right\n;;            (add1-even->odd\n;;              n-1 en-1)))\n;;        (λ (on-1)\n;;          (left\n;;            (add1-odd->even\n;;              n-1 on-1)))))))\n\n;; (define even-or-odd\n;;   (λ (n)\n;;     (ind-Nat n\n;;        mot-even-or-odd\n;;        (left zero-is-even)\n;;        step-even-or-odd)))\n\n\n;; This is the proof using our new tactic system\n(define-tactically even-or-odd\n  ( (intro n)\n    (elimNat n)\n    (left)\n    (exact zero-is-even)\n    (intro n-1)\n    (intro e-or-on-1)\n    (elimEither e-or-on-1)\n    (intro xr)\n    (right)\n    (exact ((add1-even->odd n-1) xr))\n    (intro x1)\n    (left)\n    ;; finish the proof with "(exact ((add1-odd->even n-1) x1))"\n   ))',"Inductive Type: Less Than":";; Define Less Than relation using our new inductive type definiton\n    (data Less-Than () ((j Nat) (k Nat))\n      (zero-smallest ((n Nat)) (Less-Than () (zero (add1 n))))\n      (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than () (j k)))) (Less-Than () ((add1 j) (add1 k))))\n      ind-Less-Than)\n\n    (claim proof-0<1 (Less-Than () (zero (add1 zero))))\n    (define proof-0<1 (zero-smallest zero))\n\n    (claim proof-1<2 (Less-Than () ((add1 zero) (add1 (add1 zero)))))\n    (define proof-1<2 (add1-smaller zero (add1 zero) proof-0<1))\n\n    (claim extract-smaller\n      (Pi ((j Nat) (k Nat))\n        (-> (Less-Than () (j k)) Nat)))\n    (define extract-smaller\n      (lambda (j k proof)\n        (ind-Less-Than proof\n          (lambda (j-idx k-idx p) Nat)\n          (lambda (n) zero)\n          (lambda (j-arg k-arg j<k-arg ih) (add1 ih)))))\n\n    (claim result Nat)\n    (define result (extract-smaller zero (add1 zero) proof-0<1))\n    ","Inductive Type: Subtype":"\n(data Subtype () ((T1 U) (T2 U))\n  (refl ((T U))\n    (Subtype () (T T)))\n  (trans ((T1 U) (T2 U) (T3 U)\n          (p1 (Subtype () (T1 T2)))\n          (p2 (Subtype () (T2 T3))))\n    (Subtype () (T1 T3)))\n  ;; Generic injection: if there exists a function A -> B, then A <: B\n  (inject ((A U) (B U) (f (-> A B)))\n    (Subtype () (A B)))\n  ind-Subtype)\n\n(claim coerce\n  (Pi ((A U) (B U))\n    (-> (Subtype () (A B)) A B)))\n(define coerce\n  (lambda (A B proof val)\n    ((ind-Subtype proof\n      (lambda (t1 t2 sub) (-> t1 t2))\n      (lambda (TT x) x)\n      (lambda (T11 T22 T33 p1 p2 ih1 ih2 x)\n        (ih2 (ih1 x)))\n      (lambda (AA BB ff x) (ff x))\n      )\n      val)))\n\n(data Even () ((n Nat))\n  (zero-even ()\n    (Even () (zero)))\n  (add2-even ((k Nat) (k-even (Even () (k))))\n    (Even () ((add1 (add1 k)))))\n  ind-Even)\n\n(claim even-to-nat\n  (Pi ((n Nat))\n    (-> (Even () (n)) Nat)))\n(define even-to-nat\n  (lambda (n proof)\n    (ind-Even proof\n      (lambda (m ev) Nat)\n      zero\n      (lambda (k prev ih) (add1 (add1 ih))))))\n\n(claim even-subtype-nat\n  (Pi ((n Nat))\n    (Subtype () ((Even () (n)) Nat))))\n(define even-subtype-nat\n  (lambda (n)\n    (inject (Even () (n)) Nat (even-to-nat n))))\n\n(claim + (-> Nat Nat Nat))\n(define +\n  (lambda (a b)\n    (rec-Nat a\n      b\n      (lambda (pred ih) (add1 ih)))))\n\n(claim double (-> Nat Nat))\n(define double\n  (lambda (n)\n    (+ n n)))\n\n;; Use Even with double\n(claim double-even\n  (Pi ((n Nat))\n    (-> (Even () (n)) Nat)))\n(define double-even\n  (lambda (n ev)\n    (double (coerce (Even () (n)) Nat\n                    (even-subtype-nat n)\n                    ev))))\n\n\n(claim even-four (Even () ((add1 (add1 (add1 (add1 zero)))))))\n(define even-four\n  (add2-even (add1 (add1 zero))\n    (add2-even zero\n      (zero-even))))\n\n(claim result2 Nat)\n(define result2 (double-even (add1 (add1 (add1 (add1 zero)))) even-four))\n        "},l=d["Hello World"],c=document.getElementById("preview-summary"),u=document.getElementById("preview-output");let h=null,m=null,p=null,g=null,v=null,b=null;function f(e,t="neutral"){c&&(c.textContent=e,c.dataset.tone=t)}function y(e,t){t?u.dataset.tone=t:delete u.dataset.tone,u.textContent=void 0===e?"Program is empty.":e}function N(e,t,n){const{diagnostics:i,pretty:o,proofTree:r}=n,s=t.getModel();if(!s)return;const a=i.map(t=>({startLineNumber:t.startLineNumber,startColumn:t.startColumn,endLineNumber:t.endLineNumber,endColumn:t.endColumn,message:t.message,severity:"warning"===t.severity?e.MarkerSeverity.Warning:e.MarkerSeverity.Error}));if(e.editor.setModelMarkers(s,"pie-playground",a),function(e){const t=document.getElementById("proof-tree-container");if(t){if(!e)return t.style.display="none",g&&g.clear(),v&&v.clear(),void(b&&b.clear());t.style.display="flex",g&&g.render(e),v&&v.clear(),b&&b.clear()}}(r),0===i.length)return f("SUCCESS","success"),void y(o?.trim()??void 0,"success");const d=i[0],l="warning"===d.severity?"warning":"error";f("warning"===l?"WARNING":"ERROR",l);y(`${`Line ${d.startLineNumber}, Col ${d.startColumn}`}\n${d.message}`,l)}function w(e,t){let n;return function(...i){window.clearTimeout(n),n=window.setTimeout(()=>e.apply(this,i),t)}}!async function(){window.require?(window.require.config({paths:{vs:"https://cdn.jsdelivr.net/npm/monaco-editor@0.52.0/min/vs"}}),window.require(["vs/editor/editor.main"],async()=>{p=window.monaco;const t=function(e){!function(e){e.languages.register({id:"pie"}),e.languages.setLanguageConfiguration("pie",{comments:{lineComment:";",blockComment:["#|","|#"]},brackets:[["(",")"],["[","]"],["{","}"]],autoClosingPairs:[{open:"(",close:")"},{open:"[",close:"]"},{open:"{",close:"}"},{open:'"',close:'"'}],surroundingPairs:[{open:"(",close:")"},{open:"[",close:"]"},{open:"{",close:"}"},{open:'"',close:'"'}]}),e.languages.setMonarchTokensProvider("pie",{defaultToken:"",tokenPostfix:".pie",keywords:["lambda","λ","Pi","Π","Sigma","Σ","define","claim","the","check-same","define-tactically","TODO","U","Universe","Nat","Atom","List","Vec","Either","zero","add1","nil","cons","car","cdr","ind-Nat","rec-Nat","iter-Nat","ind-List","rec-List","ind-Vec","rec-Vec","ind-Either","replace","trans","cong","symm","same","left","right","ind-Either","vecnil","vec::"],operators:["->","→","=","::"],symbols:/[=><!~?:&|+\-*/^%]+/,tokenizer:{root:[{include:"@whitespace"},[/\((?:lambda|λ|Pi|Π|Sigma|Σ|define|claim|the|check-same|define-tactically)\b/,"keyword"],[/[a-zA-Z][a-zA-Z0-9\-_!?*+=<>λΠΣ→]*/,{cases:{"@keywords":"keyword","@default":"identifier"}}],[/\d+/,"number"],[/"([^"\\]|\\.)*$/,"string.invalid"],[/"/,"string","@string"],[/'[a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*/,"string.quoted"],[/[()[\]]/,"@brackets"],[/@symbols/,{cases:{"@operators":"operator","@default":""}}]],whitespace:[[/[ \t\r\n]+/,"white"],[/;.*$/,"comment"],[/#\|/,"comment","@comment"]],comment:[[/[^#|]+/,"comment"],[/\|#/,"comment","@pop"],[/[#|]/,"comment"]],string:[[/[^\\"]+/,"string"],[/\\./,"string.escape"],[/"/,"string","@pop"]]}})}(e);const t=e.editor.create(document.getElementById("editor"),{value:l,language:"pie",theme:"vs-dark",automaticLayout:!0,minimap:{enabled:!1},scrollbar:{vertical:"auto",horizontal:"auto",useShadows:!1,verticalScrollbarSize:6,verticalSliderSize:4},padding:{top:16},fontSize:14,fontFamily:"Menlo, 'Fira Code', 'JetBrains Mono', monospace",smoothScrolling:!0});y(l.trim()),f("Ready for analysis.","neutral");const n=w(e=>{0===e.trim().length?(f("Waiting for input…","neutral"),y(void 0)):(f("Running checks…","warning"),y("Analyzing…"))},120),i=w(e=>{f("Running checks…","warning"),h&&h.postMessage({type:"analyze",payload:{source:e}})},220);return t.onDidChangeModelContent(()=>{const e=t.getValue();n(e),i(e)}),t}(p);h=function(e){if(!("Worker"in window))return f("Diagnostics unavailable in this browser.","warning"),null;const t=new Worker("diagnostics-worker.js",{type:"module"});return t.onmessage=t=>{const{type:n,payload:i}=t.data;"diagnostics"===n&&p&&N(p,e,i)},t.onerror=e=>{console.error("Worker error event:",e),console.error("Error details:",{message:e.message,filename:e.filename,lineno:e.lineno,colno:e.colno}),f("Diagnostics worker crashed.","error"),y(`Worker failed to load. Check browser console for details.\nError: ${e.message||"Unknown error"}`,"error")},t}(t),function(e){const t=document.getElementById("example-picker");t&&(Object.keys(d).forEach(e=>{const n=document.createElement("option");n.value=e,n.textContent=e,t.appendChild(n)}),t.value="Hello World",t.addEventListener("change",t=>{const n=t.target.value;n&&d[n]&&e.setValue(d[n])}))}(t),function(e){const t=document.getElementById("copy-btn");t&&t.addEventListener("click",async()=>{const n=e.getValue();try{await navigator.clipboard.writeText(n),t.textContent="Copied!",t.dataset.copied="true",setTimeout(()=>{t.textContent="Copy",delete t.dataset.copied},1500)}catch(e){console.error("Failed to copy:",e),t.textContent="Failed",setTimeout(()=>{t.textContent="Copy"},1500)}})}(t),function(){const e=document.getElementById("proof-tree-canvas"),t=document.getElementById("proof-context-panel"),o=document.getElementById("proof-goal-panel"),r=document.getElementById("proof-tree-toggle"),s=document.getElementById("proof-tree-container");e&&t&&o?(g=new n(e),v=new i(t),b=new a(o),g.setOnGoalSelect(e=>{v&&v.display(e),b&&b.display(e),g&&g.highlightGoal(e.id)}),r&&s&&r.addEventListener("click",()=>{const e=s.querySelector(".proof-tree-content");e&&("none"===e.style.display?(e.style.display="flex",r.textContent="Hide"):(e.style.display="none",r.textContent="Show"))})):console.warn("Proof tree containers not found")}(),p&&await async function(t,n){try{m&&m.isRunning()&&await m.stop(),m=new e(t,n),await m.start(),console.log("LSP client initialized successfully")}catch(e){console.error("Failed to initialize LSP client:",e),f("LSP features unavailable","warning")}}(p,t),h&&h.postMessage({type:"analyze",payload:{source:t.getValue()}}),window.__pieEditor=t})):console.error("Monaco loader not available")}();
//# sourceMappingURL=app.bundle.js.map
</file>

<file path="web/app.bundle.js.map">
{"version":3,"file":"app.bundle.js","sources":["lsp/lsp-client-simple.ts","proof-tree/ProofTreeVisualizer.ts","proof-tree/ContextPanel.ts","proof-tree/SExpressionParser.ts","proof-tree/CollapsibleTypeTree.ts","proof-tree/GoalPanel.ts","app.ts"],"sourcesContent":[null,null,null,null,null,null,null],"names":["PieLanguageClient","constructor","monacoInstance","editorInstance","this","worker","disposables","debouncedValidate","diagnostics","monaco","editor","start","Worker","URL","url","type","onmessage","event","handleWorkerMessage","data","onerror","error","console","model","getModel","debounce","source","getValue","postMessage","changeDisposable","onDidChangeModelContent","push","hoverDisposable","languages","registerHoverProvider","provideHover","position","completionDisposable","registerCompletionItemProvider","provideCompletionItems","definitionDisposable","registerDefinitionProvider","provideDefinition","stop","clearMarkers","forEach","disposable","dispose","terminate","isRunning","message","updateDiagnostics","severity","startLine","startColumn","endLine","endColumn","markers","map","diag","ensurePositiveNumber","startLineNumber","endLineNumber","MarkerSeverity","Warning","Error","setModelMarkers","diagnostic","find","lineNumber","column","contents","value","range","Promise","resolve","handleHover","removeEventListener","hoverInfo","info","markdownContent","title","summary","details","examples","addEventListener","line","setTimeout","handleCompletion","wordRange","end","suggestions","completions","item","kind","CompletionItemKind","Text","Keyword","Function","Variable","Class","Value","Snippet","label","detail","insertText","handleDefinition","location","uri","fallback","Number","isNaN","fn","delay","handle","window","clearTimeout","DEFAULT_CONFIG","nodeWidth","nodeHeight","horizontalSpacing","verticalSpacing","colors","current","completed","pending","edge","tacticLabel","background","ProofTreeVisualizer","container","config","svg","onGoalSelect","currentData","setOnGoalSelect","callback","render","clear","positions","calculateLayout","root","minX","Infinity","maxX","maxY","pos","Math","min","x","max","width","y","svgWidth","padding","svgHeight","offsetX","document","createElementNS","setAttribute","String","style","display","edgesGroup","nodesGroup","appendChild","renderNodeRecursive","node","offsetY","get","goal","id","child","children","childPos","childX","childY","renderEdge","appliedTactic","completedBy","length","renderSelfLoop","renderNode","parent","group","cursor","strokeColor","fillOpacity","isCurrent","isComplete","rect","idText","textContent","statusText","log","typeText","truncatedType","truncateText","parseFloat","fromX","fromY","toX","toY","tactic","startX","startY","endX","endY","midY","d","labelX","labelY","labelBg","labelText","labelWidth","text","centerX","bottomY","path","arrow","arrowX","arrowY","Map","widths","calculateSubtreeWidths","assignPositions","set","totalChildWidth","nodeX","childWidth","maxWidth","maxChars","floor","substring","parentNode","removeChild","highlightGoal","goalId","querySelectorAll","classList","remove","target","querySelector","add","ContextPanel","currentGoal","innerHTML","header","createElement","className","contentDiv","contextEntries","contextList","entry","entryDiv","nameSpan","name","colonSpan","typeSpan","emptyMsg","getCurrentGoal","Parser","tokens","advance","token","expect","parse","parseList","parseAtom","isAtom","sourceText","abbreviation","sourceTokens","join","replace","binding","param","kindPart","generateAbbreviation","getTypeCategory","lowerKind","toLowerCase","test","CollapsibleTypeTree","rootNode","nodeStates","nodeIdCounter","typeString","trimmed","trim","input","i","char","atom","tokenize","e","slice","parseSExpression","showPlainText","treeElement","showPlaceholder","expandAll","_","key","collapseAll","placeholder","pre","depth","nodeId","has","isExpanded","renderAtom","renderListNode","span","kindSpan","category","div","dataset","displayChildren","hasChildren","toggle","stopPropagation","toggleNode","spacer","isBindingType","bindingSpan","varName","varType","abbrev","getCollapsedHint","childrenDiv","childrenToRender","getChildrenToRender","childElement","body","currentState","GoalPanel","goalTypeTree","titleRow","status","goalTypeContainer","defaultSource","previewSummary","getElementById","previewOutput","diagnosticsWorker","lspClient","monacoApi","proofTreeVisualizer","contextPanel","goalPanel","setSummary","tone","renderPreviewText","undefined","applyDiagnostics","payload","pretty","proofTree","updateProofTree","primary","args","apply","async","require","paths","vs","register","setLanguageConfiguration","comments","lineComment","blockComment","brackets","autoClosingPairs","open","close","surroundingPairs","setMonarchTokensProvider","defaultToken","tokenPostfix","keywords","operators","symbols","tokenizer","include","cases","whitespace","comment","string","registerPieLanguage","create","language","theme","automaticLayout","minimap","enabled","scrollbar","vertical","horizontal","useShadows","verticalScrollbarSize","verticalSliderSize","top","fontSize","fontFamily","smoothScrolling","debounced","queueDiagnostics","content","initializeEditor","filename","lineno","colno","initializeDiagnostics","picker","Object","keys","option","exampleName","setValue","initializeExamplePicker","copyBtn","code","navigator","clipboard","writeText","copied","err","initializeCopyButton","canvasContainer","contextContainer","goalContainer","toggleBtn","warn","initializeProofTreeVisualizer","monacoLib","initializeLSP","__pieEditor","boot"],"mappings":"MA8BaA,EAQX,WAAAC,CAAYC,EAAqBC,GAPzBC,KAAAC,OAAwB,KAGxBD,KAAAE,YAAkC,GAClCF,KAAAG,kBAAyC,KACzCH,KAAAI,YAAkC,GAGxCJ,KAAKK,OAASP,EACdE,KAAKM,OAASP,CAChB,CAKA,WAAMQ,GACJP,KAAKC,OAAS,IAAIO,OAAO,IAAIC,IAAI,yCAA0CC,KAAM,CAAEC,KAAM,WAEzFX,KAAKC,OAAOW,UAAaC,IACvBb,KAAKc,oBAAoBD,EAAME,OAEjCf,KAAKC,OAAOe,QAAWC,IACrBC,QAAQD,MAAM,oBAAqBA,IAGrC,MAAME,EAAQnB,KAAKM,QAAQc,aAC3B,IAAKD,EACH,OAGFnB,KAAKG,kBAAoBH,KAAKqB,SAAS,KACrC,IAAKrB,KAAKC,OACR,OAEF,MAAMqB,EAASH,EAAMI,WACrBvB,KAAKC,OAAOuB,YAAY,CAAEb,KAAM,WAAYW,YAC3C,KAEH,MAAMG,EAAmBzB,KAAKM,QAAQoB,0BAA0B,KAC1D1B,KAAKG,mBACPH,KAAKG,sBAGLsB,GACFzB,KAAKE,YAAYyB,KAAKF,GAGxB,MAAMG,EAAkB5B,KAAKK,OAAOwB,UAAUC,sBAAsB,MAAO,CACzEC,aAAc,CAACZ,EAAYa,IAAkBhC,KAAK+B,aAAaZ,EAAOa,KAExEhC,KAAKE,YAAYyB,KAAKC,GAGtB,MAAMK,EAAuBjC,KAAKK,OAAOwB,UAAUK,+BAA+B,MAAO,CACvFC,uBAAwB,CAAChB,EAAYa,IAAkBhC,KAAKmC,uBAAuBhB,EAAOa,KAE5FhC,KAAKE,YAAYyB,KAAKM,GAGtB,MAAMG,EAAuBpC,KAAKK,OAAOwB,UAAUQ,2BAA2B,MAAO,CACnFC,kBAAmB,CAACnB,EAAYa,IAAkBhC,KAAKsC,kBAAkBnB,EAAOa,KAElFhC,KAAKE,YAAYyB,KAAKS,GAElBpC,KAAKG,mBACPH,KAAKG,mBAET,CAKA,UAAMoC,GACJvC,KAAKwC,eAELxC,KAAKE,YAAYuC,QAAQC,IACnBA,GAA4C,mBAAvBA,EAAWC,SAClCD,EAAWC,YAGf3C,KAAKE,YAAc,GACnBF,KAAKG,kBAAoB,KACzBH,KAAKI,YAAc,GAEfJ,KAAKC,SACPD,KAAKC,OAAO2C,YACZ5C,KAAKC,OAAS,KAElB,CAKA,SAAA4C,GACE,OAAuB,OAAhB7C,KAAKC,MACd,CAEQ,mBAAAa,CAAoBgC,GACrBA,IAIgB,sBAAjBA,EAAQnC,KACVX,KAAK+C,kBAAkBD,EAAQ1C,aAAe,IACpB,qBAAjB0C,EAAQnC,MACjBX,KAAK+C,kBAAkB,CACrB,CACEC,SAAU,QACVC,UAAW,EACXC,YAAa,EACbC,QAAS,EACTC,UAAW,EACXN,QAASA,EAAQ7B,SAIzB,CAEQ,iBAAA8B,CAAkB3C,GACxBJ,KAAKI,YAAcA,EACnB,MAAMe,EAAQnB,KAAKM,QAAQc,aAC3B,IAAKD,EACH,OAGF,MAAMkC,EAAUjD,EAAYkD,IAAKC,IAC/B,MAAMN,EAAYjD,KAAKwD,qBAAqBD,EAAKN,UAAW,GACtDE,EAAUnD,KAAKwD,qBAAqBD,EAAKJ,QAASF,GAClDC,EAAclD,KAAKwD,qBAAqBD,EAAKL,YAAa,GAEhE,MAAO,CACLO,gBAAiBR,EACjBC,cACAQ,cAAeP,EACfC,UALgBpD,KAAKwD,qBAAqBD,EAAKH,UAAWF,EAAc,GAMxEJ,QAASS,EAAKT,QACdE,SAA4B,YAAlBO,EAAKP,SACXhD,KAAKK,OAAOsD,eAAeC,QAC3B5D,KAAKK,OAAOsD,eAAeE,SAInC7D,KAAKK,OAAOC,OAAOwD,gBAAgB3C,EAAO,UAAWkC,EACvD,CAEQ,kBAAMtB,CAAaZ,EAAYa,GACrC,IAAKhC,KAAKC,OACR,OAAO,KAIT,MAAM8D,EAAa/D,KAAKI,YAAY4D,KAAMT,IACxC,MAAMN,EAAYjD,KAAKwD,qBAAqBD,EAAKN,UAAWjB,EAASiC,YAC/Dd,EAAUnD,KAAKwD,qBAAqBD,EAAKJ,QAASF,GAClDC,EAAclD,KAAKwD,qBAAqBD,EAAKL,YAAa,GAC1DE,EAAYpD,KAAKwD,qBAAqBD,EAAKH,UAAWF,EAAc,GAE1E,QAAIlB,EAASiC,WAAahB,GAAajB,EAASiC,WAAad,OAGzDnB,EAASiC,aAAehB,GAAajB,EAASkC,OAAShB,MAGvDlB,EAASiC,aAAed,GAAWnB,EAASkC,OAASd,MAM3D,GAAIW,EAAY,CACd,MAAMd,EAAYjD,KAAKwD,qBAAqBO,EAAWd,UAAWjB,EAASiC,YACrEd,EAAUnD,KAAKwD,qBAAqBO,EAAWZ,QAASF,GACxDC,EAAclD,KAAKwD,qBAAqBO,EAAWb,YAAa,GAChEE,EAAYpD,KAAKwD,qBAAqBO,EAAWX,UAAWF,EAAc,GAEhF,MAAO,CACLiB,SAAU,CACR,CAAEC,MAAO,KAA6B,YAAxBL,EAAWf,SAAyB,UAAY,gBAAgBe,EAAWjB,YAE3FuB,MAAO,CACLZ,gBAAiBR,EACjBC,cACAQ,cAAeP,EACfC,aAGN,CAGA,OAAO,IAAIkB,QAASC,IAClB,MAAMC,EAAe3D,IACnB,MAAMiC,EAAUjC,EAAME,KACtB,GAAqB,iBAAjB+B,EAAQnC,KAAyB,CAGnC,GAFAX,KAAKC,QAAQwE,oBAAoB,UAAWD,IAEvC1B,EAAQ4B,UAEX,YADAH,EAAQ,MAIV,MAAMI,EAAO7B,EAAQ4B,UACrB,IAAIE,EAAkB,KAAKD,EAAKE,cAAcF,EAAKG,UAE/CH,EAAKI,UACPH,GAAmB,OAAOD,EAAKI,WAG7BJ,EAAKK,WACPJ,GAAmB,iCAAiCD,EAAKK,oBAG3DT,EAAQ,CACNJ,SAAU,CACR,CAAEC,MAAOQ,KAGf,GAGF,GAAI5E,KAAKC,OAAQ,CACfD,KAAKC,OAAOgF,iBAAiB,UAAWT,GAExC,MAAMlD,EAASH,EAAMI,WACrBvB,KAAKC,OAAOuB,YAAY,CACtBb,KAAM,QACNW,SACA4D,KAAMlD,EAASiC,WAAa,EAC5BC,OAAQlC,EAASkC,OAAS,GAE9B,CAGAiB,WAAW,KACTnF,KAAKC,QAAQwE,oBAAoB,UAAWD,GAC5CD,EAAQ,OACP,MAEP,CAEQ,4BAAMpC,CAAuBhB,EAAYa,GAC/C,OAAKhC,KAAKC,OAIH,IAAIqE,QAASC,IAClB,MAAMa,EAAoBvE,IACxB,MAAMiC,EAAUjC,EAAME,KACtB,GAAqB,sBAAjB+B,EAAQnC,KAA8B,CACxCX,KAAKC,QAAQwE,oBAAoB,UAAWW,GAG5C,MAAMC,EAAYvC,EAAQuC,UACpBhB,EAAQgB,EAAY,CACxB5B,gBAAiBzB,EAASiC,WAC1Bf,YAAamC,EAAU9E,MAAQ,EAC/BmD,cAAe1B,EAASiC,WACxBb,UAAWiC,EAAUC,IAAM,GACzB,CACF7B,gBAAiBzB,EAASiC,WAC1Bf,YAAalB,EAASkC,OACtBR,cAAe1B,EAASiC,WACxBb,UAAWpB,EAASkC,QAGhBqB,EAAczC,EAAQ0C,YAAYlC,IAAKmC,IAE3C,IAAIC,EAAO1F,KAAKK,OAAOwB,UAAU8D,mBAAmBC,KACpD,OAAQH,EAAKC,MACX,IAAK,UACHA,EAAO1F,KAAKK,OAAOwB,UAAU8D,mBAAmBE,QAChD,MACF,IAAK,WACHH,EAAO1F,KAAKK,OAAOwB,UAAU8D,mBAAmBG,SAChD,MACF,IAAK,WACHJ,EAAO1F,KAAKK,OAAOwB,UAAU8D,mBAAmBI,SAChD,MACF,IAAK,gBACHL,EAAO1F,KAAKK,OAAOwB,UAAU8D,mBAAmBK,MAChD,MACF,IAAK,QACHN,EAAO1F,KAAKK,OAAOwB,UAAU8D,mBAAmBM,MAChD,MACF,IAAK,UACHP,EAAO1F,KAAKK,OAAOwB,UAAU8D,mBAAmBO,QAIpD,MAAO,CACLC,MAAOV,EAAKU,MACZT,OACAU,OAAQX,EAAKW,OACbC,WAAYZ,EAAKU,MACjB9B,WAIJE,EAAQ,CAAEgB,eACZ,GAGF,GAAIvF,KAAKC,OAAQ,CACfD,KAAKC,OAAOgF,iBAAiB,UAAWG,GAExC,MAAM9D,EAASH,EAAMI,WACrBvB,KAAKC,OAAOuB,YAAY,CACtBb,KAAM,aACNW,SACA4D,KAAMlD,EAASiC,WAAa,EAC5BC,OAAQlC,EAASkC,OAAS,GAE9B,CAGAiB,WAAW,KACTnF,KAAKC,QAAQwE,oBAAoB,UAAWW,GAC5Cb,EAAQ,CAAEgB,YAAa,MACtB,OA5EI,CAAEA,YAAa,GA8E1B,CAEQ,uBAAMjD,CAAkBnB,EAAYa,GAC1C,OAAKhC,KAAKC,OAIH,IAAIqE,QAASC,IAClB,MAAM+B,EAAoBzF,IACxB,MAAMiC,EAAUjC,EAAME,KACD,sBAAjB+B,EAAQnC,OACVX,KAAKC,QAAQwE,oBAAoB,UAAW6B,GAExCxD,EAAQyD,SACVhC,EAAQ,CACNiC,IAAKrF,EAAMqF,IACXnC,MAAO,CACLZ,gBAAiBX,EAAQyD,SAASrB,KAAO,EACzChC,YAAaJ,EAAQyD,SAASrD,YAAc,EAC5CQ,cAAeZ,EAAQyD,SAASrB,KAAO,EACvC9B,UAAWN,EAAQyD,SAASnD,UAAY,KAI5CmB,EAAQ,QAKd,GAAIvE,KAAKC,OAAQ,CACfD,KAAKC,OAAOgF,iBAAiB,UAAWqB,GAExC,MAAMhF,EAASH,EAAMI,WACrBvB,KAAKC,OAAOuB,YAAY,CACtBb,KAAM,aACNW,SACA4D,KAAMlD,EAASiC,WAAa,EAC5BC,OAAQlC,EAASkC,OAAS,GAE9B,CAGAiB,WAAW,KACTnF,KAAKC,QAAQwE,oBAAoB,UAAW6B,GAC5C/B,EAAQ,OACP,OAzCI,IA2CX,CAEQ,YAAA/B,GACN,MAAMrB,EAAQnB,KAAKM,QAAQc,aACvBD,GACFnB,KAAKK,OAAOC,OAAOwD,gBAAgB3C,EAAO,UAAW,GAEzD,CAEQ,oBAAAqC,CAAqBY,EAAkCqC,GAC7D,MAAqB,iBAAVrC,GAAsBsC,OAAOC,MAAMvC,IAGvCA,EAAQ,EAFNqC,EAEqBrC,CAChC,CAEQ,QAAA/C,CAASuF,EAAgBC,GAC/B,IAAIC,EAAwB,KAC5B,MAAO,KACU,OAAXA,GACFC,OAAOC,aAAaF,GAEtBA,EAASC,OAAO5B,WAAW,KACzB2B,EAAS,KACTF,KACCC,GAEP,EClZF,MAAMI,EAAmC,CACvCC,UAAW,IACXC,WAAY,GACZC,kBAAmB,GACnBC,gBAAiB,GACjBC,OAAQ,CACNC,QAAS,UACTC,UAAW,UACXC,QAAS,UACTC,KAAM,UACNC,YAAa,UACbC,WAAY,kBAUHC,EAOX,WAAAhI,CAAYiI,EAAwBC,GAN5B/H,KAAAgI,IAA4B,KAG5BhI,KAAAiI,aAA0D,KAC1DjI,KAAAkI,YAAoC,KAG1ClI,KAAK8H,UAAYA,EACjB9H,KAAK+H,OAAS,IAAKd,KAAmBc,EACxC,CAEA,eAAAI,CAAgBC,GACdpI,KAAKiI,aAAeG,CACtB,CAEA,MAAAC,CAAOtH,GACLf,KAAKkI,YAAcnH,EACnBf,KAAKsI,QAGL,MAAMC,EAAYvI,KAAKwI,gBAAgBzH,EAAK0H,MAG5C,IAAIC,EAAOC,IAAUC,GAAQD,IAAUE,EAAO,EAC9CN,EAAU9F,QAASqG,IACjBJ,EAAOK,KAAKC,IAAIN,EAAMI,EAAIG,GAC1BL,EAAOG,KAAKG,IAAIN,EAAME,EAAIG,EAAIH,EAAIK,OAClCN,EAAOE,KAAKG,IAAIL,EAAMC,EAAIM,EAAIpJ,KAAK+H,OAAOZ,cAG5C,MACMkC,EAAWT,EAAOF,EAAOY,GACzBC,EAAYV,EAAOS,GACnBE,EAHU,GAGCd,EAIjB1I,KAAKgI,IAAMyB,SAASC,gBAAgB,6BAA8B,OAClE1J,KAAKgI,IAAI2B,aAAa,QAASC,OAAOP,IACtCrJ,KAAKgI,IAAI2B,aAAa,SAAUC,OAAOL,IACvCvJ,KAAKgI,IAAI6B,MAAMC,QAAU,QAGzB,MAAMC,EAAaN,SAASC,gBAAgB,6BAA8B,KACpEM,EAAaP,SAASC,gBAAgB,6BAA8B,KAC1E1J,KAAKgI,IAAIiC,YAAYF,GACrB/J,KAAKgI,IAAIiC,YAAYD,GAGrBhK,KAAKkK,oBAAoBnJ,EAAK0H,KAAMF,EAAWiB,EAnB/B,GAmBiDO,EAAYC,GAE7EhK,KAAK8H,UAAUmC,YAAYjK,KAAKgI,IAClC,CAEQ,mBAAAkC,CACNC,EACA5B,EACAiB,EACAY,EACAL,EACAC,GAEA,MAAMlB,EAAMP,EAAU8B,IAAIF,EAAKG,KAAKC,IACpC,IAAKzB,EAAK,OAEV,MAAMG,EAAIH,EAAIG,EAAIO,EACZJ,EAAIN,EAAIM,EAAIgB,EAGlB,IAAK,MAAMI,KAASL,EAAKM,SAAU,CACjC,MAAMC,EAAWnC,EAAU8B,IAAIG,EAAMF,KAAKC,IAC1C,GAAIG,EAAU,CACZ,MAAMC,EAASD,EAASzB,EAAIO,EACtBoB,EAASF,EAAStB,EAAIgB,EAC5BpK,KAAK6K,WAAWd,EAAYd,EAAGG,EAAGuB,EAAQC,EAAQT,EAAKW,cACzD,CACF,CAGIX,EAAKY,aAAwC,IAAzBZ,EAAKM,SAASO,QACpChL,KAAKiL,eAAelB,EAAYd,EAAGG,EAAGe,EAAKY,aAI7C/K,KAAKkL,WAAWlB,EAAYG,EAAKG,KAAMrB,EAAGG,GAG1C,IAAK,MAAMoB,KAASL,EAAKM,SACvBzK,KAAKkK,oBAAoBM,EAAOjC,EAAWiB,EAASY,EAASL,EAAYC,EAE7E,CAEQ,UAAAkB,CAAWC,EAAqBb,EAAwBrB,EAAWG,GACzE,MAAMlC,UAAEA,EAASC,WAAEA,EAAUG,OAAEA,GAAWtH,KAAK+H,OAEzCqD,EAAQ3B,SAASC,gBAAgB,6BAA8B,KACrE0B,EAAMzB,aAAa,QAAS,aAC5ByB,EAAMzB,aAAa,eAAgBW,EAAKC,IACxCa,EAAMvB,MAAMwB,OAAS,UAGrB,IAAIC,EAAchE,EAAOG,QACrB8D,EAAc,MACdjB,EAAKkB,WACPF,EAAchE,EAAOC,QACrBgE,EAAc,OACLjB,EAAKmB,aACdH,EAAchE,EAAOE,UACrB+D,EAAc,QAIhB,MAAMG,EAAOjC,SAASC,gBAAgB,6BAA8B,QACpEgC,EAAK/B,aAAa,IAAKC,OAAOX,IAC9ByC,EAAK/B,aAAa,IAAKC,OAAOR,IAC9BsC,EAAK/B,aAAa,QAASC,OAAO1C,IAClCwE,EAAK/B,aAAa,SAAUC,OAAOzC,IACnCuE,EAAK/B,aAAa,KAAM,KACxB+B,EAAK/B,aAAa,KAAM,KACxB+B,EAAK/B,aAAa,OAAQ2B,GAC1BI,EAAK/B,aAAa,eAAgB4B,GAClCG,EAAK/B,aAAa,SAAU2B,GAC5BI,EAAK/B,aAAa,eAAgBW,EAAKkB,UAAY,IAAM,KACzDJ,EAAMnB,YAAYyB,GAGlB,MAAMC,EAASlC,SAASC,gBAAgB,6BAA8B,QACtEiC,EAAOhC,aAAa,IAAKC,OAAOX,EAAI,KACpC0C,EAAOhC,aAAa,IAAKC,OAAOR,EAAI,KACpCuC,EAAOhC,aAAa,OAAQ2B,GAC5BK,EAAOhC,aAAa,YAAa,MACjCgC,EAAOhC,aAAa,cAAe,aACnCgC,EAAOC,YAActB,EAAKC,GAC1Ba,EAAMnB,YAAY0B,GAGlB,MAAME,EAAapC,SAASC,gBAAgB,6BAA8B,QAC1EmC,EAAWlC,aAAa,IAAKC,OAAOX,EAAI/B,EAAY,KACpD2E,EAAWlC,aAAa,IAAKC,OAAOR,EAAI,KACxCyC,EAAWlC,aAAa,cAAe,OACvCkC,EAAWlC,aAAa,OAAQ2B,GAChCO,EAAWlC,aAAa,YAAa,MACrCzI,QAAQ4K,IAAI,QAAQxB,EAAKC,kBAAkBD,EAAKmB,yBAAyBnB,EAAKkB,aAC1ElB,EAAKmB,WACPI,EAAWD,YAAc,IAChBtB,EAAKkB,UACdK,EAAWD,YAAc,IAEzBC,EAAWD,YAAc,IAE3BR,EAAMnB,YAAY4B,GAGlB,MAAME,EAAWtC,SAASC,gBAAgB,6BAA8B,QACxEqC,EAASpC,aAAa,IAAKC,OAAOX,EAAI,KACtC8C,EAASpC,aAAa,IAAKC,OAAOR,EAAI,KACtC2C,EAASpC,aAAa,OAAQ,WAC9BoC,EAASpC,aAAa,YAAa,MACnCoC,EAASpC,aAAa,cAAe,aACrC,MAAMqC,EAAgBhM,KAAKiM,aAAa3B,EAAK3J,KAAMuG,EAAY,IAC/D6E,EAASH,YAAcI,EACvBZ,EAAMnB,YAAY8B,GAGlBX,EAAMnG,iBAAiB,QAAS,KAC1BjF,KAAKiI,cACPjI,KAAKiI,aAAaqC,KAKtBc,EAAMnG,iBAAiB,aAAc,KACnCyG,EAAK/B,aAAa,eAAgBC,OAAOsC,WAAWX,GAAe,OAErEH,EAAMnG,iBAAiB,aAAc,KACnCyG,EAAK/B,aAAa,eAAgB4B,KAGpCJ,EAAOlB,YAAYmB,EACrB,CAEQ,UAAAP,CACNM,EACAgB,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMrF,UAAEA,EAASC,WAAEA,EAAUG,OAAEA,GAAWtH,KAAK+H,OAGzCyE,EAASL,EAAQjF,EAAY,EAC7BuF,EAASL,EAAQjF,EACjBuF,EAAOL,EAAMnF,EAAY,EACzByF,EAAOL,EAGPpH,EAAOuE,SAASC,gBAAgB,6BAA8B,QAC9DkD,GAAQH,EAASE,GAAQ,EACzBE,EAAI,KAAKL,KAAUC,OAAYD,KAAUI,MAASF,KAAQE,MAASF,KAAQC,IAQjF,GAPAzH,EAAKyE,aAAa,IAAKkD,GACvB3H,EAAKyE,aAAa,OAAQ,QAC1BzE,EAAKyE,aAAa,SAAUrC,EAAOI,MACnCxC,EAAKyE,aAAa,eAAgB,KAClCwB,EAAOlB,YAAY/E,GAGfqH,EAAQ,CACV,MAAMO,GAAUN,EAASE,GAAQ,EAC3BK,EAASH,EAGTI,EAAUvD,SAASC,gBAAgB,6BAA8B,QACjEuD,EAAYjN,KAAKiM,aAAaM,EAAQ,KACtCW,EAAanE,KAAKC,IAAuB,EAAnBiE,EAAUjC,OAAa,GAAI,KACvDgC,EAAQrD,aAAa,IAAKC,OAAOkD,EAASI,EAAa,IACvDF,EAAQrD,aAAa,IAAKC,OAAOmD,EAAS,KAC1CC,EAAQrD,aAAa,QAASC,OAAOsD,IACrCF,EAAQrD,aAAa,SAAU,MAC/BqD,EAAQrD,aAAa,KAAM,KAC3BqD,EAAQrD,aAAa,OAAQrC,EAAOM,YACpCoF,EAAQrD,aAAa,eAAgB,OACrCwB,EAAOlB,YAAY+C,GAEnB,MAAMG,EAAO1D,SAASC,gBAAgB,6BAA8B,QACpEyD,EAAKxD,aAAa,IAAKC,OAAOkD,IAC9BK,EAAKxD,aAAa,IAAKC,OAAOmD,EAAS,IACvCI,EAAKxD,aAAa,cAAe,UACjCwD,EAAKxD,aAAa,OAAQrC,EAAOK,aACjCwF,EAAKxD,aAAa,YAAa,MAC/BwD,EAAKxD,aAAa,cAAe,aACjCwD,EAAKvB,YAAcqB,EACnB9B,EAAOlB,YAAYkD,EACrB,CACF,CAEQ,cAAAlC,CACNE,EACAlC,EACAG,EACAmD,GAEA,MAAMrF,UAAEA,EAASC,WAAEA,EAAUG,OAAEA,GAAWtH,KAAK+H,OAGzCqF,EAAUnE,EAAI/B,EAAY,EAC1BmG,EAAUjE,EAAIjC,EAKdmG,EAAO7D,SAASC,gBAAgB,6BAA8B,QAC9DmD,EAAI,KAAKO,EAAU,MAAMC,uBAChBD,EALG,MAKoBC,EANnB,yBAOJD,EANG,MAMoBC,EAPnB,yBAQJD,EAAU,MAAMC,IAC/BC,EAAK3D,aAAa,IAAKkD,GACvBS,EAAK3D,aAAa,OAAQ,QAC1B2D,EAAK3D,aAAa,SAAUrC,EAAOE,WACnC8F,EAAK3D,aAAa,eAAgB,KAClCwB,EAAOlB,YAAYqD,GAGnB,MACMC,EAAQ9D,SAASC,gBAAgB,6BAA8B,WAC/D8D,EAASJ,EAAU,GACnBK,EAASJ,EACfE,EAAM5D,aAAa,SACjB,GAAG6D,KAAUC,KAAUD,EALP,KAK6BC,EAL7B,KAKmDD,EALnD,KAKyEC,EALzE,KAOlBF,EAAM5D,aAAa,OAAQrC,EAAOE,WAClC2D,EAAOlB,YAAYsD,GAGnB,MAAMR,EAASM,EA3BI,GA2BmB,EAChCJ,EAAYjN,KAAKiM,aAAaM,EAAQ,KACtCW,EAAanE,KAAKC,IAAuB,IAAnBiE,EAAUjC,OAAe,GAAI,KAGnDgC,EAAUvD,SAASC,gBAAgB,6BAA8B,QACvEsD,EAAQrD,aAAa,IAAKC,OAAOwD,EAAUF,EAAa,IACxDF,EAAQrD,aAAa,IAAKC,OAAOmD,EAAS,KAC1CC,EAAQrD,aAAa,QAASC,OAAOsD,IACrCF,EAAQrD,aAAa,SAAU,MAC/BqD,EAAQrD,aAAa,KAAM,KAC3BqD,EAAQrD,aAAa,OAAQrC,EAAOM,YACpCoF,EAAQrD,aAAa,eAAgB,OACrCwB,EAAOlB,YAAY+C,GAEnB,MAAMG,EAAO1D,SAASC,gBAAgB,6BAA8B,QACpEyD,EAAKxD,aAAa,IAAKC,OAAOwD,IAC9BD,EAAKxD,aAAa,IAAKC,OAAOmD,EAAS,IACvCI,EAAKxD,aAAa,cAAe,UACjCwD,EAAKxD,aAAa,OAAQrC,EAAOE,WACjC2F,EAAKxD,aAAa,YAAa,MAC/BwD,EAAKxD,aAAa,cAAe,aACjCwD,EAAKvB,YAAcqB,EACnB9B,EAAOlB,YAAYkD,EACrB,CAEQ,eAAA3E,CAAgBC,GACtB,MAAMF,EAAY,IAAImF,IAGhBC,EAAS,IAAID,IAMnB,OALA1N,KAAK4N,uBAAuBnF,EAAMkF,GAGlC3N,KAAK6N,gBAAgBpF,EAAM,EAAG,EAAGkF,EAAQpF,GAElCA,CACT,CAEQ,sBAAAqF,CAAuBzD,EAA4BwD,GACzD,MAAMzG,UAAEA,EAASE,kBAAEA,GAAsBpH,KAAK+H,OAE9C,GAA6B,IAAzBoC,EAAKM,SAASO,OAEhB,OADA2C,EAAOG,IAAI3D,EAAKG,KAAKC,GAAIrD,GAClBA,EAGT,IAAI6G,EAAkB,EACtB,IAAK,MAAMvD,KAASL,EAAKM,SACvBsD,GAAmB/N,KAAK4N,uBAAuBpD,EAAOmD,GAExDI,IAAoB5D,EAAKM,SAASO,OAAS,GAAK5D,EAEhD,MAAM+B,EAAQJ,KAAKG,IAAIhC,EAAW6G,GAElC,OADAJ,EAAOG,IAAI3D,EAAKG,KAAKC,GAAIpB,GAClBA,CACT,CAEQ,eAAA0E,CACN1D,EACAlB,EACAG,EACAuE,EACApF,GAEA,MAAMrB,UAAEA,EAASC,WAAEA,EAAUC,kBAAEA,EAAiBC,gBAAEA,GAAoBrH,KAAK+H,OAIrEiG,EAAQ/E,IAHO0E,EAAOtD,IAAIF,EAAKG,KAAKC,KAAOrD,GAGfA,GAAa,EAI/C,GAHAqB,EAAUuF,IAAI3D,EAAKG,KAAKC,GAAI,CAAEtB,EAAG+E,EAAO5E,IAAGD,MAAOjC,IAG9CiD,EAAKM,SAASO,OAAS,EAAG,CAC5B,MAAMJ,EAASxB,EAAIjC,EAAaE,EAChC,IAAIsD,EAAS1B,EAEb,IAAK,MAAMuB,KAASL,EAAKM,SAAU,CACjC,MAAMwD,EAAaN,EAAOtD,IAAIG,EAAMF,KAAKC,KAAOrD,EAChDlH,KAAK6N,gBAAgBrD,EAAOG,EAAQC,EAAQ+C,EAAQpF,GACpDoC,GAAUsD,EAAa7G,CACzB,CACF,CACF,CAEQ,YAAA6E,CAAakB,EAAce,GAEjC,MAAMC,EAAWpF,KAAKqF,MAAMF,EAAW,GACvC,OAAIf,EAAKnC,QAAUmD,EAAiBhB,EAC7BA,EAAKkB,UAAU,EAAGF,EAAW,GAAK,KAC3C,CAEA,KAAA7F,GACMtI,KAAKgI,KAAOhI,KAAKgI,IAAIsG,YACvBtO,KAAKgI,IAAIsG,WAAWC,YAAYvO,KAAKgI,KAEvChI,KAAKgI,IAAM,IACb,CAEA,aAAAwG,CAAcC,GACZ,IAAKzO,KAAKgI,IAAK,OAGDhI,KAAKgI,IAAI0G,iBAAiB,cAClCjM,QAAQ0H,IACZA,EAAKwE,UAAUC,OAAO,iBAIxB,MAAMC,EAAS7O,KAAKgI,IAAI8G,cAAc,kBAAkBL,OACpDI,GACFA,EAAOF,UAAUI,IAAI,cAEzB,QCzaWC,EAIX,WAAAnP,CAAYiI,GAFJ9H,KAAAiP,YAAuC,KAG7CjP,KAAK8H,UAAYA,EACjB9H,KAAKsI,OACP,CAEA,OAAAwB,CAAQQ,GACNtK,KAAKiP,YAAc3E,EACnBtK,KAAK8H,UAAUoH,UAAY,GAG3B,MAAMC,EAAS1F,SAAS2F,cAAc,OACtCD,EAAOE,UAAY,eAEnB,MAAMxK,EAAQ4E,SAAS2F,cAAc,OACrCvK,EAAMwK,UAAY,cAClBxK,EAAM+G,YAAc,UACpBuD,EAAOlF,YAAYpF,GAEnB7E,KAAK8H,UAAUmC,YAAYkF,GAG3B,MAAMG,EAAa7F,SAAS2F,cAAc,OAG1C,GAFAE,EAAWD,UAAY,gBAEnB/E,EAAKiF,eAAevE,OAAS,EAAG,CAClC,MAAMwE,EAAc/F,SAAS2F,cAAc,OAC3CI,EAAYH,UAAY,eAExB,IAAK,MAAMI,KAASnF,EAAKiF,eAAgB,CACvC,MAAMG,EAAWjG,SAAS2F,cAAc,OACxCM,EAASL,UAAY,gBAErB,MAAMM,EAAWlG,SAAS2F,cAAc,QACxCO,EAASN,UAAY,qBACrBM,EAAS/D,YAAc6D,EAAMG,KAC7BF,EAASzF,YAAY0F,GAErB,MAAME,EAAYpG,SAAS2F,cAAc,QACzCS,EAAUR,UAAY,sBACtBQ,EAAUjE,YAAc,MACxB8D,EAASzF,YAAY4F,GAErB,MAAMC,EAAWrG,SAAS2F,cAAc,QACxCU,EAAST,UAAY,qBACrBS,EAASlE,YAAc6D,EAAM9O,KAC7B+O,EAASzF,YAAY6F,GAErBN,EAAYvF,YAAYyF,EAC1B,CAEAJ,EAAWrF,YAAYuF,EACzB,KAAO,CACL,MAAMO,EAAWtG,SAAS2F,cAAc,OACxCW,EAASV,UAAY,cACrBU,EAASnE,YAAc,UACvB0D,EAAWrF,YAAY8F,EACzB,CAEA/P,KAAK8H,UAAUmC,YAAYqF,EAC7B,CAEA,KAAAhH,GACEtI,KAAKiP,YAAc,KACnBjP,KAAK8H,UAAUoH,UAAY,oFAK7B,CAEA,cAAAc,GACE,OAAOhQ,KAAKiP,WACd,ECrBF,MAAMgB,EAIJ,WAAApQ,CAAYqQ,GAFJlQ,KAAA8I,IAAc,EAGpB9I,KAAKkQ,OAASA,CAChB,CAEQ,OAAA3I,GACN,OAAOvH,KAAKkQ,OAAOlQ,KAAK8I,MAAQ,CAAEnI,KAAM,MAC1C,CAEQ,OAAAwP,GACN,MAAMC,EAAQpQ,KAAKuH,UAEnB,OADAvH,KAAK8I,MACEsH,CACT,CAEQ,MAAAC,CAAO1P,GACb,MAAMyP,EAAQpQ,KAAKuH,UACnB,GAAI6I,EAAMzP,OAASA,EACjB,MAAM,IAAIkD,MAAM,YAAYlD,aAAgByP,EAAMzP,QAEpD,OAAOX,KAAKmQ,SACd,CAKA,KAAAG,GACE,MAAMF,EAAQpQ,KAAKuH,UAEnB,GAAmB,WAAf6I,EAAMzP,KACR,OAAOX,KAAKuQ,YACP,GAAmB,SAAfH,EAAMzP,KACf,OAAOX,KAAKwQ,YACP,GAAmB,QAAfJ,EAAMzP,KAEf,MAAO,CACL+E,KAAM,GACNtB,MAAO,GACPqG,SAAU,GACVgG,QAAQ,EACRC,WAAY,GACZC,aAAc,IAGhB,MAAM,IAAI9M,MAAM,qBAAqBuM,EAAMzP,OAE/C,CAEQ,SAAA6P,GACN,MAAMJ,EAAQpQ,KAAKqQ,OAAO,QAC1B,MAAO,CACL3K,KAAM0K,EAAMhM,MACZA,MAAOgM,EAAMhM,MACbqG,SAAU,GACVgG,QAAQ,EACRC,WAAYN,EAAMhM,MAClBuM,aAAcP,EAAMhM,MAExB,CAEQ,SAAAmM,GACNvQ,KAAKqQ,OAAO,UAEZ,MAAM5F,EAAuB,GACvBmG,EAAyB,CAAC,KAGhC,KAA+B,WAAxB5Q,KAAKuH,UAAU5G,MAA6C,QAAxBX,KAAKuH,UAAU5G,MAAgB,CACxE,MAAM6J,EAAQxK,KAAKsQ,QACnB7F,EAAS9I,KAAK6I,GACdoG,EAAajP,KAAK6I,EAAMkG,WAC1B,CAEA1Q,KAAKqQ,OAAO,UACZO,EAAajP,KAAK,KAGlB,MAAM+D,EAAO+E,EAASO,OAAS,GAAKP,EAAS,GAAGgG,OAC5ChG,EAAS,GAAG/E,KACZ,OAEEgL,EAAaE,EAAaC,KAAK,KAAKC,QAAQ,OAAQ,KAAKA,QAAQ,OAAQ,KACzEH,EAgDJ,SAA+BxG,GAKnC,MAAMzE,EAAOyE,EAAKzE,KACZ+E,EAAWN,EAAKM,SAGtB,OAAQ/E,GACN,IAAK,IACL,IAAK,KAEH,GAAI+E,EAASO,QAAU,EAAG,CACxB,MAAM+F,EAAUtG,EAAS,GACzB,IAAKsG,EAAQN,QAAUM,EAAQtG,SAASO,QAAU,EAAG,CAGnD,MAAO,MAFS+F,EAAQtG,SAAS,GAAGkG,kBACpBI,EAAQtG,SAAS,GAAGkG,mBAEtC,CACF,CACA,MAAO,QAGT,IAAK,IACL,IAAK,QAEH,GAAIlG,EAASO,QAAU,EAAG,CACxB,MAAM+F,EAAUtG,EAAS,GACzB,IAAKsG,EAAQN,QAAUM,EAAQtG,SAASO,QAAU,EAAG,CAGnD,MAAO,MAFS+F,EAAQtG,SAAS,GAAGkG,kBACpBI,EAAQtG,SAAS,GAAGkG,mBAEtC,CACF,CACA,MAAO,QAGT,IAAK,SAEH,OAAIlG,EAASO,QAAU,EACd,UAAUP,EAAS,GAAGkG,gBAAgBlG,EAAS,GAAGkG,eAEpD,aAGT,IAAK,OACL,IAAK,OACH,OAAIlG,EAASO,QAAU,EACd,QAAQP,EAAS,GAAGkG,eAEtB,WAGT,IAAK,QACL,IAAK,QACH,OAAIlG,EAASO,QAAU,EACd,SAASP,EAAS,GAAGkG,eAEvB,YAGT,IAAK,IAEH,OAAIlG,EAASO,QAAU,EACd,KAAKP,EAAS,GAAGkG,mBAEnB,QAGT,IAAK,IACL,IAAK,SAEH,GAAIlG,EAASO,QAAU,EAAG,CACxB,MAAMgG,EAAQvG,EAAS,GACvB,IAAKuG,EAAMP,QAAUO,EAAMvG,SAASO,QAAU,EAC5C,MAAO,MAAMgG,EAAMvG,SAAS,GAAGkG,mBAEnC,CACA,MAAO,QAGT,IAAK,OACH,OAAIlG,EAASO,QAAU,EACd,QAAQP,EAAS,GAAGkG,eAEtB,WAGT,IAAK,MACH,OAAIlG,EAASO,QAAU,EACd,OAAOP,EAAS,GAAGkG,gBAAgBlG,EAAS,GAAGkG,eAEjD,UAGT,IAAK,OACH,OAAIlG,EAASO,QAAU,EACd,QAAQP,EAAS,GAAGkG,gBAAgBlG,EAAS,GAAGkG,eAElD,WAGT,IAAK,OACL,IAAK,KACH,MAAO,SAGT,IAAK,OACH,OAAIlG,EAASO,QAAU,EACd,QAAQP,EAAS,GAAGkG,eAEtB,WAGT,QAEE,GAAIlG,EAASO,OAAS,EAAG,CACvB,MAAMiG,EAAWxG,EAAS,GAAGgG,OAAShG,EAAS,GAAGkG,aAAe,IACjE,OAAwB,IAApBlG,EAASO,OACJ,IAAIiG,KAEN,IAAIA,QACb,CACA,MAAO,QAGb,CA/KyBC,CAAqB,CAAExL,OAAM+E,aAElD,MAAO,CACL/E,OACA+E,WACAgG,QAAQ,EACRC,aACAC,eAEJ,EA2KI,SAAUQ,EAAgBzL,GAC9B,MAAM0L,EAAY1L,EAAK2L,cAGvB,MAAa,MAAT3L,GAAyB,OAATA,GAA0B,MAATA,GAAyB,OAATA,EAC5C,KAII,MAATA,GAAyB,UAATA,EACX,QAIS,WAAd0L,GAAwC,SAAdA,GAAsC,UAAdA,EAC7C,SAII,MAAT1L,GAA8B,SAAd0L,GAAsC,SAAdA,GAC1B,SAAdA,GAAsC,UAAdA,GAAuC,YAAdA,EAC5C,WAIS,SAAdA,GAAiC,OAAT1L,GAA+B,QAAd0L,GAAqC,SAAdA,EAC3D,OAIS,QAAdA,GAAqC,UAAdA,GAAuC,WAAdA,GAAwC,SAAdA,GAAsC,SAAdA,EAC7F,MAIS,QAAdA,GAAqC,SAAdA,GAAsC,SAAdA,EAC1C,MAII,MAAT1L,GAA8B,SAAd0L,GAAsC,YAAdA,GAAyC,WAAdA,GAAwC,SAAdA,EACxF,WAII,MAAT1L,GAA8B,WAAd0L,EACX,SAIL,sBAAsBE,KAAK5L,IAASA,EAAKsF,QAAU,IAAMtF,IAASA,EAAK2L,cAClE,WAGF,SACT,OCnXaE,EAMX,WAAA1R,CAAYiI,GAJJ9H,KAAAwR,SAA4B,KAC5BxR,KAAAyR,WAAmC,IAAI/D,IACvC1N,KAAA0R,cAAwB,EAG9B1R,KAAK8H,UAAYA,EACjB9H,KAAK8H,UAAU6G,UAAUI,IAAI,YAC/B,CAKA,MAAA1G,CAAOsJ,GACL3R,KAAKsI,QACLtI,KAAK0R,cAAgB,EAErB,MAAME,EAAUD,EAAWE,OAC3B,GAAKD,EAKL,IAGE,GAFA5R,KAAKwR,SD8HL,SAA2BM,GAC/B,MAAMF,EAAUE,EAAMD,OACtB,IAAKD,EACH,MAAO,CACLlM,KAAM,GACNtB,MAAO,GACPqG,SAAU,GACVgG,QAAQ,EACRC,WAAY,GACZC,aAAc,IAIlB,IACE,MAAMT,EA/JJ,SAAmB4B,GACvB,MAAM5B,EAAkB,GACxB,IAAI6B,EAAI,EAER,KAAOA,EAAID,EAAM9G,QAAQ,CACvB,MAAMgH,EAAOF,EAAMC,GAGnB,GAAI,KAAKT,KAAKU,GAAO,CACnBD,IACA,QACF,CAGA,GAAa,MAATC,EAAc,CAChB9B,EAAOvO,KAAK,CAAEhB,KAAM,WACpBoR,IACA,QACF,CAGA,GAAa,MAATC,EAAc,CAChB9B,EAAOvO,KAAK,CAAEhB,KAAM,WACpBoR,IACA,QACF,CAGA,IAAIE,EAAO,GACX,KAAOF,EAAID,EAAM9G,SAAW,SAASsG,KAAKQ,EAAMC,KAC9CE,GAAQH,EAAMC,GACdA,IAEEE,GACF/B,EAAOvO,KAAK,CAAEhB,KAAM,OAAQyD,MAAO6N,GAEvC,CAGA,OADA/B,EAAOvO,KAAK,CAAEhB,KAAM,QACbuP,CACT,CAuHmBgC,CAASN,GAExB,OADe,IAAI3B,EAAOC,GACZI,OAChB,CAAE,MAAO6B,GAEP,MAAO,CACLzM,KAAM,QACNtB,MAAOwN,EACPnH,SAAU,GACVgG,QAAQ,EACRC,WAAYkB,EACZjB,aAAciB,EAAQ5G,OAAS,GAAK4G,EAAQQ,MAAM,EAAG,IAAM,MAAQR,EAEvE,CACF,CC1JsBS,CAAiBT,GAEN,UAAvB5R,KAAKwR,SAAS9L,KAGhB,YADA1F,KAAKsS,cAAcV,GAIrB,MAAMW,EAAcvS,KAAKkL,WAAWlL,KAAKwR,SAAU,GACnDxR,KAAK8H,UAAUmC,YAAYsI,EAC7B,CAAE,MAAOJ,GAEPnS,KAAKsS,cAAcV,EACrB,MAlBE5R,KAAKwS,gBAAgB,qBAmBzB,CAKA,KAAAlK,GACEtI,KAAK8H,UAAUoH,UAAY,GAC3BlP,KAAKwR,SAAW,KAChBxR,KAAKyR,WAAWnJ,QAChBtI,KAAK0R,cAAgB,CACvB,CAKA,SAAAe,GAEE,GADAzS,KAAKyR,WAAWhP,QAAQ,CAACiQ,EAAGC,IAAQ3S,KAAKyR,WAAW3D,IAAI6E,GAAK,IACzD3S,KAAKwR,SAAU,CACjBxR,KAAK8H,UAAUoH,UAAY,GAC3B,MAAMqD,EAAcvS,KAAKkL,WAAWlL,KAAKwR,SAAU,GACnDxR,KAAK8H,UAAUmC,YAAYsI,EAC7B,CACF,CAKA,WAAAK,GAEE,GADA5S,KAAKyR,WAAWhP,QAAQ,CAACiQ,EAAGC,IAAQ3S,KAAKyR,WAAW3D,IAAI6E,GAAK,IACzD3S,KAAKwR,SAAU,CACjBxR,KAAK8H,UAAUoH,UAAY,GAC3B,MAAMqD,EAAcvS,KAAKkL,WAAWlL,KAAKwR,SAAU,GACnDxR,KAAK8H,UAAUmC,YAAYsI,EAC7B,CACF,CAEQ,eAAAC,CAAgB1P,GACtB,MAAM+P,EAAcpJ,SAAS2F,cAAc,OAC3CyD,EAAYxD,UAAY,yBACxBwD,EAAYjH,YAAc9I,EAC1B9C,KAAK8H,UAAUmC,YAAY4I,EAC7B,CAEQ,aAAAP,CAAcnF,GACpB,MAAM2F,EAAMrJ,SAAS2F,cAAc,OACnC0D,EAAIzD,UAAY,sBAChByD,EAAIlH,YAAcuB,EAClBnN,KAAK8H,UAAUmC,YAAY6I,EAC7B,CAEQ,UAAA5H,CAAWf,EAAgB4I,GACjC,MAAMC,EAAS,IAAIhT,KAAK0R,gBAGnB1R,KAAKyR,WAAWwB,IAAID,IACvBhT,KAAKyR,WAAW3D,IAAIkF,EAAQD,EAAQ,GAGtC,MAAMG,EAAalT,KAAKyR,WAAWpH,IAAI2I,KAAW,EAElD,OAAI7I,EAAKsG,OACAzQ,KAAKmT,WAAWhJ,GAGlBnK,KAAKoT,eAAejJ,EAAM6I,EAAQD,EAAOG,EAClD,CAEQ,UAAAC,CAAWhJ,GACjB,MAAMkJ,EAAO5J,SAAS2F,cAAc,QACpCiE,EAAKhE,UAAY,4BAEjB,MAAMiE,EAAW7J,SAAS2F,cAAc,QAClCmE,EAAWpC,EAAgBhH,EAAKzE,MAKtC,OAJA4N,EAASjE,UAAY,8BAA8BkE,IACnDD,EAAS1H,YAAczB,EAAK/F,OAAS+F,EAAKzE,KAC1C2N,EAAKpJ,YAAYqJ,GAEVD,CACT,CAEQ,cAAAD,CAAejJ,EAAgB6I,EAAgBD,EAAeG,GACpE,MAAMM,EAAM/J,SAAS2F,cAAc,OACnCoE,EAAInE,UAAY,4BAChBmE,EAAIC,QAAQT,OAASA,EAGrB,MAAMvI,EAAWN,EAAKM,SAEhBiJ,EADejJ,EAASO,OAAS,GAAKP,EAAS,GAAGgG,QAAUhG,EAAS,GAAG/E,OAASyE,EAAKzE,KACrD+E,EAAS2H,MAAM,GAAK3H,EAErDkJ,EAAcD,EAAgB1I,OAAS,EAGvCmE,EAAS1F,SAAS2F,cAAc,OAItC,GAHAD,EAAOE,UAAY,oBAGfsE,EAAa,CACf,MAAMC,EAASnK,SAAS2F,cAAc,QACtCwE,EAAOvE,UAAY,oBACnBuE,EAAOhI,YAAcsH,EAAa,IAAM,IACxCU,EAAO3O,iBAAiB,QAAUkN,IAChCA,EAAE0B,kBACF7T,KAAK8T,WAAWd,KAElB7D,EAAOlF,YAAY2J,EACrB,KAAO,CAEL,MAAMG,EAAStK,SAAS2F,cAAc,QACtC2E,EAAO1E,UAAY,2BACnBF,EAAOlF,YAAY8J,EACrB,CAGA,MAAMT,EAAW7J,SAAS2F,cAAc,QAClCmE,EAAWpC,EAAgBhH,EAAKzE,MAMtC,GALA4N,EAASjE,UAAY,8BAA8BkE,IACnDD,EAAS1H,YAAczB,EAAKzE,KAC5ByJ,EAAOlF,YAAYqJ,GAGftT,KAAKgU,cAAc7J,EAAKzE,OAASgO,EAAgB1I,QAAU,EAAG,CAEhE,MAAM+F,EAAU2C,EAAgB,GAChC,IAAK3C,EAAQN,QAAUM,EAAQtG,SAASO,QAAU,EAAG,CACnD,MAAMiJ,EAAcxK,SAAS2F,cAAc,QAC3C6E,EAAY5E,UAAY,qBACxB,MAAM6E,EAAUnD,EAAQtG,SAAS,GAAGrG,OAAS2M,EAAQtG,SAAS,GAAG/E,KAC3DyO,EAAUpD,EAAQtG,SAAS,GAAGkG,aACpCsD,EAAYrI,YAAc,KAAKsI,OAAaC,KAC5ChF,EAAOlF,YAAYgK,EACrB,MAAO,IAAKlD,EAAQN,QAAsC,IAA5BM,EAAQtG,SAASO,OAAc,CAE3D,MAAMiJ,EAAcxK,SAAS2F,cAAc,QAC3C6E,EAAY5E,UAAY,qBACxB,MAAM6E,EAAUnD,EAAQtG,SAAS,GAAGrG,OAAS2M,EAAQtG,SAAS,GAAG/E,KACjEuO,EAAYrI,YAAc,KAAKsI,KAC/B/E,EAAOlF,YAAYgK,EACrB,CACF,CAGA,IAAKf,GAAcS,EAAa,CAC9B,MAAMS,EAAS3K,SAAS2F,cAAc,QACtCgF,EAAO/E,UAAY,oBACnB+E,EAAOxI,YAAc,IAAM5L,KAAKqU,iBAAiBlK,EAAMuJ,GACvDvE,EAAOlF,YAAYmK,EACrB,CAKA,GAHAZ,EAAIvJ,YAAYkF,GAGZwE,GAAeT,EAAY,CAC7B,MAAMoB,EAAc7K,SAAS2F,cAAc,OAC3CkF,EAAYjF,UAAY,sBAGxB,MAAMkF,EAAmBvU,KAAKwU,oBAAoBrK,EAAMuJ,GAExD,IAAK,MAAMlJ,KAAS+J,EAAkB,CACpC,MAAME,EAAezU,KAAKkL,WAAWV,EAAOuI,EAAQ,GACpDuB,EAAYrK,YAAYwK,EAC1B,CAEAjB,EAAIvJ,YAAYqK,EAClB,CAEA,OAAOd,CACT,CAEQ,aAAAQ,CAActO,GACpB,MAAgB,MAATA,GAAyB,OAATA,GAA0B,MAATA,GAAyB,UAATA,GAA6B,MAATA,GAAyB,WAATA,CAC9F,CAEQ,mBAAA8O,CAAoBrK,EAAgBuJ,GAE1C,OAAI1T,KAAKgU,cAAc7J,EAAKzE,OAASgO,EAAgB1I,QAAU,EACtD0I,EAAgBtB,MAAM,GAExBsB,CACT,CAEQ,gBAAAW,CAAiBlK,EAAgBuJ,GACvC,GAA+B,IAA3BA,EAAgB1I,OAClB,MAAO,GAIT,GAAIhL,KAAKgU,cAAc7J,EAAKzE,OAASgO,EAAgB1I,QAAU,EAAG,CAChE,MAAM0J,EAAOhB,EAAgB,GAC7B,OAAIgB,EAAKjE,OACAiE,EAAKhP,KAEP,KAAKgP,EAAKhP,UACnB,CAGA,MAAO,KACT,CAEQ,UAAAoO,CAAWd,GACjB,MAAM2B,EAAe3U,KAAKyR,WAAWpH,IAAI2I,KAAW,EAIpD,GAHAhT,KAAKyR,WAAW3D,IAAIkF,GAAS2B,GAGzB3U,KAAKwR,SAAU,CACjBxR,KAAK0R,cAAgB,EACrB1R,KAAK8H,UAAUoH,UAAY,GAC3B,MAAMqD,EAAcvS,KAAKkL,WAAWlL,KAAKwR,SAAU,GACnDxR,KAAK8H,UAAUmC,YAAYsI,EAC7B,CACF,QC7PWqC,EAKX,WAAA/U,CAAYiI,GAHJ9H,KAAAiP,YAAuC,KACvCjP,KAAA6U,aAA2C,KAGjD7U,KAAK8H,UAAYA,EACjB9H,KAAKsI,OACP,CAEA,OAAAwB,CAAQQ,GACNtK,KAAKiP,YAAc3E,EACnBtK,KAAK8H,UAAUoH,UAAY,GAG3B,MAAMC,EAAS1F,SAAS2F,cAAc,OACtCD,EAAOE,UAAY,eAEnB,MAAMyF,EAAWrL,SAAS2F,cAAc,OACxC0F,EAASzF,UAAY,kBAErB,MAAMxK,EAAQ4E,SAAS2F,cAAc,OACrCvK,EAAMwK,UAAY,cAClBxK,EAAM+G,YAAc,OACpBkJ,EAAS7K,YAAYpF,GAErB,MAAM4J,EAAShF,SAAS2F,cAAc,QACtCX,EAAOY,UAAY,gBACnBZ,EAAO7C,YAActB,EAAKC,GAC1BuK,EAAS7K,YAAYwE,GAErBU,EAAOlF,YAAY6K,GAGnB,MAAMC,EAAStL,SAAS2F,cAAc,QACtC2F,EAAO1F,UAAY,eACf/E,EAAKmB,YACPsJ,EAAOnJ,YAAc,YACrBmJ,EAAOpG,UAAUI,IAAI,qBACZzE,EAAKkB,WACduJ,EAAOnJ,YAAc,UACrBmJ,EAAOpG,UAAUI,IAAI,oBAErBgG,EAAOnJ,YAAc,UACrBmJ,EAAOpG,UAAUI,IAAI,mBAEvBI,EAAOlF,YAAY8K,GAEnB/U,KAAK8H,UAAUmC,YAAYkF,GAG3B,MAAMG,EAAa7F,SAAS2F,cAAc,OAC1CE,EAAWD,UAAY,gBAEvB,MAAM2F,EAAoBvL,SAAS2F,cAAc,OACjD4F,EAAkB3F,UAAY,iBAC9BrP,KAAK6U,aAAe,IAAItD,EAAoByD,GAC5ChV,KAAK6U,aAAaxM,OAAOiC,EAAK3J,MAC9B2O,EAAWrF,YAAY+K,GAEvBhV,KAAK8H,UAAUmC,YAAYqF,EAC7B,CAEA,KAAAhH,GACEtI,KAAKiP,YAAc,KACnBjP,KAAK6U,aAAe,KACpB7U,KAAK8H,UAAUoH,UAAY,oFAK7B,CAEA,cAAAc,GACE,OAAOhQ,KAAKiP,WACd,ECjEF,MAAMjK,EAAW,CACf,cAAe,8FAMf,0BAA2B,4OAmB3B,cAAe,2bA0Bf,cAAe,+aAmBf,aAAc,ggBAqBhB,uBAAyB,itEAiItB,4BAA6B,07BAyB5B,0BAA0B,66DAqFxBiQ,EAAgBjQ,EAAS,eAEzBkQ,EAAiBzL,SAAS0L,eAAe,mBACzCC,EAAgB3L,SAAS0L,eAAe,kBAE9C,IAAIE,EAAmC,KACnCC,EAAsC,KACtCC,EAAkC,KAClCC,EAAkD,KAClDC,EAAoC,KACpCC,EAA8B,KAElC,SAASC,EAAW7S,EAAiB8S,EAAoD,WACnFV,IACFA,EAAetJ,YAAc9I,EAC7BoS,EAAezB,QAAQmC,KAAOA,EAElC,CAEA,SAASC,EAAkB1I,EAA0ByI,GAC/CA,EACFR,EAAc3B,QAAQmC,KAAOA,SAEtBR,EAAc3B,QAAQmC,KAI7BR,EAAcxJ,iBADHkK,IAAT3I,EAC0B,oBAEAA,CAEhC,CAoFA,SAAS4I,EAAiB1V,EAAuBC,EAA6C0V,GAC5F,MAAM5V,YAAEA,EAAW6V,OAAEA,EAAMC,UAAEA,GAAcF,EACrC7U,EAAQb,EAAOc,WAErB,IAAKD,EAAO,OAEZ,MAAMkC,EAAUjD,EAAYkD,IAAKuJ,IAAM,CACrCpJ,gBAAiBoJ,EAAEpJ,gBACnBP,YAAa2J,EAAE3J,YACfQ,cAAemJ,EAAEnJ,cACjBN,UAAWyJ,EAAEzJ,UACbN,QAAS+J,EAAE/J,QACXE,SAAyB,YAAf6J,EAAE7J,SACR3C,EAAOsD,eAAeC,QACtBvD,EAAOsD,eAAeE,SAQ5B,GALAxD,EAAOC,OAAOwD,gBAAgB3C,EAAO,iBAAkBkC,GAnGzD,SAAyB6S,GACvB,MAAMpO,EAAY2B,SAAS0L,eAAe,wBAC1C,GAAKrN,EAAL,CAEA,IAAKoO,EAYH,OAVApO,EAAU+B,MAAMC,QAAU,OACtB0L,GACFA,EAAoBlN,QAElBmN,GACFA,EAAanN,aAEXoN,GACFA,EAAUpN,SAMdR,EAAU+B,MAAMC,QAAU,OAGtB0L,GACFA,EAAoBnN,OAAO6N,GAIzBT,GACFA,EAAanN,QAEXoN,GACFA,EAAUpN,OA9BI,CAgClB,CAoEE6N,CAAgBD,GAEW,IAAvB9V,EAAY4K,OAGd,OAFA2K,EAAW,UAAW,gBACtBE,EAAkBI,GAAQpE,aAAUiE,EAAW,WAIjD,MAAMM,EAAUhW,EAAY,GACtBwV,EAA4B,YAArBQ,EAAQpT,SAAyB,UAAY,QAG1D2S,EAFuB,YAATC,EAAqB,UAAY,QAE7BA,GAElBC,EAAkB,GADD,QAAQO,EAAQ3S,wBAAwB2S,EAAQlT,kBAC/BkT,EAAQtT,UAAW8S,EACvD,CAgMA,SAASvU,EAA4CuF,EAAOC,GAC1D,IAAIC,EACJ,OAAO,YAAiCuP,GACtCtP,OAAOC,aAAaF,GACpBA,EAASC,OAAO5B,WAAW,IAAMyB,EAAG0P,MAAMtW,KAAMqW,GAAOxP,EACzD,CACF,EA1CA0P,iBACOxP,OAAOyP,SAKZzP,OAAOyP,QAAQzO,OAAO,CACpB0O,MAAO,CACLC,GAAI,8DAIR3P,OAAOyP,QAAQ,CAAC,yBAA0BD,UACxChB,EAAYxO,OAAO1G,OACnB,MAAMC,EAzHV,SAA0BD,INtHpB,SAA8BA,GAElCA,EAAOwB,UAAU8U,SAAS,CAAEpM,GAAI,QAGhClK,EAAOwB,UAAU+U,yBAAyB,MAAO,CAC/CC,SAAU,CACRC,YAAa,IACbC,aAAc,CAAC,KAAM,OAEvBC,SAAU,CACR,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,MAERC,iBAAkB,CAChB,CAAEC,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,MAEtBC,iBAAkB,CAChB,CAAEF,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,QAKxB9W,EAAOwB,UAAUwV,yBAAyB,MAAO,CAC/CC,aAAc,GACdC,aAAc,OAEdC,SAAU,CACR,SAAU,IAAK,KAAM,IAAK,QAAS,IACnC,SAAU,QAAS,MAAO,aAC1B,oBAAqB,OACrB,IAAK,WAAY,MAAO,OAAQ,OAAQ,MAAO,SAC/C,OAAQ,OAAQ,MAAO,OAAQ,MAAO,MACtC,UAAW,UAAW,WACtB,WAAY,WACZ,UAAW,UACX,aACA,UAAW,QAAS,OAAQ,OAAQ,OACpC,OAAQ,QAAS,aACjB,SAAU,SAGZC,UAAW,CACT,KAAM,IAAK,IAAK,MAIlBC,QAAS,sBAGTC,UAAW,CACTlP,KAAM,CAEJ,CAAEmP,QAAS,eAGX,CAAC,8EAA+E,WAGhF,CAAC,qCAAsC,CACrCC,MAAO,CACL,YAAa,UACb,WAAY,gBAKhB,CAAC,MAAO,UAGR,CAAC,kBAAmB,kBACpB,CAAC,IAAK,SAAU,WAGhB,CAAC,kCAAmC,iBAGpC,CAAC,UAAW,aACZ,CAAC,WAAY,CACXA,MAAO,CACL,aAAc,WACd,WAAY,OAKlBC,WAAY,CACV,CAAC,aAAc,SACf,CAAC,OAAQ,WACT,CAAC,MAAO,UAAW,aAGrBC,QAAS,CACP,CAAC,SAAU,WACX,CAAC,MAAO,UAAW,QACnB,CAAC,OAAQ,YAGXC,OAAQ,CACN,CAAC,UAAW,UACZ,CAAC,MAAO,iBACR,CAAC,IAAK,SAAU,WAIxB,CMQEC,CAAoB5X,GAEpB,MAAMC,EAASD,EAAOC,OAAO4X,OAAOzO,SAAS0L,eAAe,UAAY,CACtE/Q,MAAO6Q,EACPkD,SAAU,MACVC,MAAO,UACPC,iBAAiB,EACjBC,QAAS,CACPC,SAAS,GAEXC,UAAW,CACTC,SAAU,OACVC,WAAY,OACZC,YAAY,EACZC,sBAAuB,EACvBC,mBAAoB,GAEtBvP,QAAS,CAAEwP,IAAK,IAChBC,SAAU,GACVC,WAAY,kDACZC,iBAAiB,IAGnBpD,EAAkBZ,EAAcpD,QAChC8D,EAAW,sBAAuB,WAElC,MAAMuD,EAAY7X,EAAU8L,IACC,IAAvBA,EAAK0E,OAAO7G,QACd2K,EAAW,qBAAsB,WACjCE,OAAkBC,KAElBH,EAAW,kBAAmB,WAC9BE,EAAkB,gBAEnB,KAEGsD,EAAmB9X,EAAU8L,IACjCwI,EAAW,kBAAmB,WAC1BN,GACFA,EAAkB7T,YAAY,CAC5Bb,KAAM,UACNqV,QAAS,CAAE1U,OAAQ6L,MAGtB,KAQH,OANA7M,EAAOoB,wBAAwB,KAC7B,MAAM0X,EAAU9Y,EAAOiB,WACvB2X,EAAUE,GACVD,EAAiBC,KAGZ9Y,CACT,CAkEmB+Y,CAAiB9D,GAChCF,EAzKJ,SAA+B/U,GAC7B,KAAM,WAAYyG,QAEhB,OADA4O,EAAW,2CAA4C,WAChD,KAGT,MAAM1V,EAAS,IAAIO,OAAO,wBAAyB,CAAEG,KAAM,WAuB3D,OAtBAV,EAAOW,UAAYC,IACjB,MAAMF,KAAEA,EAAIqV,QAAEA,GAAYnV,EAAME,KACnB,gBAATJ,GAA0B4U,GAC5BQ,EAAiBR,EAAWjV,EAAQ0V,IAIxC/V,EAAOe,QAAWC,IAChBC,QAAQD,MAAM,sBAAuBA,GACrCC,QAAQD,MAAM,iBAAkB,CAC9B6B,QAAS7B,EAAM6B,QACfwW,SAAUrY,EAAMqY,SAChBC,OAAQtY,EAAMsY,OACdC,MAAOvY,EAAMuY,QAEf7D,EAAW,8BAA+B,SAC1CE,EACE,qEAAqE5U,EAAM6B,SAAW,kBACtF,UAIG7C,CACT,CA2IwBwZ,CAAsBnZ,GAxC9C,SAAiCA,GAC/B,MAAMoZ,EAASjQ,SAAS0L,eAAe,kBAElCuE,IAGLC,OAAOC,KAAK5U,GAAUvC,QAAQmN,IAC5B,MAAMiK,EAASpQ,SAAS2F,cAAc,UACtCyK,EAAOzV,MAAQwL,EACfiK,EAAOjO,YAAcgE,EACrB8J,EAAOzP,YAAY4P,KAIrBH,EAAOtV,MAAQ,cAGfsV,EAAOzU,iBAAiB,SAAWkN,IACjC,MAAM2H,EAAe3H,EAAEtD,OAA6BzK,MAChD0V,GAAe9U,EAAS8U,IAC1BxZ,EAAOyZ,SAAS/U,EAAS8U,MAG/B,CAkBIE,CAAwB1Z,GAlE5B,SAA8BA,GAC5B,MAAM2Z,EAAUxQ,SAAS0L,eAAe,YAEnC8E,GAELA,EAAQhV,iBAAiB,QAASsR,UAChC,MAAM2D,EAAO5Z,EAAOiB,WACpB,UACQ4Y,UAAUC,UAAUC,UAAUH,GACpCD,EAAQrO,YAAc,UACtBqO,EAAQxG,QAAQ6G,OAAS,OACzBnV,WAAW,KACT8U,EAAQrO,YAAc,cACfqO,EAAQxG,QAAQ6G,QACtB,KACL,CAAE,MAAOC,GACPrZ,QAAQD,MAAM,kBAAmBsZ,GACjCN,EAAQrO,YAAc,SACtBzG,WAAW,KACT8U,EAAQrO,YAAc,QACrB,KACL,GAEJ,CA4CI4O,CAAqBla,GA9PzB,WACE,MAAMma,EAAkBhR,SAAS0L,eAAe,qBAC1CuF,EAAmBjR,SAAS0L,eAAe,uBAC3CwF,EAAgBlR,SAAS0L,eAAe,oBACxCyF,EAAYnR,SAAS0L,eAAe,qBACpCrN,EAAY2B,SAAS0L,eAAe,wBAErCsF,GAAoBC,GAAqBC,GAK9CnF,EAAsB,IAAI3N,EAAoB4S,GAC9ChF,EAAe,IAAIzG,EAAa0L,GAChChF,EAAY,IAAId,EAAU+F,GAG1BnF,EAAoBrN,gBAAiBmC,IAC/BmL,GACFA,EAAa3L,QAAQQ,GAEnBoL,GACFA,EAAU5L,QAAQQ,GAEhBkL,GACFA,EAAoBhH,cAAclE,EAAKC,MAKvCqQ,GAAa9S,GACf8S,EAAU3V,iBAAiB,QAAS,KAClC,MAAMmU,EAAUtR,EAAUgH,cAAc,uBACpCsK,IAC4B,SAA1BA,EAAQvP,MAAMC,SAChBsP,EAAQvP,MAAMC,QAAU,OACxB8Q,EAAUhP,YAAc,SAExBwN,EAAQvP,MAAMC,QAAU,OACxB8Q,EAAUhP,YAAc,YA/B9B1K,QAAQ2Z,KAAK,kCAoCjB,CAmNIC,GAGIvF,SA/IRgB,eAA6BwE,EAA0Bza,GACrD,IACMgV,GAAaA,EAAUzS,mBACnByS,EAAU/S,OAGlB+S,EAAY,IAAI1V,EAAkBmb,EAAWza,SACvCgV,EAAU/U,QAChBW,QAAQ4K,IAAI,sCACd,CAAE,MAAO7K,GACPC,QAAQD,MAAM,mCAAoCA,GAClD0U,EAAW,2BAA4B,UACzC,CACF,CAmIYqF,CAAczF,EAAWjV,GAG7B+U,GACFA,EAAkB7T,YAAY,CAC5Bb,KAAM,UACNqV,QAAS,CAAE1U,OAAQhB,EAAOiB,cAI7BwF,OAAekU,YAAc3a,KA9B9BY,QAAQD,MAAM,8BAgClB,CAUAia"}
</file>

<file path="eslint.config.js">
import js from '@eslint/js';
import tseslint from 'typescript-eslint';
import globals from 'globals';

export default [
  js.configs.recommended,
  ...tseslint.configs.recommended,
  {
    files: ['**/*.{js,ts,tsx}'],
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.browser,
        ...globals.es2021,
      },
    },
    rules: {
      // Add custom rules here
      '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
      '@typescript-eslint/no-explicit-any': 'warn',
      'no-console': 'warn',
    },
  },
  {
    files: ['**/__tests__/**/*', '**/*.test.{js,ts,tsx}'],
    languageOptions: {
      globals: {
        ...globals.jest,
      },
    },
  },
  {
    ignores: ['dist/**', 'node_modules/**', '*.config.js'],
  },
];
</file>

<file path="jest.config.json">
{
  "preset": "ts-jest/presets/default-esm",
  "testEnvironment": "node",
  "extensionsToTreatAsEsm": [".ts"],
  "moduleNameMapper": {
    "^(\\.{1,2}/.*)\\.js$": "$1"
  },
  "transform": {
    "^.+\\.tsx?$": ["ts-jest", {
      "useESM": true,
      "tsconfig": {
        "noImplicitAny": false
      }
    }]
  },
  "testMatch": [
    "**/__tests__/**/*.ts",
    "**/?(*.)+(spec|test).ts"
  ],
  "collectCoverageFrom": [
    "src/**/*.ts",
    "!src/**/*.d.ts",
    "!src/**/__tests__/**"
  ]
}
</file>

<file path="docs/pie_language/pie_language_spec.md">
# Pie Language Specification

Pie is a dependently-typed programming language based on "The Little Typer" book. This document describes the syntax and semantics for generating valid Pie expressions.

## Basic Syntax

### Numbers (Literals)
- Numeric literals: `0`, `1`, `2`, `3`, `4`, `5`, etc. are shorthand for Nat constructors
- `0` is equivalent to `zero`
- `1` is equivalent to `(add1 zero)`
- `2` is equivalent to `(add1 (add1 zero))`

### Variables
- Variable names: alphanumeric identifiers, can include hyphens: `x`, `my-var`, `n-1`, `vec-length`
- Variables are introduced by lambda parameters, Pi parameters, or definitions

### Type Annotations
When explicit type annotation is needed, use `(the Type value)`:
```
(the Nat zero)
(the Atom 'foo)
(the (List Nat) nil)
```

## Core Types

### Nat (Natural Numbers)
- The type of natural numbers
- Syntax: `Nat`

### Atom
- The type of quoted symbols
- Syntax: `Atom`

### Trivial
- The unit type with only one value
- Syntax: `Trivial`

### Absurd
- The empty type with no values
- Syntax: `Absurd`

### U (Universe)
- The type of types
- Syntax: `U`

### → (Arrow/Function Type)
Non-dependent function type shorthand:
```
(-> A B)           ; A → B
(-> A B C)         ; A → B → C (curried)
```

### Π (Pi Type)
Dependent function type with explicit parameter names:
```
(Π ((x A)) B)                    ; Π(x:A). B
(Π ((x A) (y B)) C)             ; Π(x:A)(y:B). C
```

### Pair (Sigma Type)
Non-dependent pair type shorthand:
```
(Pair A D)         ; Σ(a:A). D
```

### Σ (Sigma Type)
Dependent pair type with explicit parameter names:
```
(Σ ((x A)) B)                    ; Σ(x:A). B
(Σ ((x A) (y B)) C)             ; Σ(x:A)(y:B). C
```

### List
Polymorphic list type:
```
(List A)           ; List of elements of type A
```

### Vec
Length-indexed vector type:
```
(Vec E n)          ; Vector of elements of type E with length n (where n is a Nat)
```

### Either
Sum type (disjoint union):
```
(Either L R)       ; Either left (type L) or right (type R)
```

### = (Equality Type)
Propositional equality:
```
(= T from to)      ; Proof that from equals to, both of type T
```

## Constructors

### Nat Constructors
- `zero`: The number 0
- `(add1 n)`: The successor of n

### Atom Constructors
- `'symbol`: A quoted symbol, e.g., `'foo`, `'bar`, `'pea`, `'olive`

### Trivial Constructor
- `sole`: The only value of type Trivial

### Pair/Sigma Constructors
- `(cons a d)`: Construct a pair with car `a` and cdr `d`

### List Constructors
- `nil`: Empty list (requires type annotation: `(the (List T) nil)`)
- `(:: head tail)`: Cons cell with head and tail

### Vec Constructors
- `vecnil`: Empty vector (requires type annotation: `(the (Vec E zero) vecnil)`)
- `(vec:: head tail)`: Vector cons with head element and tail vector

### Either Constructors
- `(left x)`: Left injection into Either type
- `(right y)`: Right injection into Either type

### Equality Constructor
- `same`: Reflexivity proof for equality (when both sides are definitionally equal)
- `(same x)`: Explicit reflexivity proof at value x

### Function Constructor
- `(λ (x) body)`: Lambda function (can also write as `lambda`)
- `(λ (x y) body)`: Multi-parameter lambda (curried: `(λ (x) (λ (y) body))`)

## Eliminators

### Nat Eliminators
- `(ind-Nat target motive base step)`: Induction on natural numbers
  - `target`: The Nat being analyzed
  - `motive`: `(λ (k) T)` - function from Nat to type
  - `base`: Value for zero case
  - `step`: `(λ (n-1 ih) ...)` - function taking predecessor and inductive hypothesis

- `(rec-Nat target base step)`: Recursion (simpler than ind-Nat)
  - Similar to ind-Nat but motive is implicit (always returns same type)

- `(iter-Nat target base step)`: Iteration (simplest)
  - `step`: `(λ (x) ...)` - function taking only result of previous iteration

- `(which-Nat target base step)`: Case analysis (if zero then base, else step)
  - `step`: `(λ (n-1) ...)` - function taking predecessor only

### List Eliminators
- `(ind-List target motive base step)`: Induction on lists
  - `target`: The list being analyzed
  - `motive`: `(λ (xs) T)` - function from list to type
  - `base`: Value for nil case
  - `step`: `(λ (head tail ih) ...)` - head, tail, and inductive hypothesis

- `(rec-List target base step)`: Recursion on lists
  - Similar structure to ind-List

### Vec Eliminators
- `(ind-Vec length target motive base step)`: Induction on vectors
  - `length`: The length (Nat) of the vector
  - `target`: The vector being analyzed
  - `motive`: Function taking length and vector to type
  - `base`: Value for vecnil case
  - `step`: Function for vec:: case

- `head`: Get first element of non-empty vector
- `tail`: Get rest of non-empty vector (one element shorter)

### Pair/Sigma Eliminators
- `(car p)`: First projection (get first element of pair)
- `(cdr p)`: Second projection (get second element of pair)

### Either Eliminators
- `(ind-Either target motive on-left on-right)`: Case analysis on Either
  - `target`: The Either value
  - `motive`: `(λ (e) T)` - function from Either to type
  - `on-left`: `(λ (x) ...)` - handler for left case
  - `on-right`: `(λ (y) ...)` - handler for right case

### Absurd Eliminator
- `(ind-Absurd target motive)`: Ex falso quodlibet (from false, anything follows)

### Equality Eliminators
- `(replace proof motive base)`: Use equality proof to convert types
  - `proof`: A proof of `(= T from to)`
  - `motive`: `(λ (x) T)` - how the type depends on the value
  - `base`: Value of type `(motive from)`, returns value of type `(motive to)`

## Function Application
- `(f x)`: Apply function f to argument x
- `(f x y)`: Apply f to x and y (curried: `((f x) y)`)

## Top-Level Definitions
- `(claim name type)`: Declare a name with a type
- `(define name value)`: Define the value for a previously claimed name
- `(define-tactically name tactics)`: Define using tactics (for proof mode)

## Comments
Lines can be omitted or preceded with `;` for comments (though not used in generation).

## Key Rules

1. **Empty collections need type annotations**: `(the (List Nat) nil)`, `(the (Vec Atom zero) vecnil)`
2. **Variables must be in scope**: Use only variables from the context or introduced by lambdas
3. **Type consistency**: The generated expression must match the expected type
4. **Constructor arity**: Each constructor takes a specific number of arguments
5. **Eliminator structure**: Eliminators have fixed parameter patterns (target, motive, cases)
</file>

<file path="src/language_server/server/src/server.ts">
import {
	createConnection,
	TextDocuments,
	Diagnostic,
	DiagnosticSeverity,
	ProposedFeatures,
	InitializeParams,
	DidChangeConfigurationNotification,
	CompletionItem,
	CompletionItemKind,
	TextDocumentPositionParams,
	TextDocumentSyncKind,
	InitializeResult,
	DocumentDiagnosticReportKind,
	type DocumentDiagnosticReport,
	Hover,
	HoverParams,
	MarkupKind,
	Location,
	Position,
	DefinitionParams,
} from 'vscode-languageserver/node';

import { PIE_HOVER_INFO } from './pie_hover_info';

import {
	TextDocument
} from 'vscode-languageserver-textdocument';

import { pieDeclarationParser, Declaration, Claim, Definition, DefineTactically, schemeParse } from '../../../pie_interpreter/parser/parser';
import { Context, initCtx, addClaimToContext, addDefineToContext } from '../../../pie_interpreter/utils/context';
import { go, stop } from '../../../pie_interpreter/types/utils';
import { ProofManager } from '../../../pie_interpreter/tactics/proofmanager';


// Interface for type checking results
interface TypeCheckResult {
    diagnostics: Diagnostic[];
    context: Context;
}

// Interface to store symbol definition information
interface SymbolDefinition {
	name: string;
	location: Location;
	type: 'claim' | 'define' | 'define-tactically';
	typeInfo?: string;
}

// Create a connection for the server
const connection = createConnection(ProposedFeatures.all);


// Create a simple text document manager.
const documents: TextDocuments<TextDocument> = new TextDocuments(TextDocument);

let hasConfigurationCapability = false;
let hasWorkspaceFolderCapability = false;

// Track user-defined symbols per document for go-to-definition and hover
const symbolDefinitions = new Map<string, Map<string, SymbolDefinition>>();

connection.onInitialize((params: InitializeParams) => {
	const capabilities = params.capabilities;

	// Does the client support the `workspace/configuration` request?
	// If not, we fall back using global settings.
	hasConfigurationCapability = !!(
		capabilities.workspace && !!capabilities.workspace.configuration
	);
	hasWorkspaceFolderCapability = !!(
		capabilities.workspace && !!capabilities.workspace.workspaceFolders
	);

	const result: InitializeResult = {
		capabilities: {
			textDocumentSync: TextDocumentSyncKind.Incremental,
			// Tell the client that this server supports code completion.
			completionProvider: {
				resolveProvider: true,
				triggerCharacters: ['(', ' '] // Trigger character
			},
			// Supports hover
			hoverProvider: true,

			// Definition provider
			definitionProvider: true,
			diagnosticProvider: {
				interFileDependencies: false,
				workspaceDiagnostics: false
			}
		}
	};
	if (hasWorkspaceFolderCapability) {
		result.capabilities.workspace = {
			workspaceFolders: {
				supported: true
			}
		};
	}
	return result;
});

connection.onInitialized(() => {
	if (hasConfigurationCapability) {
		// Register for all configuration changes.
		connection.client.register(DidChangeConfigurationNotification.type, undefined);
	}
	if (hasWorkspaceFolderCapability) {
		connection.workspace.onDidChangeWorkspaceFolders(_event => {
			connection.console.log('Workspace folder change event received.');
		});
	}
});


interface Settings {
	maxNumberOfProblems: number;
}


// Cache the settings of all open documents
const documentSettings = new Map<string, Thenable<Settings>>();

// Track user-defined symbols per document
const documentSymbols = new Map<string, Map<string, CompletionItem>>();

connection.onDidChangeConfiguration(_change => {
	if (hasConfigurationCapability) {
		// Reset all cached document settings
		documentSettings.clear();
	}
	// Refresh the diagnostics since the `maxNumberOfProblems` could have changed.
	// We could optimize things here and re-fetch the setting first can compare it
	// to the existing setting, but this is out of scope for this example.
	connection.languages.diagnostics.refresh();
});


// The content of a text document has changed. This event is emitted
// when the text document first opened or when its content has changed.
documents.onDidChangeContent(change => {
	connection.console.log('Document content changed');
	
	// Extract user-defined symbols for completion
	const symbols = extractUserDefinedSymbols(change.document);
	documentSymbols.set(change.document.uri, symbols);
	
	// Extract symbol definitions for go-to-definition and hover
	const definitions = extractSymbolDefinitions(change.document);
	symbolDefinitions.set(change.document.uri, definitions);
	
	// Perform type checking and send diagnostics
	validateTextDocument(change.document);
});


// Only keep settings for open documents
documents.onDidClose(e => {
	documentSettings.delete(e.document.uri);
	documentSymbols.delete(e.document.uri);
	symbolDefinitions.delete(e.document.uri);
});

// Extract symbols when document is opened
documents.onDidOpen(change => {
	connection.console.log('Document opened: ' + change.document.uri);

	// Extract user-defined symbols for completion
	const symbols = extractUserDefinedSymbols(change.document);
	documentSymbols.set(change.document.uri, symbols);

	// Extract symbol definitions for go-to-definition and hover
	const definitions = extractSymbolDefinitions(change.document);
	symbolDefinitions.set(change.document.uri, definitions);

	// Perform initial validation
	validateTextDocument(change.document);
});



// Parse document to extract user-defined symbols
function extractUserDefinedSymbols(document: TextDocument): Map<string, CompletionItem> {
	const text = document.getText();
	const symbols = new Map<string, CompletionItem>();
	
	// Regular expressions for Pie constructs
	const definePattern = /\(define\s+([a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*)/g;
	const claimPattern = /\(claim\s+([a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*)\s+(.+?)\)/g;
	const defineTacticallyPattern = /\(define-tactically\s+([a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*)/g;
	
	// Extract define symbols
	let match: RegExpExecArray | null;
	while ((match = definePattern.exec(text)) !== null) {
		const symbolName = match[1];
		symbols.set(symbolName, {
			label: symbolName,
			kind: CompletionItemKind.Function,
			detail: 'User-defined function'
		});
	}
	
	// Extract claim symbols
	while ((match = claimPattern.exec(text)) !== null) {
		const symbolName = match[1];
		const typeSpec = match[2];
		symbols.set(symbolName, {
			label: symbolName,
			kind: CompletionItemKind.Variable,
			detail: `Claimed type: ${typeSpec}`
		});
	}
	
	// Extract define-tactically symbols
	while ((match = defineTacticallyPattern.exec(text)) !== null) {
		const symbolName = match[1];
		symbols.set(symbolName, {
			label: symbolName,
			kind: CompletionItemKind.Function,
			detail: 'Tactically defined function'
		});
	}
	
	return symbols;
}

// Extract symbol definitions for go-to-definition and hover
function extractSymbolDefinitions(document: TextDocument): Map<string, SymbolDefinition> {
	const text = document.getText();
	const lines = text.split('\n');
	const symbols = new Map<string, SymbolDefinition>();
	
	// Regular expressions for Pie constructs with line tracking
	const definePattern = /\(define\s+([a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*)/;
	const claimPattern = /\(claim\s+([a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*)\s+(.+?)\)/;
	const defineTacticallyPattern = /\(define-tactically\s+([a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*)/;
	
	lines.forEach((line, lineIndex) => {
		// Check for define
		let match = definePattern.exec(line);
		if (match) {
			const symbolName = match[1];
			const startCol = line.indexOf(symbolName);
			symbols.set(symbolName, {
				name: symbolName,
				location: {
					uri: document.uri,
					range: {
						start: { line: lineIndex, character: startCol },
						end: { line: lineIndex, character: startCol + symbolName.length }
					}
				},
				type: 'define'
			});
		}
		
		// Check for claim
		match = claimPattern.exec(line);
		if (match) {
			const symbolName = match[1];
			const typeSpec = match[2];
			const startCol = line.indexOf(symbolName);
			symbols.set(symbolName, {
				name: symbolName,
				location: {
					uri: document.uri,
					range: {
						start: { line: lineIndex, character: startCol },
						end: { line: lineIndex, character: startCol + symbolName.length }
					}
				},
				type: 'claim',
				typeInfo: typeSpec
			});
		}
		
		// Check for define-tactically
		match = defineTacticallyPattern.exec(line);
		if (match) {
			const symbolName = match[1];
			const startCol = line.indexOf(symbolName);
			symbols.set(symbolName, {
				name: symbolName,
				location: {
					uri: document.uri,
					range: {
						start: { line: lineIndex, character: startCol },
						end: { line: lineIndex, character: startCol + symbolName.length }
					}
				},
				type: 'define-tactically'
			});
		}
	});
	
	return symbols;
}

// Get word at cursor position
function getWordAtPosition(document: TextDocument, position: Position): string | null {
	const text = document.getText();
	const lines = text.split('\n');

	if (position.line >= lines.length) {
		return null;
	}

	const line = lines[position.line];
	const character = position.character;

	if (character >= line.length) {
		return null;
	}

	// Define what constitutes an identifier in Pie
	const identifierRegex = /[a-zA-Z0-9_\-!?*+=<>λΠΣ→]/;

	// Find the start of the word
	let start = character;
	while (start > 0 && identifierRegex.test(line[start - 1])) {
		start--;
	}

	// Find the end of the word
	let end = character;
	while (end < line.length && identifierRegex.test(line[end])) {
		end++;
	}

	// Return the word if it's not empty and starts with a letter
	const word = line.substring(start, end);
	if (word.length > 0 && /[a-zA-Z]/.test(word[0])) {
		return word;
	}

	return null;
}

// Get word at position with range information
function getWordAndRange(document: TextDocument, position: Position): { word: string, start: number, end: number, cursorOffset: number } | null {
	const text = document.getText();
	const lines = text.split('\n');

	if (position.line >= lines.length) {
		return null;
	}

	const line = lines[position.line];
	const character = position.character;

	// Define what constitutes an identifier in Pie
	const identifierRegex = /[a-zA-Z0-9_\-!?*+=<>λΠΣ→]/;

	// Find the start of the word
	let start = character;
	while (start > 0 && identifierRegex.test(line[start - 1])) {
		start--;
	}

	// Find the end of the word
	let end = character;
	while (end < line.length && identifierRegex.test(line[end])) {
		end++;
	}

	if (start === end) {
		return null;
	}

	return {
		word: line.substring(start, end),
		start,
		end,
		cursorOffset: character - start
	};
}

// Hover handler
connection.onHover((params: HoverParams): Hover | null => {
	connection.console.log(`Hover requested at ${params.position.line}:${params.position.character}`);
	
	const document = documents.get(params.textDocument.uri);
	if (!document) {
		return null;
	}
	
	const word = getWordAtPosition(document, params.position);
	if (!word) {
		return null;
	}
	
	connection.console.log(`Hovering over word: "${word}"`);
	
	// Check for user-defined symbol first
	const currentDocSymbols = symbolDefinitions.get(params.textDocument.uri);
	let definition: SymbolDefinition | undefined;
	
	if (currentDocSymbols && currentDocSymbols.has(word)) {
		definition = currentDocSymbols.get(word);
	} else {
		// Check other documents
		for (const [, symbols] of symbolDefinitions) {
			if (symbols.has(word)) {
				definition = symbols.get(word);
				break;
			}
		}
	}
	
	if (definition) {
		let hoverText = `**${word}**\n\n`;
		hoverText += `Type: ${definition.type}\n`;
		
		if (definition.typeInfo) {
			hoverText += `Signature: \`${definition.typeInfo}\`\n`;
		}

		const fileName = definition.location.uri.split('/').pop() || definition.location.uri;
		hoverText += `Defined in: ${fileName}\n`;
		hoverText += `Location: Line ${definition.location.range.start.line + 1}, Column ${definition.location.range.start.character + 1}`;
		
		return {
			contents: {
				kind: MarkupKind.Markdown,
				value: hoverText
			}
		};
	}
	
	// Fall back to built-in hover info
	const hoverInfo = PIE_HOVER_INFO.get(word);
	if (hoverInfo) {
		let hoverContent = `**${word}**\n\n${hoverInfo.summary}`;
		
		if (hoverInfo.details) {
			hoverContent += `\n\n${hoverInfo.details}`;
		}
		
		if (hoverInfo.examples) {
			hoverContent += `\n\n**Examples:**\n\`\`\`pie\n${hoverInfo.examples}\n\`\`\``;
		}
		
		return {
			contents: {
				kind: MarkupKind.Markdown,
				value: hoverContent
			}
		};
	}
	
	// Check if it's a number
	if (/^\d+$/.test(word)) {
		return {
			contents: {
				kind: MarkupKind.Markdown,
				value: `**Natural number literal**\n\nRepresents the Nat value ${word}`
			}
		};
	}
	
	// Check if it's a quoted atom
	if (word.startsWith("'")) {
		return {
			contents: {
				kind: MarkupKind.Markdown,
				value: `**Quoted atom**\n\nType: \`Atom\`\n\nValue: \`${word}\``
			}
		};
	}
	
	return null;
});

// Handler for Go to Definition requests
connection.onDefinition((params: DefinitionParams): Location[] => {
	connection.console.log('===== GO TO DEFINITION TRIGGERED =====');
	connection.console.log(`Document: ${params.textDocument.uri}`);
	connection.console.log(`Position: ${params.position.line}:${params.position.character}`);
	
	const document = documents.get(params.textDocument.uri);
	if (!document) {
		connection.console.log('Document not found');
		return [];
	}
	
	// Get the word at the cursor position
	const word = getWordAtPosition(document, params.position);
	if (!word) {
		connection.console.log('No word found at position');
		return [];
	}
	
	connection.console.log(`Looking for definition of: ${word}`);
	
	// First, check the current document for definitions
	const currentDocSymbols = symbolDefinitions.get(params.textDocument.uri);
	if (currentDocSymbols && currentDocSymbols.has(word)) {
		const definition = currentDocSymbols.get(word)!;
		connection.console.log(`Found definition in current document: ${definition.type}`);
		return [definition.location];
	}

	// Then check all other documents (for workspace-wide definitions)
	for (const [documentUri, symbols] of symbolDefinitions) {
		if (documentUri !== params.textDocument.uri && symbols.has(word)) {
			const definition = symbols.get(word)!;
			connection.console.log(`Found definition in document ${documentUri}: ${definition.type}`);
			return [definition.location];
		}
	}
	
	connection.console.log(`No definition found for: ${word}`);
	return [];
});

// Built-in Pie completions
const PIE_COMPLETIONS: CompletionItem[] = [
	// Basic types
	{ label: 'Nat', kind: CompletionItemKind.TypeParameter, detail: 'Natural numbers' },
	{ label: 'Atom', kind: CompletionItemKind.TypeParameter, detail: 'Atomic values' },
	{ label: 'Universe', kind: CompletionItemKind.TypeParameter, detail: 'Type of types' },
	{ label: 'U', kind: CompletionItemKind.TypeParameter, detail: 'Type of types (short)' },
	
	// Constructors
	{ label: 'zero', kind: CompletionItemKind.Value, detail: 'Natural number zero' },
	{ label: 'add1', kind: CompletionItemKind.Function, detail: 'Add one to a natural number' },
	{ label: 'nil', kind: CompletionItemKind.Value, detail: 'Empty list' },
	{ label: '::', kind: CompletionItemKind.Function, detail: 'List constructor' },
	{ label: 'cons', kind: CompletionItemKind.Function, detail: 'Pair constructor' },
	{ label: 'same', kind: CompletionItemKind.Function, detail: 'Reflexivity of equality' },
	
	// Functions
	{ label: 'lambda', kind: CompletionItemKind.Keyword, detail: 'Anonymous function' },
	{ label: 'λ', kind: CompletionItemKind.Keyword, detail: 'Anonymous function (Unicode)' },
	{ label: 'the', kind: CompletionItemKind.Keyword, detail: 'Type annotation' },
	{ label: 'car', kind: CompletionItemKind.Function, detail: 'First element of pair' },
	{ label: 'cdr', kind: CompletionItemKind.Function, detail: 'Second element of pair' },
	
	// Dependent types
	{ label: 'Pi', kind: CompletionItemKind.TypeParameter, detail: 'Dependent function type' },
	{ label: 'Π', kind: CompletionItemKind.TypeParameter, detail: 'Dependent function type (Unicode)' },
	{ label: 'Sigma', kind: CompletionItemKind.TypeParameter, detail: 'Dependent pair type' },
	{ label: 'Σ', kind: CompletionItemKind.TypeParameter, detail: 'Dependent pair type (Unicode)' },
	
	// Type constructors
	{ label: 'List', kind: CompletionItemKind.TypeParameter, detail: 'List type constructor' },
	{ label: 'Pair', kind: CompletionItemKind.TypeParameter, detail: 'Pair type constructor' },
	{ label: '->', kind: CompletionItemKind.TypeParameter, detail: 'Function type' },
	{ label: '→', kind: CompletionItemKind.TypeParameter, detail: 'Function type (Unicode)' },
	{ label: '=', kind: CompletionItemKind.TypeParameter, detail: 'Equality type' },
	
	// Equality functions
	{ label: 'replace', kind: CompletionItemKind.Function, detail: 'Substitution of equals for equals' },
	{ label: 'trans', kind: CompletionItemKind.Function, detail: 'Transitivity of equality' },
	{ label: 'cong', kind: CompletionItemKind.Function, detail: 'Congruence of equality' },
	{ label: 'symm', kind: CompletionItemKind.Function, detail: 'Symmetry of equality' },
	
	// Special
	{ label: 'TODO', kind: CompletionItemKind.Snippet, detail: 'Placeholder for incomplete code' },
	
	// Top-level forms
	{ label: 'define', kind: CompletionItemKind.Keyword, detail: 'Define a function or value' },
	{ label: 'claim', kind: CompletionItemKind.Keyword, detail: 'Claim the type of a name' },
	{ label: 'define-tactically', kind: CompletionItemKind.Keyword, detail: 'Define using tactics' }
];

// This handler provides the initial list of completion items.
connection.onCompletion(
	(_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] => {
		const document = documents.get(_textDocumentPosition.textDocument.uri);
		if (!document) {
			return PIE_COMPLETIONS;
		}

		// Get the word at cursor for prefix filtering
		const wordInfo = getWordAndRange(document, _textDocumentPosition.position);
		const prefix = wordInfo ? wordInfo.word.substring(0, wordInfo.cursorOffset) : '';

		// Get user-defined symbols for this document
		const userSymbols = documentSymbols.get(_textDocumentPosition.textDocument.uri);

		// Combine built-in completions with user-defined symbols
		let allCompletions = userSymbols
			? [...PIE_COMPLETIONS, ...Array.from(userSymbols.values())]
			: PIE_COMPLETIONS;

		// Filter completions based on prefix
		if (prefix) {
			allCompletions = allCompletions.filter(item =>
				item.label.toLowerCase().startsWith(prefix.toLowerCase())
			);

			// Sort by relevance
			allCompletions.sort((a, b) => {
				const aLabel = a.label;
				const bLabel = b.label;

				// Exact match gets highest priority
				if (aLabel === prefix && bLabel !== prefix) return -1;
				if (bLabel === prefix && aLabel !== prefix) return 1;

				// Case-sensitive prefix match
				const aStartsWith = aLabel.startsWith(prefix);
				const bStartsWith = bLabel.startsWith(prefix);
				if (aStartsWith && !bStartsWith) return -1;
				if (bStartsWith && !aStartsWith) return 1;

				// Then sort alphabetically
				return aLabel.localeCompare(bLabel);
			});
		}

		// Add textEdit to replace the word range if we found one
		if (wordInfo) {
			allCompletions = allCompletions.map(item => ({
				...item,
				textEdit: {
					range: {
						start: { line: _textDocumentPosition.position.line, character: wordInfo.start },
						end: { line: _textDocumentPosition.position.line, character: wordInfo.end }
					},
					newText: item.label
				}
			}));
		}

		return allCompletions;
	}
);

// This handler resolves additional information for the item selected in the completion list.
connection.onCompletionResolve(
	(item: CompletionItem): CompletionItem => {
		return item;
	}
);

// Main function to type check a Pie document and return diagnostics
function typeCheckPieDocument(document: TextDocument): TypeCheckResult {
    const text = document.getText();
    const diagnostics: Diagnostic[] = [];
    let context = initCtx;
    
    try {
        // Parse the document into declarations
        const declarations = parsePieDeclarations(text);
        
        // Process each declaration
        for (const decl of declarations) {
            const declResult = processDeclaration(decl, context, document);
            diagnostics.push(...declResult.diagnostics);
            context = declResult.context;
        }
        
    } catch (error) {
        // Handle parsing errors - try to get location from error if available
        let range = { start: { line: 0, character: 0 }, end: { line: 0, character: 100 } };

        // Check if error has location information
        if (error && typeof error === 'object' && 'location' in error) {
            range = locationToRange((error as any).location);
        }

        const diagnostic: Diagnostic = {
            severity: DiagnosticSeverity.Error,
            range,
            message: `Parse error: ${error}`,
            source: 'Pie Language Server'
        };
        diagnostics.push(diagnostic);
    }
    
    return { diagnostics, context };
}

// Parse Pie declarations from text
function parsePieDeclarations(text: string): Declaration[] {
    const declarations: Declaration[] = [];

    // First parse with scheme parser to get AST nodes
    const astList = schemeParse(text);

    // Then parse each AST node as a declaration
    for (const ast of astList) {
        const declaration = pieDeclarationParser.parseDeclaration(ast);
        declarations.push(declaration);
    }
    
    return declarations;
}

// Helper function to convert Pie location to VS Code range
function locationToRange(location: any): { start: { line: number, character: number }, end: { line: number, character: number } } {
    if (location && location.syntax) {
        return {
            start: { line: location.syntax.start.line, character: location.syntax.start.column },
            end: { line: location.syntax.end.line, character: location.syntax.end.column }
        };
    }
    // Fallback to first line if no location info
    return {
        start: { line: 0, character: 0 },
        end: { line: 0, character: 10 }
    };
}

// Process a single declaration for type checking
function processDeclaration(decl: Declaration, context: Context, _document: TextDocument): TypeCheckResult {
    const diagnostics: Diagnostic[] = [];
    let newContext = context;

    try {
        if (decl instanceof Claim) {
            // Process claim declaration
            newContext = processClaimDeclaration(decl, context, diagnostics);
        } else if (decl instanceof Definition) {
            // Process define declaration
            newContext = processDefineDeclaration(decl, context, diagnostics);
        } else if (decl instanceof DefineTactically) {
            // Process define-tactically declaration
            newContext = processDefineTacticallyDeclaration(decl, context, diagnostics);
        } else {
            // Unknown declaration type or Source expression
            const range = (decl as any).location ? locationToRange((decl as any).location) : locationToRange(null);
            const diagnostic: Diagnostic = {
                severity: DiagnosticSeverity.Warning,
                range,
                message: `Unknown declaration type or unhandled expression`,
                source: 'Pie Language Server'
            };
            diagnostics.push(diagnostic);
        }
    } catch (error) {
        const range = (decl as any).location ? locationToRange((decl as any).location) : locationToRange(null);
        const diagnostic: Diagnostic = {
            severity: DiagnosticSeverity.Error,
            range,
            message: `Error processing declaration: ${error}`,
            source: 'Pie Language Server'
        };
        diagnostics.push(diagnostic);
    }

    return { diagnostics, context: newContext };
}

// Process claim declarations
function processClaimDeclaration(claim: Claim, context: Context, diagnostics: Diagnostic[]): Context {
    try {
        const result = addClaimToContext(context, claim.name, claim.location, claim.type);
        if (result instanceof go) {
            return result.result;
        } else if (result instanceof stop) {
            const diagnostic: Diagnostic = {
                severity: DiagnosticSeverity.Error,
                range: {
                    start: { line: result.where.syntax.start.line, character: result.where.syntax.start.column },
                    end: { line: result.where.syntax.end.line, character: result.where.syntax.end.column }
                },
                message: `${result.message}`,
                source: 'Pie Language Server'
            };
            diagnostics.push(diagnostic);
            return context;
        }
        return context;
    } catch (error) {
        const range = locationToRange(claim.location);
        const diagnostic: Diagnostic = {
            severity: DiagnosticSeverity.Error,
            range,
            message: `Error in claim '${claim.name}': ${error}`,
            source: 'Pie Language Server'
        };
        diagnostics.push(diagnostic);
        return context;
    }
}

// Process define declarations
function processDefineDeclaration(define: Definition, context: Context, diagnostics: Diagnostic[]): Context {
    try {
        const result = addDefineToContext(context, define.name, define.location, define.expr);
        if (result instanceof go) {
            return result.result;
        } else if (result instanceof stop) {
            const diagnostic: Diagnostic = {
                severity: DiagnosticSeverity.Error,
                range: {
                    start: { line: result.where.syntax.start.line, character: result.where.syntax.start.column },
                    end: { line: result.where.syntax.end.line, character: result.where.syntax.end.column }
                },
                message: `${result.message}`,
                source: 'Pie Language Server'
            };
            diagnostics.push(diagnostic);
            return context;
        }
        return context;
    } catch (error) {
        const range = locationToRange(define.location);
        const diagnostic: Diagnostic = {
            severity: DiagnosticSeverity.Error,
            range,
            message: `Error in definition '${define.name}': ${error}`,
            source: 'Pie Language Server'
        };
        diagnostics.push(diagnostic);
        return context;
    }
}

// Process define-tactically declarations
function processDefineTacticallyDeclaration(defineTactically: DefineTactically, context: Context, diagnostics: Diagnostic[]): Context {
    try {
        const proofManager = new ProofManager();

        // Start the proof
        const startResult = proofManager.startProof(defineTactically.name, context, defineTactically.location);
        if (startResult instanceof stop) {
            const diagnostic: Diagnostic = {
                severity: DiagnosticSeverity.Error,
                range: {
                    start: { line: startResult.where.syntax.start.line, character: startResult.where.syntax.start.column },
                    end: { line: startResult.where.syntax.end.line, character: startResult.where.syntax.end.column }
                },
                message: `${startResult.message}`,
                source: 'Pie Language Server'
            };
            diagnostics.push(diagnostic);
            return context;
        }

        // Apply each tactic
        for (const tactic of defineTactically.tactics) {
            const tacticResult = proofManager.applyTactic(tactic);
            if (tacticResult instanceof stop) {
                const diagnostic: Diagnostic = {
                    severity: DiagnosticSeverity.Error,
                    range: {
                        start: { line: tacticResult.where.syntax.start.line, character: tacticResult.where.syntax.start.column },
                        end: { line: tacticResult.where.syntax.end.line, character: tacticResult.where.syntax.end.column }
                    },
                    message: `Tactic error: ${tacticResult.message}`,
                    source: 'Pie Language Server'
                };
                diagnostics.push(diagnostic);
                return context;
            }
        }


        // TODO: Update this when ProofManager provides context access
        return context;
    } catch (error) {
        const range = locationToRange(defineTactically.location);
        const diagnostic: Diagnostic = {
            severity: DiagnosticSeverity.Error,
            range,
            message: `Error in tactical definition '${defineTactically.name}': ${error}`,
            source: 'Pie Language Server'
        };
        diagnostics.push(diagnostic);
        return context;
    }
}


async function validateTextDocument(textDocument: TextDocument): Promise<void> {
	// Perform type checking
	const result = typeCheckPieDocument(textDocument);
	// let problems = 0;
	const diagnostics: Diagnostic[] = [];

	// Add type checking diagnostics
	diagnostics.push(...result.diagnostics);
	// problems += result.diagnostics.length;

	// Send the computed diagnostics to VSCode.
	connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
}


connection.onDidChangeWatchedFiles(_change => {
	// Monitored files have change in VSCode
	connection.console.log('We received a file change event');
});


connection.onRequest('custom/documentSymbols', (params: { textDocument: { uri: string } }) => {
	const symbols = symbolDefinitions.get(params.textDocument.uri);
	if (symbols) {
		return Array.from(symbols.entries()).map(([name, def]) => ({
			name,
			type: def.type,
			location: def.location
		}));
	}
	return [];
});

// Diagnostic provider
connection.languages.diagnostics.on(async (params) => {
	const document = documents.get(params.textDocument.uri);
	if (document !== undefined) {
		const result = typeCheckPieDocument(document);
		return {
			kind: DocumentDiagnosticReportKind.Full,
			items: result.diagnostics
		} satisfies DocumentDiagnosticReport;
	} else {
		return {
			kind: DocumentDiagnosticReportKind.Full,
			items: []
		} satisfies DocumentDiagnosticReport;
	}
});

// Make the text document manager listen on the connection
// for open, change and close text document events
documents.listen(connection);

// Listen on the connection
connection.listen();
</file>

<file path="src/pie_interpreter/__tests__/test_ctor_debug.ts">
import 'jest';
import { evaluatePie } from '../main'

describe("Debug constructor with type params", () => {
  it("Just define the datatype and constructor", () => {
    const input =
    `(data Subtype () ((T1 U) (T2 U))
  (refl ((T U))
    (Subtype () (T T)))
  ind-Subtype)

;; Test: can we construct a refl?
(claim nat-refl (Subtype () (Nat Nat)))
(define nat-refl (refl Nat))`;
    const result = evaluatePie(input);
    console.log(result);
  })
})
</file>

<file path="src/pie_interpreter/__tests__/test_datatype_only.ts">
import 'jest';
import { evaluatePie } from '../main'

describe("Test datatype definition only", () => {
  it("Define Subtype", () => {
    const input = `
    (data Subtype () ((T1 U) (T2 U))
      (refl ((T U))
        (Subtype () (T T)))
      (trans ((T1 U) (T2 U) (T3 U)
              (p1 (Subtype () (T1 T2)))
              (p2 (Subtype () (T2 T3))))
        (Subtype () (T1 T3)))
      ind-Subtype)
    `;
    const result = evaluatePie(input);
    console.log("Success!");
  });
})
</file>

<file path="src/pie_interpreter/__tests__/test_sort.ts">
import 'jest';
import { evaluatePie } from '../main'

describe("Parser Evaluate Integration Tests", () => {

it("Evaluate MyVec (parameterized and indexed)", () => {
    const input = `
    (data MyList ((E U)) ()
      (myNil () (MyList (E) ()))
      (myCons ((head E) (tail (MyList (E) ()))) (MyList (E) ()))
      ind-MyList)

    (data Less-Than () ((j Nat) (k Nat))
      (zero-smallest ((n Nat)) (Less-Than () (zero (add1 n))))
      (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than () (j k)))) (Less-Than () ((add1 j) (add1 k))))
      ind-Less-Than)

    (data Sorted () ((xs (MyList (Nat) ())))
      (sorted-nil ()
        (Sorted () ((myNil))))
      (sorted-one ((x Nat))
        (Sorted () ((myCons x (myNil)))))
      (sorted-many ((x Nat) (y Nat) (rest (MyList (Nat) ()))
                    (x<=y (Less-Than () (x y)))
                    (sorted-rest (Sorted () ((myCons y rest)))))
        (Sorted () ((myCons x (myCons y rest)))))
  ind-Sorted)
    `;
    const result = evaluatePie(input);
    console.log(result)
  });
})
</file>

<file path="src/pie_interpreter/__tests__/test_telescope.ts">
import 'jest'
import { evaluatePie } from '../main';

describe('test_telescope', () => {
  it('test0', () =>
  console.log(evaluatePie(
    `
    (claim test (Pi ((A U) (x A)) A))`
  )))
})
</file>

<file path="src/pie_interpreter/__tests__/test_temp.ts">
import 'jest';

import { evaluatePie } from '../main'

describe("demo", () => {
    it("fact", () => {
        const src =
            `
    (claim add (-> Nat Nat Nat))
(define add (lambda (x y) (rec-Nat x y (lambda (n add-n-1) (add1 add-n-1)))))

(claim mult (-> Nat Nat Nat))
(define mult (lambda (x y) (rec-Nat x 0 (lambda (n mult-n-1) (add y mult-n-1)))))

(claim fact (-> Nat Nat))
(define fact
(lambda (n) (ind-Nat n (lambda (n) Nat)  (add1 0) (lambda (n fact-n-1) (mult (add1 n) fact-n-1)))))

(fact 5)`;
        console.log(evaluatePie(src));
    });

});
</file>

<file path="src/pie_interpreter/typechecker/represent.ts">
import * as C from '../types/core';
import * as V from '../types/value';

import { Context, valInContext } from '../utils/context';
import { Source } from '../types/source';
import { go, goOn, Perhaps, PerhapsM } from '../types/utils';
import { readBack } from '../evaluator/utils';
import { Location } from '../utils/locations';
import { convert } from './utils';

/**
 * Represent the expression in the context.
 */
export function represent(ctx: Context, expr: Source): Perhaps<C.Core> {
  const outmeta = new PerhapsM<C.The>('outmeta');
  return goOn([[outmeta, () => expr.synth(ctx, new Map())]],
    () => {
      const tv = valInContext(ctx, outmeta.value.type);
      const v = valInContext(ctx, outmeta.value.expr);
      return new go(
        new C.The(tv.readBackType(ctx), readBack(ctx, tv, v))
      );
    }
  );
}

export function normType(ctx: Context, src: Source): Perhaps<C.Core> {
  const eout = new PerhapsM<C.Core>('eout');
  return goOn(
    [[eout, () => src.isType(ctx, new Map())]],
    () => {
      return new go(valInContext(ctx, eout.value!).readBackType(ctx));
    }
  )
}

// (: check-same (-> Ctx Loc Src Src Src (Perhaps Void)))
// (define (check-same Γ loc t a b)
//   (go-on ((t-out (is-type Γ '() t))
//           (tv (go (val-in-ctx Γ t-out)))
//           (a-out (check Γ '() a tv))
//           (b-out (check Γ '() b tv))
//           (av (go (val-in-ctx Γ a-out)))
//           (bv (go (val-in-ctx Γ b-out))))
//     (convert Γ loc tv av bv)))

export function checkSame(ctx: Context, where: Location, t: Source, a: Source, b: Source): Perhaps<undefined> {
  const typeOut = new PerhapsM<C.Core>('tOut');
  const typeValue = new PerhapsM<V.Value>('tv');
  const leftOut = new PerhapsM<C.Core>('aOut');
  const rightOut = new PerhapsM<C.Core>('bOut');
  const leftValue = new PerhapsM<V.Value>('av');
  const rightValue = new PerhapsM<V.Value>('bv');
  return goOn(
    [
      [typeOut, () => t.isType(ctx, new Map())],
      [typeValue, () => new go(valInContext(ctx, typeOut.value))],
      [leftOut, () => a.check(ctx, new Map(), typeValue.value)],
      [rightOut, () => b.check(ctx, new Map(), typeValue.value)],
      [leftValue, () => new go(valInContext(ctx, leftOut.value))],
      [rightValue, () => new go(valInContext(ctx, rightOut.value))]
    ],
    () => {
      return convert(ctx, where, typeValue.value, leftValue.value, rightValue.value);
    }
  );
}
</file>

<file path="src/pie_interpreter/index.ts">
import { initialise } from "conductor/dist/conductor/runner/util/";
import { PieEvaluator } from './PieEvaluator';

initialise(PieEvaluator);
</file>

<file path="src/pie_interpreter/PieEvaluator.ts">
import { BasicEvaluator } from "conductor/dist/conductor/runner";
import { IRunnerPlugin } from "conductor/dist/conductor/runner/types";
import { evaluatePie } from "./main";

export class PieEvaluator extends BasicEvaluator {
  private executionCount: number;

  constructor(conductor: IRunnerPlugin) {
    super(conductor);
    this.executionCount = 0;
  }

  async evaluateChunk(chunk: string): Promise<void> {
    this.executionCount++;
    try {
      const result = evaluatePie(chunk);
      this.conductor.sendOutput(`Result of expression: execution ${result}`);
    } catch (error) {
      // Handle errors and send them to the REPL
      if (error instanceof Error) {
        this.conductor.sendOutput(`Error: ${error.message}`);
      } else {
        this.conductor.sendOutput(`Error: ${String(error)}`);
      }
    }

  }
}
</file>

<file path=".env.example">
# Google Gemini API Key for LLM TODO solver
# Get your API key from: https://ai.google.dev/gemini-api/docs/api-key
GOOGLE_API_KEY=your_google_api_key_here
</file>

<file path="LLM_SETUP.md">
# LLM TODO Solver Setup

This project uses Google's Gemini API for LLM-powered TODO solving in Pie code.

## Setup Instructions

1. **Get a Google Gemini API Key**
   - Visit: https://ai.google.dev/gemini-api/docs/api-key
   - Sign in with your Google account
   - Create a new API key

2. **Configure the API Key**
   - Copy `.env.example` to `.env`:
     ```bash
     cp .env.example .env
     ```
   - Edit `.env` and replace `your_google_api_key_here` with your actual API key:
     ```
     GOOGLE_API_KEY=your_actual_api_key_here
     ```

3. **Run Tests**
   ```bash
   npm test -- test_llm.ts
   ```

## Important Notes

- **Never commit `.env` file to git** - it's already in `.gitignore`
- The `.env.example` file is safe to commit (it has no real key)
- If you get an error about missing API key, make sure `.env` file exists and contains your key

## Free Tier Limits

Google Gemini free tier has rate limits:
- 10 requests per minute
- If you hit the limit, tests will fail with quota errors
- Wait a minute and try again

## Security

- Keep your API key private
- Don't share it in commits, screenshots, or public channels
- If accidentally exposed, regenerate a new key immediately
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "module": "ESNext",
        "moduleResolution": "node",
        "target": "ES2020",
        "lib": ["ES2022", "DOM"],
        "sourceMap": true,
        "outDir": "./dist",
        "rootDir": "./src",
        "strict": true,
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "skipLibCheck": true,
        "downlevelIteration": true,
        "resolveJsonModule": true,
        "declaration": true,
        "declarationMap": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist",
        "**/*.test.ts",
        "**/__tests__/**/*"
    ]
}
</file>

<file path="tsconfig.standalone.json">
{
    "compilerOptions": {
        "module": "CommonJS",
        "moduleResolution": "node",
        "target": "ES2020",
    "lib": ["ES2022", "DOM"],
        "sourceMap": true,
        "outDir": "./dist-standalone",
        "rootDir": "./src",
        "strict": false,
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "skipLibCheck": true,
        "downlevelIteration": true,
        "resolveJsonModule": true,
        "declaration": false,
        "noImplicitAny": false,
        "allowJs": true
    },
    "include": [
        "src/standalone.ts",
        "src/pie_interpreter/**/*",
        "src/scheme_parser/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist",
        "**/*.test.ts",
        "**/__tests__/**/*",
        "src/pie_interpreter/index.ts",
        "src/pie_interpreter/PieEvaluator.ts"
    ]
}
</file>

<file path="docs/pie_language/pie_examples.md">
# Pie Code Examples

Real working examples extracted from the test suite.

---

## Basic Types

### Nat Examples
```
zero
(add1 zero)
(add1 (add1 zero))
1
2
3
```

### Atom Examples
```
'foo
'bar
'pea
'olive
'oil
```

### Trivial Example
```
sole
```

---

## Function Examples

### Identity Function
```
(the (→ Nat Nat)
  (λ (x) x))
```

### Constant Function
```
(the (→ Nat Nat)
  (λ (x) zero))
```

### Two-Argument Function
```
(the (→ (→ Nat Nat) Nat Nat)
  (λ (f x) (f x)))
```

### Addition Using ind-Nat
```
(the (→ Nat Nat Nat)
  (λ (x y)
    (ind-Nat x
      (λ (k) Nat)
      y
      (λ (n-1 ih) (add1 ih)))))
```

### Addition Using iter-Nat
```
(the (→ Nat Nat Nat)
  (λ (x y)
    (iter-Nat x
      y
      (λ (prev) (add1 prev)))))
```

---

## Pair Examples

### Simple Pair
```
(the (Pair Atom Atom)
  (cons 'olive 'oil))
```

### Pair Projections
```
(car (the (Pair Atom Atom) (cons 'olive 'oil)))  ; Returns 'olive
(cdr (the (Pair Atom Atom) (cons 'olive 'oil)))  ; Returns 'oil
```

### Function with Pair
```
(the (→ Trivial (Pair Trivial Trivial))
  (λ (x) (cons x x)))
```

### Nested Pairs
```
(the (Pair Nat (Pair Atom Trivial))
  (cons zero (cons 'foo sole)))
```

---

## List Examples

### Empty List
```
(the (List Nat) nil)
```

### Single Element
```
(:: (add1 zero)
  (the (List Nat) nil))
```

### Multiple Elements
```
(:: (add1 (add1 (add1 zero)))
  (:: (add1 (add1 zero))
    (the (List Nat) nil)))
```

### List Recursion - Sum
```
(the (→ (List Nat) Nat)
  (λ (ns)
    (ind-List ns
      (λ (_) Nat)
      zero
      (λ (x y z)
        (ind-Nat x
          (λ (n) Nat)
          z
          (λ (_ q) (add1 q)))))))
```

---

## Vec Examples

### Empty Vector
```
(the (Vec Nat zero) vecnil)
```

### Vector Length 1
```
(vec:: zero (the (Vec Nat zero) vecnil))
```

### Vector Length 3
```
(vec:: zero
  (vec:: (add1 zero)
    (vec:: (add1 (add1 zero))
      (the (Vec Nat zero) vecnil))))
```

### First of Vector
```
(claim first
  (Π ((E U) (l Nat))
    (→ (Vec E (add1 l)) E)))

(define first
  (λ (E l es) (head es)))
```

### Rest of Vector
```
(claim rest
  (Π ((E U) (l Nat))
    (→ (Vec E (add1 l)) (Vec E l))))

(define rest
  (λ (E l es) (tail es)))
```

### Build Vector Using ind-Nat
```
(claim peas
  (Π ((how-many-peas Nat))
    (Vec Atom how-many-peas)))

(define peas
  (λ (how-many-peas)
    (ind-Nat how-many-peas
      (λ (k) (Vec Atom k))
      (the (Vec Atom zero) vecnil)
      (λ (l-1 peas-l-1)
        (vec:: 'pea peas-l-1)))))
```

---

## Either Examples

### Left Injection
```
(left zero)          ; Type: (Either Nat Atom)
```

### Right Injection
```
(right 'foo)         ; Type: (Either Nat Atom)
```

### Case Analysis
```
(λ (e)
  (ind-Either e
    (λ (_) Nat)
    (λ (n) n)
    (λ (a) zero)))
```

---

## Equality Examples

### Reflexivity
```
(the (= Nat zero zero)
  (same zero))
```

### Symmetry with replace
```
(the (Π ((n Nat) (m Nat))
       (→ (= Nat n m)
          (= Nat m n)))
  (λ (n m n=m)
    (replace n=m
      (λ (k) (= Nat k n))
      (same n))))
```

### Using replace
```
(replace (the (= Nat 4 4) (same 4))
  (λ (k) (= Nat k 4))
  (same 4))
```

### Congruence with ind-=
```
(λ (n-1 incr=add1n-1)
  (ind-= incr=add1n-1
    (λ (x proof-incr-n-1=x)
      (= Nat (add1 (incr n-1)) (add1 x)))
    (same (add1 (incr n-1)))))
```

---

## Dependent Type Examples

### Pi Type (Dependent Function)
```
(the (Π ((A U)) U)
  (λ (B) B))
```

### Multiple Dependent Parameters
```
(the (Π ((A U) (a A)) A)
  (λ (B b) b))
```

### Complex Dependent Function with Pair
```
(the (Π ((f (→ Nat U))
         (p (Σ ((n Nat)) (f n))))
       (f (car p)))
  (λ (f p) (cdr p)))
```

---

## User-Defined Inductive Types

### Bool Definition
```
(data Bool () ()
  (true () (Bool))
  (false () (Bool))
  ind-Bool)
```

### Bool Usage
```
(true)
(false)

(ind-Bool (true)
  (λ (b) Nat)
  (add1 zero)
  zero)
```

### Less-Than Definition (Indexed Type)
```
(data Less-Than () ((j Nat) (k Nat))
  (zero-smallest ((n Nat))
    (Less-Than zero (add1 n)))
  (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than j k)))
    (Less-Than (add1 j) (add1 k)))
  ind-Less-Than)
```

### Less-Than Usage
```
(claim proof-0<1 (Less-Than zero (add1 zero)))
(define proof-0<1 (zero-smallest zero))

(claim proof-1<2 (Less-Than (add1 zero) (add1 (add1 zero))))
(define proof-1<2
  (add1-smaller zero (add1 zero)
    (zero-smallest zero)))

(ind-Less-Than proof-0<1
  (λ (j k p) Nat)
  (λ (n) zero)
  (λ (j k j<k ih) (add1 ih)))
```

---

## Complete Programs

### Addition Function
```
(claim +
  (→ Nat Nat Nat))

(claim step-plus
  (→ Nat Nat))

(define step-plus
  (λ (n-1) (add1 n-1)))

(define +
  (λ (n j)
    (iter-Nat n j step-plus)))
```

### Increment Function
```
(claim incr
  (→ Nat Nat))

(define incr
  (λ (n)
    (iter-Nat n 1 (+ 1))))
```

### Proof: incr n = add1 n
```
(claim incr=add1
  (Π ((n Nat))
    (= Nat (incr n) (add1 n))))

(claim base-incr=add1
  (= Nat (incr zero) (add1 zero)))

(define base-incr=add1
  (same (add1 zero)))

(claim step-incr=add1
  (Π ((n-1 Nat))
    (→ (= Nat (incr n-1) (add1 n-1))
       (= Nat (add1 (incr n-1)) (add1 (add1 n-1))))))

(define step-incr=add1
  (λ (n-1 incr=add1n-1)
    (ind-= incr=add1n-1
      (λ (x proof-incr-n-1=x)
        (= Nat (add1 (incr n-1)) (add1 x)))
      (same (add1 (incr n-1))))))
```

---

## Key Observations from Examples

1. **Empty collections always need `(the Type value)`**:
   - `(the (List Nat) nil)` not `nil`
   - `(the (Vec Atom zero) vecnil)` not `vecnil`

2. **User-defined constructors/eliminators get `` prefix**:
   - `(true)` not `(true)`
   - `(ind-Bool ...)` not `(ind-Bool ...)`

3. **Numeric literals are shorthand**:
   - `0` = `zero`
   - `1` = `(add1 zero)`
   - `2` = `(add1 (add1 zero))`

4. **Lambda can take multiple arguments**:
   - `(λ (x y) body)` is curried as `(λ (x) (λ (y) body))`

5. **Eliminators have fixed structure**:
   - `ind-Nat`: target, motive, base, step
   - `ind-List`: target, motive, base, step
   - `ind-Vec`: length, target, motive, base, step
   - `ind-Either`: target, motive, left-case, right-case
   - `ind-=`: proof, motive, base
</file>

<file path="docs/pie_language/pie_type_reference.md">
# Pie Type Reference

Quick reference for all Pie types with their constructors and eliminators.

## Summary Table

| Type | Constructors | Eliminators | Notes |
|------|--------------|-------------|-------|
| Nat | `zero`, `(add1 n)` | `ind-Nat`, `rec-Nat`, `iter-Nat`, `which-Nat` | Natural numbers |
| Atom | `'symbol` | None (atoms are compared by name) | Quoted symbols |
| Trivial | `sole` | None (only one value) | Unit type |
| Absurd | None | `ind-Absurd` | Empty type |
| U | Type expressions | None | Universe of types |
| → | `(λ (x) body)` | Application `(f x)` | Non-dependent function |
| Π | `(λ (x) body)` | Application `(f x)` | Dependent function |
| Pair/Σ | `(cons a d)` | `car`, `cdr` | Pairs/dependent pairs |
| List | `nil`, `(:: h t)` | `ind-List`, `rec-List` | Polymorphic lists |
| Vec | `vecnil`, `(vec:: h t)` | `ind-Vec`, `head`, `tail` | Length-indexed vectors |
| Either | `(left x)`, `(right y)` | `ind-Either` | Sum type |
| = | `same`, `(same x)` | `replace`, `ind-=` | Equality proofs |
| **User-defined** | Defined by `data` | Generated eliminator | Custom inductive types |

---

## Nat (Natural Numbers)

**Type syntax:** `Nat`

### Constructors
```
zero                    ; 0
(add1 n)               ; n + 1

; Shorthand: numeric literals
0    ≡ zero
1    ≡ (add1 zero)
2    ≡ (add1 (add1 zero))
```

### Eliminators

#### ind-Nat (Induction)
Most powerful, allows dependent motives:
```
(ind-Nat target motive base step)

target : Nat                           ; The number to analyze
motive : (→ Nat U)                    ; (λ (k) TypeDependingOnK)
base   : (motive zero)                ; Value for zero case
step   : (Π ((n-1 Nat))              ; (λ (n-1 ih) ...)
          (→ (motive n-1)
              (motive (add1 n-1))))
```

**Example - Addition:**
```
(λ (x y)
  (ind-Nat x
    (λ (k) Nat)
    y
    (λ (n-1 ih) (add1 ih))))
```

#### rec-Nat (Recursion)
Similar to ind-Nat but simpler (non-dependent result type):
```
(rec-Nat target base step)

target : Nat
base   : T                            ; Value for zero case
step   : (→ Nat T T)                 ; (λ (n-1 ih) ...)
```

**Example - Addition:**
```
(λ (x y)
  (rec-Nat x
    y
    (λ (n-1 ih) (add1 ih))))
```

#### iter-Nat (Iteration)
Simplest, step only gets previous result:
```
(iter-Nat target base step)

target : Nat
base   : T
step   : (→ T T)                      ; (λ (prev) ...)
```

**Example - Add constant:**
```
(iter-Nat 3
  5
  (λ (prev) (add1 prev)))   ; Result: 8
```

#### which-Nat (Case analysis)
Check if zero or successor:
```
(which-Nat target base step)

target : Nat
base   : T                            ; If target is zero
step   : (→ Nat T)                   ; (λ (n-1) ...) if target is (add1 n-1)
```

---

## Atom

**Type syntax:** `Atom`

### Constructors
```
'symbol              ; Examples: 'foo, 'bar, 'pea, 'olive, 'oil
```

### Eliminators
None directly. Atoms are primitive values.

---

## Trivial (Unit Type)

**Type syntax:** `Trivial`

### Constructors
```
sole                 ; The only value of type Trivial
```

### Eliminators
None needed (only one possible value).

---

## Absurd (Empty Type)

**Type syntax:** `Absurd`

### Constructors
None (uninhabited type).

### Eliminators

#### ind-Absurd
From contradiction, derive anything:
```
(ind-Absurd target motive)

target : Absurd                       ; The impossible value
motive : U                           ; Any type you want to prove
```

---

## U (Universe)

**Type syntax:** `U`

The type of types. Type expressions evaluate to values of type U.

**Examples:**
```
Nat : U
Atom : U
(→ Nat Nat) : U
(List Atom) : U
```

---

## → (Function Type / Pi with non-dependent result)

**Type syntax:**
```
(→ A B)              ; A → B
(→ A B C)            ; A → B → C (curried)
```

### Constructors
```
(λ (x) body)                         ; Lambda abstraction
(λ (x y) body)                       ; Multi-argument (curried)
```

### Eliminators
```
(f x)                                ; Function application
```

**Example:**
```
(the (→ Nat Nat)
  (λ (x) x))                         ; Identity function
```

---

## Π (Dependent Function Type / Pi Type)

**Type syntax:**
```
(Π ((x A)) B)                        ; Π(x:A). B where B can depend on x
(Π ((x A) (y B)) C)                 ; Multiple dependent parameters
```

### Constructors
```
(λ (x) body)                         ; Lambda (same as →)
```

### Eliminators
```
(f x)                                ; Application (same as →)
```

**Example:**
```
(the (Π ((n Nat)) (Vec Atom n))
  (λ (n) (peas n)))                 ; Returns vector of length n
```

---

## Pair (Non-dependent Pair) / Σ (Dependent Pair / Sigma Type)

**Type syntax:**
```
(Pair A D)                           ; Σ(a:A). D (non-dependent)
(Σ ((x A)) B)                        ; Σ(x:A). B where B can depend on x
(Σ ((x A) (y B)) C)                 ; Multiple dependent fields
```

### Constructors
```
(cons a d)                           ; Construct pair with car=a, cdr=d
```

### Eliminators
```
(car p)                              ; First projection
(cdr p)                              ; Second projection
```

**Examples:**
```
; Non-dependent pair
(the (Pair Atom Atom)
  (cons 'olive 'oil))

; Dependent pair
(the (Σ ((n Nat)) (Vec Atom n))
  (cons 3 (vec:: 'a (vec:: 'b (vec:: 'c vecnil)))))
```

---

## List (Polymorphic Lists)

**Type syntax:** `(List E)` where E is the element type

### Constructors
```
nil                                  ; Empty list (needs annotation!)
(:: head tail)                       ; Cons cell

; IMPORTANT: nil requires type annotation
(the (List Nat) nil)                 ; Correct
nil                                  ; ERROR!
```

### Eliminators

#### ind-List (Induction)
```
(ind-List target motive base step)

target : (List E)
motive : (→ (List E) U)              ; (λ (xs) TypeDependingOnXs)
base   : (motive nil)                ; Value for nil case
step   : (Π ((head E)                ; (λ (h t ih) ...)
             (tail (List E)))
          (→ (motive tail)
             (motive (:: head tail))))
```

#### rec-List (Recursion)
Similar to ind-List but simpler.

**Example - Sum of list:**
```
(ind-List ns
  (λ (_) Nat)
  zero
  (λ (x y z)
    (ind-Nat x
      (λ (n) Nat)
      z
      (λ (_ q) (add1 q)))))
```

**Example - Build list:**
```
(:: (add1 zero)
  (:: (add1 (add1 zero))
    (the (List Nat) nil)))           ; List [1, 2]
```

---

## Vec (Length-Indexed Vectors)

**Type syntax:** `(Vec E n)` where E is element type, n is length (a Nat)

### Constructors
```
vecnil                               ; Empty vector (needs annotation!)
(vec:: head tail)                    ; Vector cons

; IMPORTANT: vecnil requires type annotation
(the (Vec Nat zero) vecnil)          ; Correct
vecnil                               ; ERROR!
```

### Eliminators

#### ind-Vec (Induction)
```
(ind-Vec length target motive base step)

length : Nat                         ; Length of the vector
target : (Vec E length)             ; The vector
motive : (Π ((k Nat))               ; Type depends on length and vector
          (→ (Vec E k) U))
base   : (motive zero vecnil)       ; Value for vecnil case
step   : (Π ((len Nat)              ; (λ (len e es ih) ...)
             (e E)
             (es (Vec E len)))
          (→ (motive len es)
             (motive (add1 len) (vec:: e es))))
```

#### head
```
(head v)                             ; Get first element (v must be non-empty)
; Type: (Π ((E U) (n Nat)) (→ (Vec E (add1 n)) E))
```

#### tail
```
(tail v)                             ; Get rest of vector (one shorter)
; Type: (Π ((E U) (n Nat)) (→ (Vec E (add1 n)) (Vec E n)))
```

**Example - Build vector of length 3:**
```
(vec:: zero
  (vec:: (add1 zero)
    (vec:: (add1 (add1 zero))
      (the (Vec Nat zero) vecnil))))  ; Vec [0, 1, 2] : (Vec Nat 3)
```

---

## Either (Sum Type)

**Type syntax:** `(Either L R)` where L is left type, R is right type

### Constructors
```
(left x)                             ; Inject x into left side
(right y)                            ; Inject y into right side
```

### Eliminators

#### ind-Either (Case analysis)
```
(ind-Either target motive on-left on-right)

target   : (Either L R)
motive   : (→ (Either L R) U)        ; (λ (e) TypeDependingOnE)
on-left  : (Π ((x L)) (motive (left x)))   ; (λ (x) ...)
on-right : (Π ((y R)) (motive (right y)))  ; (λ (y) ...)
```

**Example - Swap Either:**
```
(λ (e)
  (ind-Either e
    (λ (_) (Either Atom Nat))
    (λ (x) (right x))                ; Swap: Nat goes right
    (λ (y) (left y))))               ; Swap: Atom goes left
```

**Example - Simple construction:**
```
(left zero)          ; : (Either Nat Atom)
(right 'foo)         ; : (Either Nat Atom)
```

---

## = (Equality Type)

**Type syntax:** `(= T from to)` - proof that `from` equals `to`, both of type `T`

### Constructors
```
same                                 ; Reflexivity (when from ≡ to definitionally)
(same x)                             ; Explicit reflexivity at x
```

### Eliminators

#### replace (Transport across equality)
```
(replace proof motive base)

proof  : (= T from to)              ; Equality proof
motive : (→ T U)                    ; (λ (x) TypeDependingOnX)
base   : (motive from)              ; Value at 'from'
; Returns: (motive to)              ; Value transported to 'to'
```

**Example - Reflexivity proof:**
```
(the (= Nat zero zero)
  (same zero))
```

**Example - Symmetry using replace:**
```
(λ (n m n=m)
  (replace n=m
    (λ (k) (= Nat k n))
    (same n)))                       ; Proves m = n from n = m
```

#### ind-= (Equality induction / J rule)
More powerful eliminator for equality:
```
(ind-= proof motive base)

proof  : (= T from to)              ; Equality proof
motive : (Π ((x T))                 ; Two-argument motive
          (→ (= T from x) U))       ; Depends on x AND proof
base   : (motive from (same from))  ; Base case for reflexivity
; Returns: (motive to proof)        ; Result for actual proof
```

**Example - Congruence for add1:**
```
(λ (n-1 incr=add1n-1)
  (ind-= incr=add1n-1
    (λ (x proof-incr-n-1=x)
      (= Nat (add1 (incr n-1)) (add1 x)))
    (same (add1 (incr n-1)))))
```

**Difference between `replace` and `ind-=`:**
- `replace`: Motive takes one argument `(λ (x) T)`
- `ind-=`: Motive takes two arguments `(λ (x proof) T)` - can use the proof itself!

---

## User-Defined Inductive Types (data)

You can define your own inductive types with parameters and indices.

### Syntax
```
(data TypeName
  (parameters)                       ; Type parameters
  (indices)                          ; Type indices
  (constructor1 (args) result-type)
  (constructor2 (args) result-type)
  ...
  eliminator-name)
```

### Example 1: Simple Bool
```
(data Bool () ()                     ; No parameters, no indices
  (true () (Bool))                   ; Constructor 'true' with no args
  (false () (Bool))                  ; Constructor 'false' with no args
  ind-Bool)                          ; Eliminator name
```

**Using Bool:**
```
; Constructors get prefix 
(true)                          ; : Bool
(false)                         ; : Bool

; Eliminator also gets prefix 
(ind-Bool (true)
  (lambda (b) Nat)                   ; Motive
  (add1 zero)                        ; Case for true
  zero)                              ; Case for false
```

### Example 2: Indexed Type (Less-Than)
```
(data Less-Than () ((j Nat) (k Nat))  ; Indexed by two Nats
  (zero-smallest ((n Nat))
    (Less-Than zero (add1 n)))        ; 0 < n+1
  (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than j k)))
    (Less-Than (add1 j) (add1 k)))    ; j < k → j+1 < k+1
  ind-Less-Than)
```

**Using Less-Than:**
```
; Constructors
(zero-smallest zero)             ; : (Less-Than 0 1)
(add1-smaller zero (add1 zero)
  (zero-smallest zero))          ; : (Less-Than 1 2)

; Eliminator
(ind-Less-Than proof
  (lambda (j k p) Nat)                ; Motive depends on indices and proof
  (lambda (n) zero)                   ; Case for zero-smallest
  (lambda (j k j<k ih) (add1 ih)))    ; Case for add1-smaller
```

### General Constructor Pattern
```
(constructor-name
  ((param1 Type1) (param2 Type2) ... (arg ArgType))
  (TypeName index1 index2 ...))
```

- Constructor names get `` prefix when used
- Parameters before the colon
- Result type must be the datatype with indices

### General Eliminator Pattern
```
(ind-TypeName target motive method1 method2 ...)

target  : (TypeName idx1 idx2 ...)   ; The value to eliminate
motive  : Depends on indices + target
methodN : One method per constructor
```

Each method gets:
- Constructor's parameters as arguments
- Inductive hypotheses for recursive arguments
- Must return `(motive applied to constructor)`

---

## Type Annotation Reminders

### Always annotate empty collections:
```
✓ (the (List Nat) nil)
✗ nil

✓ (the (Vec Atom zero) vecnil)
✗ vecnil
```

### Sometimes need explicit types:
```
✓ (the Nat zero)
✓ (the Atom 'foo)
✓ (the (= Nat 0 0) (same 0))
```

### User-defined constructors need prefix:
```
✗ (true)                             ; ERROR
✓ (true)                        ; Correct

✗ (ind-Bool ...)                     ; ERROR
✓ (ind-Bool ...)                ; Correct
```
</file>

<file path="src/language_server/__test__/test_sidebar.pie">
(claim vec-map 
  (Π ((A U) (B U) (n Nat))
     (-> (-> A B) (Vec A n)
         (Vec B n))))

(define vec-map
  (λ (A B n)
    (λ (f vs)
      (ind-Vec n vs
        (λ (k xs) (Vec B k))
        vecnil
        (λ (k x xs ih) (vec:: (f x) ih))))))

(claim nat-vec-5 (Vec Nat 5))

(define nat-vec-5 (vec:: 1 (vec:: 2 (vec:: 3 (vec:: 4 (vec:: 5 vecnil))))))

(claim list-a (List Atom))
(define list-a (:: 'A (:: 'B (:: 'C nil))))

(claim atom-vec-5 (Vec Atom 5))
(define atom-vec-5 (vec-map Nat Atom 5 (lambda (n) 'A) nat-vec-5))
</file>

<file path="src/language_server/package.json">
{
	"name": "pie-lsp",
	"description": "A language server for Pie",
	"author": "Ding Feng, Li Daoxin, Zhang Qixiang",
	"publisher": "source-academy",
	"version": "1.0.0",
	"repository": {
		"type": "git"
	},
	"categories": [],
	"keywords": [
		"multi-root ready"
	],
	"engines": {
		"vscode": "^1.103.0"
	},
	"activationEvents": [
		"onLanguage:pie"
	],
	"main": "./out/src/language_server/client/src/extension",
	"contributes": {
		"languages": [
			{
				"id": "pie",
				"aliases": [
					"Pie",
					"pie"
				],
				"extensions": [
					".pie"
				],
				"configuration": "./language-configuration.json"
			}
		],
		"grammars": [
			{
				"language": "pie",
				"scopeName": "source.pie",
				"path": "./syntaxes/pie.tmLanguage.json"
			}
		],
		"views": {
			"explorer": [
				{
					"id": "pieOutput",
          "icon": "",
					"name": "Pie Output"
				}
			]
		},
		"commands": [
			{
				"command": "pie.runCode",
				"title": "Run Pie Code",
				"icon": "$(play)"
			},
			{
				"command": "pie.refreshOutput",
				"title": "Refresh",
				"icon": "$(refresh)"
			}
		],
		"menus": {
			"editor/title": [
				{
					"command": "pie.runCode",
					"when": "resourceExtname == .pie",
					"group": "navigation"
				}
			],
			"view/title": [
				{
					"command": "pie.refreshOutput",
					"when": "view == pieOutput",
					"group": "navigation"
				}
			]
		},
		"configuration": {
			"type": "object",
			"title": "Example configuration",
			"properties": {
				"languageServerExample.maxNumberOfProblems": {
					"scope": "resource",
					"type": "number",
					"default": 100,
					"description": "Controls the maximum number of problems produced by the server."
				},
				"languageServerExample.trace.server": {
					"scope": "window",
					"type": "string",
					"enum": [
						"off",
						"messages",
						"verbose"
					],
					"default": "off",
					"description": "Traces the communication between VS Code and the language server."
				}
			}
		}
	},
	"scripts": {
		"vscode:prepublish": "npm run compile",
		"compile": "tsc || true",
		"watch": "tsc -w",
		"lint": "eslint",
		"test": "jest",
		"clean": "rimraf out"
	},
	"dependencies": {
		"@types/estree": "^1.0.8",
		"js-base64": "^3.7.8",
		"vscode-languageclient": "^9.0.1",
		"vscode-languageserver": "^9.0.1",
		"vscode-languageserver-textdocument": "^1.0.11"
	},
	"devDependencies": {
		"@eslint/js": "^9.13.0",
		"@stylistic/eslint-plugin": "^2.9.0",
		"@types/jest": "^29.5.14",
		"@types/node": "^22",
		"@types/vscode": "^1.103.0",
		"eslint": "^9.13.0",
		"jest": "^29.7.0",
		"rimraf": "^3.0.2",
		"ts-jest": "^29.4.1",
		"typescript": "^5.9.2",
		"typescript-eslint": "^8.39.0"
	}
}
</file>

<file path="src/pie_interpreter/__tests__/test_absurd.ts">
import 'jest'
import { evaluatePie } from '../main';

describe("absurd", () => {
    it("trivial", () => {
        const str = 
        `
        (claim test_absurd
  (Pi ((x Absurd) (B U))
    B))
    (define test_absurd
  (lambda (x B)
    (ind-Absurd
      x B)))`
        console.log(evaluatePie(str))

    })

    it("trivial tactic", () => {
        const str =
        `
        (claim test_absurd
  (Pi ((x Absurd) (B U))
    B))
(define-tactically test_absurd
    ((intro x)
     (intro B)
     (elimAbsurd x)))
        `
        console.log(evaluatePie(str))})
})
</file>

<file path="src/pie_interpreter/__tests__/test_either.ts">
import 'jest'
import { evaluatePie } from '../main'

describe("left and right", () => {
  it("left trivial", () => {
    const str =
      `(claim test_either
  (Either Nat Nat))

(define test_either
  (left zero))`
    console.log(evaluatePie(str))
  })

  it("left trivial tactic", () => {
    const str =
      `
        (claim test_either
  (Either Nat Nat))

  (define-tactically test_either
    ((left)
     (exact zero)))
        `
    console.log(evaluatePie(str))
  })

  it("right trivial", () => {
    const str =
      `(claim test_either
  (Either Nat Nat))

  (define-tactically test_either
    ((right)
     (exact zero)))
        `
    console.log(evaluatePie(str))
  })
}
)

describe("elimEither", () => {
  it("trivial", () => {
    const str =
      `(claim either-swap
  (Pi ((A U) (B U))
    (-> (Either A B)
        (Either B A))))

(define either-swap
  (lambda (A B e)
    (ind-Either e
                (lambda (_) (Either B A))
                (lambda (x) (right x))
                (lambda (x) (left x)))))`
    console.log(evaluatePie(str))
  })

  it("trivial tactic ver0", () => {
    const str =
      `(claim either-swap
  (Pi ((A U) (B U))
    (-> (Either A B)
        (Either B A))))

        (define-tactically either-swap
          ((intro A)
           (intro B)
           (intro e)
           (elimEither e)
           (exact (lambda (x) (right x)))
           (exact (lambda (x) (left x)))))`
    console.log(evaluatePie(str))
  })

  it("trivial tactic ver1", () => {
    const str =
      `(claim either-swap
  (Pi ((A U) (B U))
    (-> (Either A B)
        (Either B A))))

        (define-tactically either-swap
          ((intro A)
           (intro B)
           (intro e)
           (elimEither e)
           (intro x)
           (exact (right x))
           (intro x)
           (exact (left x))))`
    console.log(evaluatePie(str))
  })

  it("trivial tactic ver2", () => {
    const str =
      `(claim either-swap
  (Pi ((A U) (B U))
    (-> (Either A B)
        (Either B A))))

        (define-tactically either-swap
          ((intro A)
           (intro B)
           (intro e)
           (elimEither e)
           (intro x)
           (right)
           (exact x)
           (intro x)
           (left)
           (exact x)))`
    console.log(evaluatePie(str))
  })
})
</file>

<file path="src/pie_interpreter/__tests__/test_lessThan.ts">
import 'jest';
import { evaluatePie } from '../main'

describe("Parser Evaluate Integration Tests", () => {

it("Evaluate Less-Than (no params, indexed)", () => {
    const input = `
    ;; Define Less Than relation using our new inductive type definiton
    (data Less-Than () ((j Nat) (k Nat))
      (zero-smallest ((n Nat)) (Less-Than () (zero (add1 n))))
      (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than () (j k)))) (Less-Than () ((add1 j) (add1 k))))
      ind-Less-Than)

    (claim proof-0<1 (Less-Than () (zero (add1 zero))))
    (define proof-0<1 (zero-smallest zero))

    (claim proof-1<2 (Less-Than () ((add1 zero) (add1 (add1 zero)))))
    (define proof-1<2 (add1-smaller zero (add1 zero) proof-0<1))

    (claim extract-smaller
      (Pi ((j Nat) (k Nat))
        (-> (Less-Than () (j k)) Nat)))
    (define extract-smaller
      (lambda (j k proof)
        (ind-Less-Than proof
          (lambda (j-idx k-idx p) Nat)
          (lambda (n) zero)
          (lambda (j-arg k-arg j<k-arg ih) (add1 ih)))))

    (claim result Nat)
    (define result (extract-smaller zero (add1 zero) proof-0<1))
    `;
    const result = evaluatePie(input);
    console.log(result)
  });
})
</file>

<file path="src/pie_interpreter/__tests__/test_motive_type.ts">
// import 'jest';
// import * as S from '../types/source';
// import * as V from '../types/value';
// import { Location, Syntax } from '../utils/locations';
// import { Position } from '../../scheme_parser/transpiler/types/location';
// import { DefineDatatypeSource, GeneralConstructor } from '../typechecker/definedatatype';
// import { Context } from '../utils/context';
// import { HigherOrderClosure, SiteBinder, TypedBinder } from '../types/utils';

// const testLoc = new Location(new Syntax(new Position(1, 1), new Position(1, 1), 'test'), false);

// describe("generateMotiveType implementation", () => {

//   it("should generate motive type for Bool (no indices, no parameters)", () => {
//     const ctx: Context = new Map();
//     const indicesBody = new S.Universe(testLoc) as any;

//     const boolDatatype = new DefineDatatypeSource(
//       testLoc,
//       "Bool",
//       [],
//       indicesBody,
//       [
//         new GeneralConstructor(testLoc, "true", [], new S.GeneralTypeConstructor(testLoc, "Bool", [], [])),
//         new GeneralConstructor(testLoc, "false", [], new S.GeneralTypeConstructor(testLoc, "Bool", [], []))
//       ]
//     );

//     const motiveType = boolDatatype.generateMotiveType(ctx, new Map(), []);
//     
//     // Should be: (Π [target : InductiveType("Bool", [], [])] U)
//     expect(motiveType).toBeInstanceOf(V.Pi);

//     if (motiveType instanceof V.Pi) {
//       expect(motiveType.argName).toBe('target');
//       expect(motiveType.argType).toBeInstanceOf(V.InductiveTypeConstructor);

//       const argType = motiveType.argType as V.InductiveTypeConstructor;
//       expect(argType.name).toBe("Bool");
//       expect(argType.parameters).toHaveLength(0);
//       expect(argType.indices).toHaveLength(0);

//       // Result type should be Universe
//       const resultType = motiveType.resultType.valOfClosure(new V.Zero()); // dummy arg
//       expect(resultType).toBeInstanceOf(V.Universe);
//     }

//     console.log("✅ Bool motive type:", motiveType.prettyPrint());
//   });

//   it("should generate motive type for Vec-like type (one index)", () => {
//     const ctx: Context = new Map();

//     // Vec E with index (n : Nat)
//     const indicesPi = new S.Pi(
//       testLoc,
//       [new TypedBinder(new SiteBinder(testLoc, "n"), new S.Nat(testLoc))],
//       new S.Universe(testLoc)
//     );

//     const vecDatatype = new DefineDatatypeSource(
//       testLoc,
//       "MyVec",
//       [new TypedBinder(new SiteBinder(testLoc, "E"), new S.Universe(testLoc))],
//       indicesPi,
//       [
//         new GeneralConstructor(testLoc, "vnil", [],
//           new S.GeneralTypeConstructor(testLoc, "MyVec", [], [new S.Zero(testLoc)]))
//       ]
//     );

//     // For simplicity, pass empty params (should be E value in real usage)
//     const motiveType = vecDatatype.generateMotiveType(ctx, new Map(), []);
//     

//     // Should be: (Π [n : Nat] (Π [target : InductiveType("MyVec", [], [n])] U))
//     expect(motiveType).toBeInstanceOf(V.Pi);

//     if (motiveType instanceof V.Pi) {
//       expect(motiveType.argName).toBe('n');
//       expect(motiveType.argType).toBeInstanceOf(V.Nat);

//       // Apply the closure to get inner Pi
//       const innerType = motiveType.resultType.valOfClosure(new V.Zero());
//       expect(innerType).toBeInstanceOf(V.Pi);

//       if (innerType instanceof V.Pi) {
//         expect(innerType.argName).toBe('target');
//         expect(innerType.argType).toBeInstanceOf(V.InductiveTypeConstructor);

//         const argType = innerType.argType as V.InductiveTypeConstructor;
//         expect(argType.name).toBe("MyVec");
//         // The index should be the captured value from the outer closure
//         expect(argType.indices).toHaveLength(1);
//       }
//     }

//     console.log("✅ MyVec motive type:", motiveType.prettyPrint());
//   });

//   it("should demonstrate closure capturing for indices", () => {
//     const ctx: Context = new Map();
//     const indicesBody = new S.Universe(testLoc) as any;

//     const boolDatatype = new DefineDatatypeSource(
//       testLoc,
//       "Bool",
//       [],
//       indicesBody,
//       []
//     );

//     const motiveType = boolDatatype.generateMotiveType(ctx, new Map(), []);

//     console.log("\n=== Motive Type Structure ===");
//     console.log("Generated:", motiveType.prettyPrint());
//     console.log("\nThis motive type:");
//     console.log("- Is a function from target values to Types");
//     console.log("- Can be applied with doApp(motive, targetValue)");
//     console.log("- Returns Universe (a Type)");
//     console.log("================================\n");

//     expect(motiveType).toBeDefined();
//   });
// });

describe("placeholder tests", () => {
  it("should pass", () => {
    expect(true).toBe(true);
  })
})
</file>

<file path="src/pie_interpreter/__tests__/tests.ts">
import 'jest';

import { Parser } from '../parser/parser';
import { go } from '../types/utils';
import { initCtx } from '../utils/context';
import { normType, represent } from '../typechecker/represent';
import * as C from '../types/core';


const parsePie = Parser.parsePie;
function normalize(src: string): string {
  return src.replace(/\s+/g, ' ').trim();
}

describe("demo", () => {

  it("Pie demo", () => {
    const src = parsePie('(-> Nat Nat Nat Nat Nat)');
    
    const actual = new go(new C.The(new C.Universe, new C.Pi('x', new C.Nat, 
      new C.Pi('x₁', new C.Nat, 
        new C.Pi('x₂', new C.Nat, 
          new C.Pi('x₃', new C.Nat, new C.Nat)))))
    )
    expect(represent(initCtx, src)).toEqual(actual);                                      
    }
  );

  it("Sigma demo", () => {
    const src = parsePie(
                        `(the (-> Trivial
                                    (Pair Trivial Trivial))
                                    (lambda (x)
                                    (cons x x)))`
                                       );
    const actual = new go(
      new C.The(
        new C.Pi('x', new C.Trivial(), new C.Sigma('x₁', new C.Trivial(), new C.Trivial())),
        new C.Lambda('x', new C.Cons(new C.Sole(), new C.Sole()))
      )
    );
    expect(represent(initCtx, src)).toEqual(actual);
  });

});

describe("Pie language tests", () => {

  it("Lambda with ind-List and ind-Nat", () => {
    const src = normalize(`(the (-> (List Nat) Nat)
                             (lambda (ns)
                               (ind-List
                                ns
                                (λ (_) Nat)
                                zero
                                (lambda (x y z)
                                  (ind-Nat
                                   x
                                   (lambda (n)
                                     Nat)
                                   z
                                   (lambda (_ q)
                                     (add1 q)))))))`);
    const actual = `(the
                 (Π (x (List Nat))
                   Nat)
                 (λ (ns)
                   (ind-List
                    ns
                    (λ (_) Nat)
                    0
                    (λ (x)
                      (λ (y) (λ (z) (ind-Nat x (λ (n) Nat) z (λ (_) (λ (q) (add1 q))))))))))`
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });


  it("ind-List test", () => {
    const src = normalize(`(ind-List (:: (add1 (add1 (add1 zero)))
                                      (:: (add1 (add1 zero))
                                          nil))
                                  (λ (_)
                                    Nat)
                                  zero
                                  (lambda (x y z)
                                    (ind-Nat x
                                             (lambda (n)
                                               Nat)
                                             z
                                             (lambda (_ q)
                                               (add1 q)))))`);
    const actual = `(the Nat 5)`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  
  it("Simple lambda function", () => {
    const src = parsePie('(the (-> Nat Nat) (λ (my-var) my-var))');
    const actual = new go(new C.The(new C.Pi('x', new C.Nat, new C.Nat), 
                                  new C.Lambda('my-var', new C.VarName('my-var'))));
    expect(represent(initCtx, src)).toEqual(actual);
  });

  it("Lambda with parameter named z", () => {
    const src = parsePie('(the (-> Nat Nat) (λ (z) z))');
    const actual = new go(new C.The(
      new C.Pi('x', new C.Nat(), new C.Nat()),
      new C.Lambda('z', new C.VarName('z'))
    ));
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("which-Nat with non-zero argument", () => {
    const src = parsePie('(which-Nat 1 1 (lambda (x) x))');
    const actual = new go(new C.The(new C.Nat(), new C.Zero()));
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("which-Nat with zero argument", () => {
    const src = parsePie('(which-Nat 0 2 (lambda (x) x))');
    const actual = new go(new C.The(new C.Nat(), new C.Add1(new C.Add1(new C.Zero()))));
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });
});


describe("Higher-order function tests", () => {
  
  it("Function that takes a function and an argument", () => {
    const src = parsePie('(the (-> (-> Nat Nat) Nat Nat) (lambda (f x) (f x)))');
    const actual = new go(
      new C.The(
        new C.Pi(
          'x', new C.Pi('x', new C.Nat(), new C.Nat()),
          new C.Pi(
            'x₁', new C.Nat(), 
            new C.Nat()
          )
        ),
        new C.Lambda('f', new C.Lambda('x', new C.Application(new C.VarName('f'), new C.VarName('x'))))
      )
    );
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("which-Nat with constant base case and function step case", () => {
    const src = normalize(`(the (-> Nat (-> Nat Nat) Nat)
                                     (lambda (x f)
                                       (which-Nat 2 x f)))`);
    const actual = `(the (Π (x Nat)
                       (Π (x₁ (Π (x₁ Nat)
                                 Nat))
                         Nat))
                     (λ (x)
                       (λ (f)
                         (f 1))))`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  it("which-Nat with variable condition", () => {
    const src = parsePie('(the (-> Nat (-> Nat Nat) Nat) (lambda (x f) (which-Nat x (add1 (add1 zero)) f)))');
    const actual = new go(
      new C.The(
        new C.Pi(
          'x', new C.Nat(), 
          new C.Pi(
            'x₁', new C.Pi('x₁', new C.Nat(), new C.Nat()), 
            new C.Nat()
          )
        ),
        new C.Lambda('x', 
          new C.Lambda('f', 
            new C.WhichNat(
              new C.VarName('x'),
              new C.The(new C.Nat(), new C.Add1(new C.Add1(new C.Zero()))),
              new C.Lambda('n', new C.Application(new C.VarName('f'), new C.VarName('n')))
            )
          )
        )
      )
    );
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });
});

describe("Advanced Pie language features", () => {
  
  it("Dependent type with Pi", () => {
    const src = parsePie('(the (Pi ((A U)) U) (lambda (B) B))');

    const actual = new go(
      new C.The(
        new C.Pi(
          'A', new C.Universe(), 
          new C.Universe()
        ),
        new C.Lambda('B', new C.VarName('B'))
      )
    );
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("Dependent type with multiple parameters", () => {
    const src = parsePie('(the (Pi ((A U) (a A)) A) (lambda (B b) b))');

    const actual = new go(
      new C.The(
        new C.Pi(
          'A', new C.Universe(), 
          new C.Pi(
            'a', 
            new C.VarName('A'), 
            new C.VarName('A')
          )
        ),
        new C.Lambda('B', new C.Lambda('b', new C.VarName('b')))));
    const context = new Map();      
    expect(represent(context, src)).toEqual(actual);
  });

  it("ind-Nat with constant values", () => {
    const src = parsePie('(ind-Nat (add1 (add1 zero)) (lambda (x) Nat) (add1 zero) (lambda (n-1 ih) (add1 ih)))');
    const actual = new go(new C.The(new C.Nat(), new C.Add1(new C.Add1(new C.Add1(new C.Zero())))));
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("Addition function using ind-Nat", () => {
    const src = parsePie('(the (-> Nat Nat Nat) (lambda (x y) (ind-Nat x (lambda (x) Nat) y (lambda (n-1 ih) (add1 ih)))))');
    const actual = new go(
      new C.The(
        new C.Pi(
          'x', new C.Nat(), 
          new C.Pi(
            'x₁', new C.Nat(), 
            new C.Nat()
          )
        ),
        new C.Lambda(
          'x', 
          new C.Lambda(
            'y', 
            new C.IndNat(
              new C.VarName('x'), 
              new C.Lambda('x₁', new C.Nat()), 
              new C.VarName('y'), 
              new C.Lambda(
                'n-1', 
                new C.Lambda(
                  'ih', 
                  new C.Add1(new C.VarName('ih'))
                )
              )
            )
          )
        )
      )
    );
    expect(represent(initCtx, src)).toEqual(actual);
  });

  it("Function type as a universe type", () => {
    const src = parsePie('(the U (-> Nat Nat))');
    const actual = new go(new C.The(new C.Universe(), new C.Pi('x', new C.Nat(), new C.Nat())));
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("Pi type with explicit parameter names", () => {
    const src = parsePie('(Π ((x Nat) (y Nat)) Nat)');
    //const actual = new go(['the', 'U', ['Π', [[Symbol('x'), 'Nat']], ['Π', [[Symbol('y'), 'Nat']], 'Nat']]]);
    const actual = new go(new C.The(new C.Universe(), new C.Pi('x', new C.Nat(), new C.Pi('y', new C.Nat(), new C.Nat()))));
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("normType with Nat", () => {
    const src = parsePie('Nat');
    const actual = new go(new C.Nat());
    const context = new Map();
    expect(normType(context, src)).toEqual(actual);
  });
});

describe("Atom and Pair tests", () => {
  
  it("Quote literal", () => {
    const src = parsePie("'a");
    const actual = new go(new C.The(new C.Atom(), new C.Quote('a')));
    expect(represent(initCtx, src)).toEqual(actual);
  });

  it("Explicit atom type", () => {
    const src = parsePie("(the Atom 'a)");
    const actual = new go(new C.The(new C.Atom(), new C.Quote('a')));
    expect(represent(initCtx, src)).toEqual(actual);
  });

  it("Atom type", () => {
    const src = parsePie("Atom");
    //const actual = new go(['the', 'U', 'Atom']);
    const actual = new go(new C.The(new C.Universe(), new C.Atom()));
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("Pair type", () => {
    const src = parsePie("(Pair Atom Atom)");
    //const actual = new go(['the', 'U', ['Σ', [[Symbol('a'), 'Atom']], 'Atom']]);
    const actual = new go(new C.The(new C.Universe(), new C.Sigma('a', new C.Atom(), new C.Atom())));
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("Sigma type with multiple fields", () => {
    const src = parsePie("(Σ ((x Nat) (y Atom)) Nat)");
    const actual = new go(
      new C.The(
        new C.Universe(), 
        new C.Sigma('x', new C.Nat(), new C.Sigma('y', new C.Atom(), new C.Nat()))
      )
    );
    const context = new Map();
    expect(represent(context, src)).toEqual(actual);
  });

  it("Pair construction", () => {
    const src = parsePie("(the (Pair Atom Atom) (cons 'olive 'oil))");
    const actual = new go(new C.The(new C.Sigma('x', new C.Atom(), new C.Atom()), new C.Cons(new C.Quote('olive'), new C.Quote('oil'))));
    expect(represent(initCtx, src)).toEqual(actual);
  });

  it("Pair first projection", () => {
    const src = parsePie("(car (the (Pair Atom Atom) (cons 'olive 'oil)))");
    const actual = new go(new C.The(new C.Atom(), new C.Quote('olive')));
    expect(represent(initCtx, src)).toEqual(actual);
  });

  it("Pair second projection", () => {
    const src = parsePie("(cdr (the (Pair Atom Atom) (cons 'olive 'oil)))");
    const actual = new go(new C.The(new C.Atom(), new C.Quote('oil')));
    expect(represent(initCtx, src)).toEqual(actual);
  });

  it("Complex dependent function with pair", () => {
    const src = parsePie(`(the (Π ((f (-> Nat U))
                          (p (Σ ((n Nat))
                              (f n))))
                        (f (car p)))
                      (λ (f p)
                        (cdr p)))`);
    const actual = new go(
      new C.The(
        new C.Pi(
          'f', new C.Pi('x', new C.Nat(), new C.Universe()),
            new C.Pi(
              'p', new C.Sigma('n', new C.Nat(), new C.Application(new C.VarName('f'), new C.VarName('n'))),
              new C.Application(new C.VarName('f'), new C.Car(new C.VarName('p'))))),
              new C.Lambda('f', new C.Lambda('p', new C.Cdr(new C.VarName('p'))))));
    expect(represent(initCtx, src)).toEqual(actual);
  });

  it("Normalize sigma type", () => {
    const src = parsePie("(Σ ((x Nat) (y Nat)) Nat)");
    const actual = new go(new C.Sigma('x', new C.Nat(), new C.Sigma('y', new C.Nat(), new C.Nat())));
    expect(normType(initCtx, src)).toEqual(actual);
  });


  it("test", () => {
    const src = normalize(`(the (Pi ((x (-> Trivial Absurd)) (y (-> Trivial Absurd))) (= (-> Trivial Absurd) x y)) (lambda (f g) (ind-Absurd (f sole) (= (-> Trivial Absurd) f g))))`);
    const actual = `(the
                 (Π (x (Π (x Trivial) Absurd))
                   (Π (y (Π (x₁ Trivial) Absurd))
                     (= (Π (x₁ Trivial) Absurd)
                        (λ (x₁) (the Absurd (x sole)))
                        (λ (x₁) (the Absurd (y sole))))))
                 (λ (f)
                   (λ (g)
                     (ind-Absurd
                      (the Absurd (f sole))
                      (= (Π (x Trivial) Absurd)
                         (λ (x) (the Absurd (f sole)))
                         (λ (x) (the Absurd (g sole))))))))`
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  it("", () => {
    const src = normalize(`(the (= Nat 0 0) (same 0))`);
    const actual = `(the (= Nat 0 0) (same 0))`
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  it("", () => {
    const src = normalize(`(the (Pi ((n Nat)
                                          (m Nat))
                                         (-> (= Nat n m)
                                             (= Nat m n)))
                                     (lambda (n m n=m)
                                       (replace n=m
                                                (lambda (k)
                                                  (= Nat k n))
                                                (same n))))`);
    const actual = `(the (Π (n Nat)
                       (Π (m Nat)
                         (Π (x (= Nat n m))
                           (= Nat m n))))
                     (λ (n)
                       (λ (m)
                         (λ (n=m)
                           (replace n=m
                                    (λ (k)
                                      (= Nat k n))
                                    (same n))))))`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  it("", () => {
    const src = normalize(`(replace (the (= Nat 4 4) (same 4))
                                         (lambda (k)
                                           (= Nat k 4))
                                         (same 4))`);
    const actual = `(the (= Nat 4 4) (same 4))`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  it("", () => {
    const src = normalize(`(iter-Nat 2
                                          3
                                          (λ (ih)
                                            (add1 ih)))`);
    const actual = `(the Nat 5)`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  it("", () => {
    const src = normalize(`(the (-> Nat Nat
                                 Nat)
                             (lambda (x y)
                               (iter-Nat x
                                         y
                                         (λ (n-1)
                                           (add1 n-1)))))`);
    const actual = `(the
                 (Π (x Nat)
                   (Π (x₁ Nat)
                     Nat))
                 (λ (x)
                   (λ (y)
                     (iter-Nat x
                               (the Nat y)
                               (λ (n-1)
                                 (add1 n-1))))))`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  it("", () => {
    const src = normalize(`(the (-> Nat Nat Nat)
                             (lambda (x y)
                               (rec-Nat x
                                        y
                                        (λ (n-1 ih)
                                          (add1 ih)))))`);
    const actual = `(the
                 (Π (x Nat)
                   (Π (x₁ Nat)
                     Nat))
                 (λ (x)
                   (λ (y)
                     (rec-Nat x
                              (the Nat y)
                              (λ (n-1)
                                (λ (ih)
                                  (add1 ih)))))))`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  }); 

  it("", () => {
    const src = normalize(`(rec-Nat 2 3 (λ (n-1 ih) (add1 ih)))`);
    const actual = `(the Nat 5)`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  /* it("", () => {
    const src = normalize(`((the (Pi ((A U) (B U))
                    (-> (Either A B)
                        (Either B A)))
                (lambda (A B e)
                  (ind-Either e
                              (lambda (_) (Either B A))
                              (lambda (x) (right x))
                              (lambda (x) (left x)))))
           Nat Trivial (left 2))`);
    const actual = `(the (Either Trivial Nat) (right (add1 (add1 zero))))`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  });

  it("", () => {
    const src = normalize(`((the (Pi ((A U) (B U))
                    (-> (Either A B)
                        (Either B A)))
                (lambda (A B e)
                  (ind-Either e
                              (lambda (_) (Either B A))
                              (lambda (x) (right x))
                              (lambda (x) (left x)))))
           Nat)`);
    const actual = `(the
   (Π (B U) (Π (x (Either Nat B)) (Either B Nat)))
   (λ (B)
     (λ (e)
       (ind-Either
        e
        (λ (_) (Either B Nat))
        (λ (x) (right x))
        (λ (x) (left x))))))`;
    expect(normalize((represent(initCtx, parsePie(src)) as go<C.Core>).result.prettyPrint())).toEqual(actual.replace(/\s+/g, ' ').trim());
  }); */

});
</file>

<file path="src/pie_interpreter/types/neutral.ts">
import * as C from "./core";

import { Value, Pi, Absurd } from "./value";
import { SourceLocation } from "../utils/locations";
import { Context } from "../utils/context";
import { readBack } from "../evaluator/utils";

/*
    Normal forms consist of syntax that is produced by read-back,
    following the type. This structure contains a type value and a
    value described by the type, so that read-back can later be applied
    to it.
*/
export class Norm {
  constructor(public type: Value, public value: Value) { }
}

// Predicate function to check if an object is Norm
export function isNorm(obj: any): obj is Norm {
  return obj instanceof Norm;
}


/*
    ## Neutral Expressions ##
    Neutral expressions are represented by structs that ensure that no
    non-neutral expressions can be represented.
*/

// Base class for all Neutral types
export abstract class Neutral {

  constructor() { }

  public abstract readBackNeutral(context: Context): C.Core;

  public abstract prettyPrint(): string;

  public toString() {
    return this.prettyPrint();
  }
}

export class Variable extends Neutral {
  constructor(public name: string) {
    super();
  }

  public readBackNeutral(_: Context): C.Core {
    return new C.VarName(this.name);
  }

  public prettyPrint() {
    return `N-${this.name}`;
  }
}

export class TODO extends Neutral {
  constructor(public where: SourceLocation, public type: Value) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.TODO(
      this.where, this.type.readBackType(context)
    );
  }

  public prettyPrint() {
    return `N-TODO`;
  }
}

export class WhichNat extends Neutral {
  constructor(public target: Neutral, public base: Norm, public step: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.WhichNat(
      this.target.readBackNeutral(context),
      new C.The(
        this.base.type.readBackType(context),
        readBack(context, this.base.type, this.base.value),
      ),
      readBack(context, this.step.type, this.step.value)
    );
  }

  public prettyPrint() {
    return `N-WhichNat`;
  }

}

export class IterNat extends Neutral {
  constructor(public target: Neutral, public base: Norm, public step: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.IterNat(
      this.target.readBackNeutral(context),
      new C.The(
        this.base.type.readBackType(context),
        readBack(context, this.base.type, this.base.value),
      ),
      readBack(context, this.step.type, this.step.value)
    );
  }

  public prettyPrint() {
    return `N-IterNat`;
  }
}

export class RecNat extends Neutral {

  constructor(public target: Neutral, public base: Norm, public step: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.RecNat(
      this.target.readBackNeutral(context),
      new C.The(
        this.base.type.readBackType(context),
        readBack(context, this.base.type, this.base.value),
      ),
      readBack(context, this.step.type, this.step.value)
    );
  }

  public prettyPrint() {
    return `N-RecNat`;
  }
}

export class IndNat extends Neutral {
  constructor(
    public target: Neutral,
    public motive: Norm,
    public base: Norm,
    public step: Norm
  ) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.IndNat(
      this.target.readBackNeutral(context),
      readBack(context, this.motive.type, this.motive.value),
      readBack(context, this.base.type, this.base.value),
      readBack(context, this.step.type, this.step.value)
    );
  }

  public prettyPrint() {
    return `N-IndNat`;
  }

}

export class Car extends Neutral {
  constructor(public target: Neutral) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Car(this.target.readBackNeutral(context));
  }

  public prettyPrint() {
    return `N-Car`;
  }
}

export class Cdr extends Neutral {
  constructor(public target: Neutral) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Cdr(this.target.readBackNeutral(context));
  }

  public prettyPrint() {
    return `N-Cdr`;
  }
}

export class RecList extends Neutral {
  constructor(public target: Neutral, public base: Norm, public step: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.RecList(
      this.target.readBackNeutral(context),
      new C.The(
        this.base.type.readBackType(context),
        readBack(context, this.base.type, this.base.value),
      ),
      readBack(context, this.step.type, this.step.value)
    );
  }

  public prettyPrint() {
    return `N-RecList`;
  }
}

export class IndList extends Neutral {
  constructor(public target: Neutral, public motive: Norm, public base: Norm, public step: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.IndList(
      this.target.readBackNeutral(context),
      readBack(context, this.motive.type, this.motive.value),
      readBack(context, this.base.type, this.base.value),
      readBack(context, this.step.type, this.step.value)
    );
  }

  public prettyPrint() {
    return `N-IndList`;
  }
}

export class IndAbsurd extends Neutral {

  constructor(public target: Neutral, public motive: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    // Here's some Absurd η. The rest is in α-equiv?.
    return new C.IndAbsurd(
      new C.The(
        new C.Absurd(),
        this.target.readBackNeutral(context)
      ),
      readBack(context, this.motive.type, this.motive.value)
    );
  }

  public prettyPrint() {
    return `N-IndAbsurd`;
  }

}

export class Replace extends Neutral {
  constructor(public target: Neutral, public motive: Norm, public base: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Replace(
      this.target.readBackNeutral(context),
      readBack(context, this.motive.type, this.motive.value),
      readBack(context, this.base.type, this.base.value)
    );
  }

  public prettyPrint() {
    return `N-Replace`;
  }
}

export class Trans1 extends Neutral {
  constructor(public target1: Neutral, public target2: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Trans(
      this.target1.readBackNeutral(context),
      readBack(context, this.target2.type, this.target2.value)
    );
  }

  public prettyPrint() {
    return `N-Trans1`;
  }
}

export class Trans2 extends Neutral {
  constructor(public target1: Norm, public target2: Neutral) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Trans(
      readBack(context, this.target1.type, this.target1.value),
      this.target2.readBackNeutral(context)
    )
  }

  public prettyPrint() {
    return `N-Trans2`;
  }
}

export class Trans12 extends Neutral {
  constructor(public target1: Neutral, public target2: Neutral) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Trans(
      this.target1.readBackNeutral(context),
      this.target2.readBackNeutral(context)
    )
  }

  public prettyPrint() {
    return `N-Trans12`;
  }

}

export class Cong extends Neutral {
  constructor(public target: Neutral, public func: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    const funcType = this.func.type;
    if (funcType instanceof Pi) {
      const closure = funcType.resultType;
      return new C.Cong(
        this.target.readBackNeutral(context),
        closure
          .valOfClosure(new Absurd())
          .readBackType(context),
        readBack(context, this.func.type, this.func.value)
      );
    } else {
      throw new Error("Cong applied to non-Pi type.");
    }
  }

  public prettyPrint() {
    return `N-Cong`;
  }

}

export class Symm extends Neutral {
  constructor(public target: Neutral) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Symm(this.target.readBackNeutral(context));
  }

  public prettyPrint() {
    return `N-Symm`;
  }

}

export class IndEqual extends Neutral {
  constructor(public target: Neutral, public motive: Norm, public base: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.IndEqual(
      this.target.readBackNeutral(context),
      readBack(context, this.motive.type, this.motive.value),
      readBack(context, this.base.type, this.base.value)
    );
  }

  public prettyPrint() {
    return `N-IndEqual`;
  }

}

export class Head extends Neutral {
  constructor(public target: Neutral) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Head(this.target.readBackNeutral(context));
  }

  public prettyPrint() {
    return `N-Head`;
  }

}

export class Tail extends Neutral {
  constructor(public target: Neutral) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Tail(this.target.readBackNeutral(context));
  }

  public prettyPrint() {
    return `N-Tail`;
  }

}

export class IndVec1 extends Neutral {
  constructor(
    public length: Neutral,
    public target: Norm,
    public motive: Norm,
    public base: Norm,
    public step: Norm
  ) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.IndVec(
      this.length.readBackNeutral(context),
      readBack(context, this.target.type, this.target.value),
      readBack(context, this.motive.type, this.motive.value),
      readBack(context, this.base.type, this.base.value),
      readBack(context, this.step.type, this.step.value
      ));
  }

  public prettyPrint() {
    return `N-IndVec1`;
  }
}

export class IndVec2 extends Neutral {
  constructor(
    public length: Norm,
    public target: Neutral,
    public motive: Norm,
    public base: Norm,
    public step: Norm
  ) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.IndVec(
      readBack(context, this.length.type, this.length.value),
      this.target.readBackNeutral(context),
      readBack(context, this.motive.type, this.motive.value),
      readBack(context, this.base.type, this.base.value),
      readBack(context, this.step.type, this.step.value)
    );
  }

  public prettyPrint() {
    return `N-IndVec2`;
  }

}

export class IndVec12 extends Neutral {
  constructor(
    public length: Neutral,
    public target: Neutral,
    public motive: Norm,
    public base: Norm,
    public step: Norm
  ) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.IndVec(
      this.length.readBackNeutral(context),
      this.target.readBackNeutral(context),
      readBack(context, this.motive.type, this.motive.value),
      readBack(context, this.base.type, this.base.value),
      readBack(context, this.step.type, this.step.value)
    );
  }

  public prettyPrint() {
    return `N-IndVec12`;
  }

}

export class IndEither extends Neutral {
  constructor(
    public target: Neutral,
    public motive: Norm,
    public baseLeft: Norm,
    public baseRight: Norm
  ) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.IndEither(
      this.target.readBackNeutral(context),
      readBack(context, this.motive.type, this.motive.value),
      readBack(context, this.baseLeft.type, this.baseLeft.value),
      readBack(context, this.baseRight.type, this.baseRight.value)
    );
  }

  public prettyPrint() {
    return `N-IndEither`;
  }
}

export class GenericEliminator extends Neutral {

  constructor(
    public typeName: string,
    public target: Neutral,
    public motive: Norm,
    public methods: Norm[]
  ) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Eliminator(
      this.typeName,
      this.target.readBackNeutral(context),
      readBack(context, this.motive.type, this.motive.value),
      this.methods.map(method => readBack(context, method.type, method.value))
    );
  }

  public prettyPrint() {
    return `N-GenericEliminator-${this.typeName}`;
  }
}

export class Application extends Neutral {

  constructor(public operator: Neutral, public operand: Norm) {
    super();
  }

  public readBackNeutral(context: Context): C.Core {
    return new C.Application(
      this.operator.readBackNeutral(context),
      readBack(context, this.operand.type, this.operand.value)
    );
  }

  public prettyPrint() {
    return `N-Application`;
  }

}

// Predicate function to check if an object is Neutral
export function isNeutral(obj: any): obj is Neutral {
  return obj instanceof Neutral;
}
</file>

<file path="web/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pie Playground</title>
    <link rel="stylesheet" href="styles.css" />
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div class="app-shell">
      <div class="editor-header">
        <h2 class="panel-title editor-title">
          <span class="panel-icon">π</span>
          Pie Playground
        </h2>
        <select id="example-picker" class="example-picker">
          <option value="">Examples</option>
        </select>
        <button id="copy-btn" class="copy-btn" title="Copy code to clipboard">Copy</button>
      </div>
      <div id="editor"></div>
      <div id="preview-summary" class="panel-title preview-summary">
        Start typing to see feedback.
      </div>
      <pre id="preview-output" class="preview-code"></pre>

      <!-- Proof Tree Visualizer Panel -->
      <div id="proof-tree-container" class="proof-tree-container" style="display: none;">
        <div class="proof-tree-header">
          <h3 class="panel-title proof-tree-title">
            <span class="panel-icon">T</span>
            Proof Tree
          </h3>
          <button id="proof-tree-toggle" class="proof-tree-toggle">Hide</button>
        </div>
        <div class="proof-tree-content">
          <div id="proof-context-panel" class="proof-context-panel"></div>
          <div id="proof-tree-canvas" class="proof-tree-canvas"></div>
          <div id="proof-goal-panel" class="proof-goal-panel"></div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.52.0/min/vs/loader.min.js"></script>
    <script src="app.bundle.js?v=1" type="module"></script>
  </body>
</html>
</file>

<file path="github-pages-index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pie-Slang</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #1a4d2e 0%, #0d2818 100%);
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }
      .container {
        background: #f4f9f6;
        border-radius: 12px;
        padding: 48px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        max-width: 680px;
        width: 100%;
      }
      h1 {
        font-size: 2.5em;
        color: #333;
        margin-bottom: 16px;
        text-align: center;
      }
      .pi-symbol {
        color: #2d6a4f;
        font-size: 1.2em;
      }
      p {
        color: #666;
        line-height: 1.6;
        margin-bottom: 32px;
        text-align: center;
      }
      .links {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      a {
        display: block;
        padding: 16px 24px;
        background: linear-gradient(135deg, #2d6a4f 0%, #1a4d2e 100%);
        color: white;
        text-decoration: none;
        border-radius: 8px;
        text-align: center;
        font-weight: 500;
        transition: transform 0.2s, box-shadow 0.2s;
      }
      a:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 16px rgba(45, 106, 79, 0.5);
      }
      .secondary {
        background: white;
        color: #2d6a4f;
        border: 2px solid #2d6a4f;
      }
      .secondary:hover {
        box-shadow: 0 8px 16px rgba(45, 106, 79, 0.3);
      }
      .description {
        margin-top: 12px;
        font-size: 0.9em;
        color: #888;
      }
      .footer {
        margin-top: 36px;
        padding-top: 24px;
        border-top: 1px solid #d0e4d9;
        text-align: center;
        font-size: 0.9em;
        color: #666;
        line-height: 1.8;
      }
      .footer a {
        display: inline;
        padding: 0;
        background: none;
        color: #2d6a4f;
        font-weight: 600;
        border: none;
        border-radius: 0;
      }
      .footer a:hover {
        transform: none;
        box-shadow: none;
        text-decoration: underline;
      }
      .book-cover {
        margin: 20px auto 16px;
        display: block;
        max-width: 180px;
        height: auto;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(45, 106, 79, 0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .book-cover:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 20px rgba(45, 106, 79, 0.4);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1><span class="pi-symbol">Π</span> Pie-Slang</h1>
      <p>A language server and interpreter for the Pie programming language</p>
      <div class="links">
        <a href="pie-playground/">
          <div>🎮 Pie Playground</div>
          <div class="description">Try Pie in your browser</div>
        </a>
        <a href="dist/index.js" class="secondary">
          <div>📦 Distribution Files</div>
          <div class="description">Access compiled dist/index.js</div>
        </a>
        <a href="https://github.com/source-academy/pie-slang" class="secondary">
          <div>💻 View on GitHub</div>
          <div class="description">Source code and documentation</div>
        </a>
      </div>
      <div class="footer">
        <a href="https://thelittletyper.com" target="_blank">
          <img src="https://thelittletyper.com/the-little-typer.jpg" alt="The Little Typer Book Cover" class="book-cover">
        </a>
        <div>Inspired by <a href="https://thelittletyper.com" target="_blank">The Little Typer</a></div>
        <div>Part of <a href="https://sourceacademy.org" target="_blank">Source Academy</a> @ <a href="https://www.comp.nus.edu.sg" target="_blank">NUS School of Computing</a></div>
      </div>
    </div>
  </body>
</html>
</file>

<file path="src/pie_interpreter/__tests__/test_indices.ts">
import 'jest';
import { evaluatePie } from '../main'

describe("Parser Evaluate Integration Tests", () => {
  it("Evaluate myList (parameterized, no indices)", () => {
    const input = `
    (data Less-Than () ((j Nat) (k Nat))
      (zero-smallest ((n Nat)) (Less-Than () (zero (add1 n))))
      (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than () (j k)))) (Less-Than () ((add1 j) (add1 k))))
      ind-Less-Than)

    (claim proof-0<1 (Less-Than () (zero (add1 zero))))
    (define proof-0<1 (zero-smallest zero))

    (claim proof-1<2 (Less-Than () ((add1 zero) (add1 (add1 zero)))))
    (define proof-1<2 (add1-smaller zero (add1 zero) proof-0<1))
    
    `;
    const result = evaluatePie(input);
  });
})
</file>

<file path="src/pie_interpreter/__tests__/test_method_type.ts">
// import 'jest';
// import * as S from '../types/source';
// import * as C from '../types/core';
// import * as V from '../types/value';
// import { Location, Syntax } from '../utils/locations';
// import { Position } from '../../scheme_parser/transpiler/types/location';
// import { DefineDatatypeSource, GeneralConstructor } from '../typechecker/definedatatype';
// import { Context, valInContext } from '../utils/context';
// import { SiteBinder, TypedBinder, HigherOrderClosure } from '../types/utils';

// const testLoc = new Location(new Syntax(new Position(1, 1), new Position(1, 1), 'test'), false);

// describe("generateMethodType implementation", () => {

//   it("should generate method type structure for Bool true constructor (no args)", () => {
//     const ctx: Context = new Map();
//     const indicesBody = new S.Universe(testLoc) as any;

//     const boolDatatype = new DefineDatatypeSource(
//       testLoc,
//       "Bool",
//       [],
//       indicesBody,
//       [
//         new GeneralConstructor(testLoc, "true", [], new S.GeneralTypeConstructor(testLoc, "Bool", [], [])),
//         new GeneralConstructor(testLoc, "false", [], new S.GeneralTypeConstructor(testLoc, "Bool", [], []))
//       ]
//     );

//     // First normalize constructors to get C.ConstructorType
//     const normalizedCtors = boolDatatype.normalizeConstructor(ctx, new Map());
//     const trueCtorType = normalizedCtors[0];

//     // Create a dummy motive value (Lambda) for testing
//     // In real usage, this would be a checked motive expression
//     const dummyMotive = new V.Lambda(
//       'x',
//       new HigherOrderClosure(_ => new V.Universe())
//     );

//     const methodType = boolDatatype.generateMethodType(ctx, new Map(), trueCtorType, dummyMotive, []);

//     // For true constructor with no args, method type should be: P(true)
//     // Since there are no arguments, it should directly be the result type
//     console.log("✅ True method type:", methodType.prettyPrint());

//     expect(methodType).toBeDefined();
//   });

//   it("should generate method type for Nat succ constructor (one recursive arg)", () => {
//     const ctx: Context = new Map();
//     const indicesBody = new S.Universe(testLoc) as any;

//     const natDatatype = new DefineDatatypeSource(
//       testLoc,
//       "MyNat",
//       [],
//       indicesBody,
//       [
//         new GeneralConstructor(testLoc, "zero", [],
//           new S.GeneralTypeConstructor(testLoc, "MyNat", [], [])),
//         new GeneralConstructor(testLoc, "succ",
//           [new TypedBinder(new SiteBinder(testLoc, "n"),
//             new S.GeneralTypeConstructor(testLoc, "MyNat", [], []))],
//           new S.GeneralTypeConstructor(testLoc, "MyNat", [], []))
//       ]
//     );

//     const normalizedCtors = natDatatype.normalizeConstructor(ctx, new Map());
//     const succCtorType = normalizedCtors[1];

//     // Create a dummy motive value (Lambda)
//     const dummyMotive = new V.Lambda(
//       'x',
//       new HigherOrderClosure(_ => new V.Universe())
//     );

//     // Method type for succ should be: (Π [n : MyNat] (Π [ih : P(n)] P(succ n)))
//     const methodType = natDatatype.generateMethodType(ctx, new Map(), succCtorType, dummyMotive, []);

//     console.log("✅ Succ method type:", methodType.prettyPrint());

//     // Should be a Pi type
//     expect(methodType).toBeInstanceOf(V.Pi);

//     if (methodType instanceof V.Pi) {
//       // Outer Pi should be for the argument
//       expect(methodType.argName).toBe('arg0');

//       // Inner should contain IH and result
//       const innerType = methodType.resultType.valOfClosure(new V.Zero());
//       expect(innerType).toBeInstanceOf(V.Pi);

//       if (innerType instanceof V.Pi) {
//         // Should be IH
//         expect(innerType.argName).toBe('ih0');
//         console.log("  - IH type:", innerType.argType.prettyPrint());
//       }
//     }
//   });

//   it("should demonstrate method type structure for List cons", () => {
//     const ctx: Context = new Map();
//     const indicesBody = new S.Universe(testLoc) as any;

//     const listDatatype = new DefineDatatypeSource(
//       testLoc,
//       "MyList",
//       [],
//       indicesBody,
//       [
//         new GeneralConstructor(testLoc, "nil", [],
//           new S.GeneralTypeConstructor(testLoc, "MyList", [], [])),
//         new GeneralConstructor(testLoc, "cons", [
//           new TypedBinder(new SiteBinder(testLoc, "head"), new S.Nat(testLoc)),
//           new TypedBinder(new SiteBinder(testLoc, "tail"),
//             new S.GeneralTypeConstructor(testLoc, "MyList", [], []))
//         ],
//           new S.GeneralTypeConstructor(testLoc, "MyList", [], []))
//       ]
//     );

//     const normalizedCtors = listDatatype.normalizeConstructor(ctx, new Map());
//     const consCtorType = normalizedCtors[1];

//     // Create a dummy motive value (Lambda)
//     const dummyMotive = new V.Lambda(
//       'x',
//       new HigherOrderClosure(_ => new V.Universe())
//     );

//     // Method type for cons should be:
//     // (Π [head : Nat] (Π [tail : MyList] (Π [ih : P(tail)] P(cons head tail))))
//     const methodType = listDatatype.generateMethodType(ctx, new Map(), consCtorType, dummyMotive, []);

//     console.log("\n=== Method Type for cons ===");
//     console.log("Type:", methodType.prettyPrint());
//     console.log("\nStructure:");
//     console.log("- Takes head : Nat (non-recursive)");
//     console.log("- Takes tail : MyList (recursive)");
//     console.log("- Takes ih : P(tail) (inductive hypothesis)");
//     console.log("- Returns P(cons head tail)");
//     console.log("============================\n");

//     expect(methodType).toBeDefined();
//     expect(methodType).toBeInstanceOf(V.Pi);
//   });
// });

describe("placeholder tests", () => {
  it("should pass", () => {
    expect(true).toBe(true);
  })
})
</file>

<file path="src/pie_interpreter/tactics/proofstate.ts">
import { Claim, Context, extendContext } from '../utils/context';
import { Core } from '../types/core';
import { Value } from '../types/value';
import { Location } from '../utils/locations';
import { fresh, go, Perhaps } from '../types/utils';
import { Renaming } from '../typechecker/utils';

type GoalId = string;

//TODO: Add location

export class Goal {
  constructor(
    public id: GoalId,
    public type: Value,
    public context: Context,
    public renaming: Renaming,
    public term?: Core,
  ) { }

  clone(modifications: Partial<Goal> = {}): Goal {
    return new Goal(
      modifications.id ?? this.id,
      modifications.type ?? this.type,
      modifications.context ?? new Map(this.context),
      modifications.renaming ?? new Map(this.renaming),
      modifications.term ?? this.term,
    );
  }

  addHypothesis(name: string, type: Value): void {
    const freename = fresh(this.context, name);
    extendContext(this.context, freename, new Claim(type))
  }

  getVariableType(name: string): Value | undefined {
    const binder = this.context.get(name);
    return binder?.type;
  }
  
  prettyPrintWithContext(): string {
    const contextStr = Array.from(this.context.entries())
      .map(([name, binder]) => `${name} : ${binder.type.readBackType(this.context).prettyPrint()}`)
      .join('\n  ');

    const goalStr = this.type.readBackType(this.context).prettyPrint();

    return contextStr ?
      `Context:\n  ${contextStr}\n────────────────\nGoal: ${goalStr}` :
      `Goal: ${goalStr}`;
  }

  toSerializable(isComplete: boolean, isCurrent: boolean): SerializableGoal {
    const contextEntries: SerializableContextEntry[] = Array.from(this.context.entries())
      .map(([name, binder]) => ({
        name,
        type: binder.type.readBackType(this.context).prettyPrint()
      }));

    return {
      id: this.id,
      type: this.type.readBackType(this.context).prettyPrint(),
      contextEntries,
      isComplete,
      isCurrent
    };
  }
}

export class GoalNode {
  public children: GoalNode[] = [];
  public parent: GoalNode | null = null;
  public isComplete: boolean = false;
  public childFocusIndex: number = -1;
  public appliedTactic?: string;  // Tactic that was applied to create children
  public completedBy?: string;    // Tactic that directly solved this goal (for leaf nodes)

  constructor(
    public goal: Goal,
  ) { }

  addChildren(children: GoalNode[]): void {
    children.forEach(child => {
      child.parent = this;
    });
    this.children = children;
  }

  findById(goalId: GoalId): GoalNode | null {
    if (this.goal.id === goalId) {
      return this;
    }

    for (const child of this.children) {
      const found = child.findById(goalId);
      if (found) return found;
    }

    return null;
  }

  toSerializable(currentGoalId: string | null): SerializableGoalNode {
    const isCurrent = this.goal.id === currentGoalId;

    return {
      goal: this.goal.toSerializable(this.isComplete, isCurrent),
      children: this.children.map(child => child.toSerializable(currentGoalId)),
      appliedTactic: this.appliedTactic,
      completedBy: this.completedBy
    };
  }
}

export class ProofState {
  public currentGoal: GoalNode;
  public proofHistory: ProofState[] = [];
  private goalIdCounter: number = 0;

  constructor(
    public location: Location,
    public goalTree: GoalNode
  ) {
    this.currentGoal = this.goalTree;
  }

  static initialize(globalContext: Context, theorem: Value, location: Location): ProofState {
    const rootGoal = new Goal(
      "goal_0",
      theorem,
      new Map(globalContext),
      new Map(),
    );

    const proofstate = new ProofState(location, new GoalNode(rootGoal))
    proofstate.currentGoal = proofstate.goalTree
    return proofstate
  }

  generateGoalId(): string {
    return `goal_${++this.goalIdCounter}`;
  }

  isComplete(): boolean {
    return this.goalTree.isComplete;
  }

  getCurrentGoal(): Perhaps<Goal> {
    if (this.currentGoal === null) {
      throw new Error("No current goal available.")
    }
    return new go(this.currentGoal.goal);
  }

  visualizeTree(): string {
    return this.visualizeNode(this.goalTree, "", true);
  }

  private visualizeNode(node: GoalNode, prefix: string, isLast: boolean): string {
    const connector = isLast ? "└── " : "├── ";
    const status = node.isComplete ? "✓" : (node === this.currentGoal ? "→" : "○");
    const goalInfo = `${status} ${node.goal.id}`;

    let result = prefix + connector + goalInfo + "\n";

    const childPrefix = prefix + (isLast ? "    " : "│   ");
    for (let i = 0; i < node.children.length; i++) {
      const isLastChild = i === node.children.length - 1;
      result += this.visualizeNode(node.children[i], childPrefix, isLastChild);
    }

    return result;
  }

  addGoal(goals: GoalNode[]): void {
    this.currentGoal.addChildren(goals)
    this.currentGoal.childFocusIndex = 0
    this.currentGoal = goals[0]
  }

  nextGoal(): boolean {

    if (this.currentGoal.parent === null) {
      return true
    }

    const cur_parent = this.currentGoal.parent;
    const nextGoal = this.nextGoalAux(cur_parent);
    if (nextGoal === null) {
      return true
    } else {
      this.currentGoal = nextGoal;
      return false;
    }
  }

  private nextGoalAux(curParent): GoalNode | null {
    if (curParent.childFocusIndex === -1 || curParent.childFocusIndex >= curParent.children.length - 1) {
      // Only mark parent complete if ALL children are actually complete
      const allChildrenComplete = curParent.children.length === 0 ||
        curParent.children.every(child => child.isComplete);

      if (allChildrenComplete) {
        curParent.isComplete = true;
      }

      if (curParent.parent === null) {
        return null;
      } else {
        return this.nextGoalAux(curParent.parent);
      }
    } else {
      curParent.childFocusIndex += 1;
      return curParent.children[curParent.childFocusIndex];
    }
  }

  previousGoal(): void {
    if (this.currentGoal.parent === null) {
      throw new Error("No previous goal available at the root level.");
    }

    const prevGoal = this.PreviousGoalAux(this.currentGoal);
    if (prevGoal === null) {
      throw new Error("No previous goal found.");
    } else {
      this.currentGoal = prevGoal;
    }
  }

  private PreviousGoalAux(curParent): GoalNode | null {
    if (curParent.childFocusIndex === 0) {
      return curParent
    } else {
      let isBottom = false
      let curNode = curParent.children[curParent.childFocusIndex - 1]
      while (!isBottom) {
        if (curNode.childFocusINdex === -1) {
          isBottom = true
          return curNode
        } else {
          curNode = curNode.children[curNode.childFocusIndex]
        }
      }

    }
    return null; // Add explicit return for the else branch

  }

  getProofTreeData(): ProofTreeData {
    const currentGoalId = this.currentGoal ? this.currentGoal.goal.id : null;
    return {
      root: this.goalTree.toSerializable(currentGoalId),
      isComplete: this.isComplete(),
      currentGoalId
    };
  }
}

export interface ProofSummary {
  totalGoals: number;
  completedGoals: number;
}

// Serializable types for proof tree visualization
export interface SerializableContextEntry {
  name: string;
  type: string;
}

export interface SerializableGoal {
  id: string;
  type: string;
  contextEntries: SerializableContextEntry[];
  isComplete: boolean;
  isCurrent: boolean;
}

export interface SerializableGoalNode {
  goal: SerializableGoal;
  children: SerializableGoalNode[];
  appliedTactic?: string;
  completedBy?: string;  // Tactic that directly solved this leaf goal
}

export interface ProofTreeData {
  root: SerializableGoalNode;
  isComplete: boolean;
  currentGoalId: string | null;
}
</file>

<file path="web/lsp/pie-language-server-simple.worker.ts">
/**
 * Simple browser-based language server for Pie
 * This provides diagnostics via a Web Worker without full LSP protocol
 */

import { pieDeclarationParser, Claim, Definition, DefineTactically, schemeParse } from '../../src/pie_interpreter/parser/parser';
import { DefineDatatypeSource, handleDefineDatatype } from '../../src/pie_interpreter/typechecker/definedatatype';
import { Context, initCtx, addClaimToContext, addDefineToContext } from '../../src/pie_interpreter/utils/context';
import { Renaming } from '../../src/pie_interpreter/typechecker/utils';
import { go, stop } from '../../src/pie_interpreter/types/utils';
import { ProofManager } from '../../src/pie_interpreter/tactics/proofmanager';
import { PIE_HOVER_INFO } from './pie_hover_info';

interface Diagnostic {
	severity: 'error' | 'warning';
	startLine: number;
	startColumn: number;
	endLine: number;
	endColumn: number;
	message: string;
}

interface ValidationResult {
	diagnostics: Diagnostic[];
}

// Helper function to convert Pie location to diagnostic range
function locationToRange(location: any): { startLine: number, startColumn: number, endLine: number, endColumn: number } {
	if (location && location.syntax) {
		return {
			startLine: location.syntax.start.line,
			startColumn: location.syntax.start.column,
			endLine: location.syntax.end.line,
			endColumn: location.syntax.end.column
		};
	}
	// Fallback to first line if no location info
	return {
		startLine: 0,
		startColumn: 0,
		endLine: 0,
		endColumn: 10
	};
}

// Main function to type check a Pie document and return diagnostics
function validatePieSource(source: string): ValidationResult {
	const diagnostics: Diagnostic[] = [];
	let context = initCtx;
	let renaming: Renaming = new Map();

	try {
		// Parse the document into declarations
		const astList = schemeParse(source);

		// Process each declaration
		for (const ast of astList) {
			const declaration = pieDeclarationParser.parseDeclaration(ast);
			const result = processDeclaration(declaration, context, renaming);
			diagnostics.push(...result.diagnostics);
			context = result.context;
			renaming = result.renaming;
		}

	} catch (error) {
		// Handle parsing errors
		const range = locationToRange(null);
		const diagnostic: Diagnostic = {
			severity: 'error',
			...range,
			message: `Parse error: ${error}`
		};
		diagnostics.push(diagnostic);
	}

	return { diagnostics };
}

// Process a single declaration for type checking
function processDeclaration(decl: any, context: Context, renaming: Renaming): { diagnostics: Diagnostic[], context: Context, renaming: Renaming } {
	const diagnostics: Diagnostic[] = [];
	let newContext = context;
	let newRenaming = renaming;

	try {
		if (decl instanceof Claim) {
			newContext = processClaimDeclaration(decl, context, diagnostics);
		} else if (decl instanceof Definition) {
			newContext = processDefineDeclaration(decl, context, diagnostics);
		} else if (decl instanceof DefineTactically) {
			newContext = processDefineTacticallyDeclaration(decl, context, diagnostics);
		} else if (decl instanceof DefineDatatypeSource) {
			const result = processDefineDatatypeDeclaration(decl, context, renaming, diagnostics);
			newContext = result.context;
			newRenaming = result.renaming;
		} else {
			const range = (decl as any).location ? locationToRange((decl as any).location) : locationToRange(null);
			const diagnostic: Diagnostic = {
				severity: 'warning',
				...range,
				message: `Unknown declaration type or unhandled expression`
			};
			diagnostics.push(diagnostic);
		}
	} catch (error) {
		const range = (decl as any).location ? locationToRange((decl as any).location) : locationToRange(null);
		const diagnostic: Diagnostic = {
			severity: 'error',
			...range,
			message: `Error processing declaration: ${error}`
		};
		diagnostics.push(diagnostic);
	}

	return { diagnostics, context: newContext, renaming: newRenaming };
}

// Process define-datatype declarations (inductive types)
function processDefineDatatypeDeclaration(
	datatype: DefineDatatypeSource,
	context: Context,
	renaming: Renaming,
	diagnostics: Diagnostic[]
): { context: Context, renaming: Renaming } {
	try {
		const result = handleDefineDatatype(context, renaming, datatype);
		if (result instanceof go) {
			return { context: result.result, renaming };
		} else if (result instanceof stop) {
			const range = locationToRange(datatype.location);
			diagnostics.push({
				severity: 'error',
				...range,
				message: `Error in datatype definition '${datatype.name}': ${result.message}`
			});
			return { context, renaming };
		}
		return { context, renaming };
	} catch (error) {
		const range = locationToRange(datatype.location);
		diagnostics.push({
			severity: 'error',
			...range,
			message: `Error in datatype definition '${datatype.name}': ${error}`
		});
		return { context, renaming };
	}
}

// Process claim declarations
function processClaimDeclaration(claim: Claim, context: Context, diagnostics: Diagnostic[]): Context {
	try {
		const result = addClaimToContext(context, claim.name, claim.location, claim.type);
		if (result instanceof go) {
			return result.result;
		} else if (result instanceof stop) {
			const range = locationToRange(result.where);
			const diagnostic: Diagnostic = {
				severity: 'error',
				...range,
				message: `${result.message}`
			};
			diagnostics.push(diagnostic);
			return context;
		}
		return context;
	} catch (error) {
		const range = locationToRange(claim.location);
		const diagnostic: Diagnostic = {
			severity: 'error',
			...range,
			message: `Error in claim '${claim.name}': ${error}`
		};
		diagnostics.push(diagnostic);
		return context;
	}
}

// Process define declarations
function processDefineDeclaration(define: Definition, context: Context, diagnostics: Diagnostic[]): Context {
	try {
		const result = addDefineToContext(context, define.name, define.location, define.expr);
		if (result instanceof go) {
			return result.result;
		} else if (result instanceof stop) {
			const range = locationToRange(result.where);
			const diagnostic: Diagnostic = {
				severity: 'error',
				...range,
				message: `${result.message}`
			};
			diagnostics.push(diagnostic);
			return context;
		}
		return context;
	} catch (error) {
		const range = locationToRange(define.location);
		const diagnostic: Diagnostic = {
			severity: 'error',
			...range,
			message: `Error in definition '${define.name}': ${error}`
		};
		diagnostics.push(diagnostic);
		return context;
	}
}

// Process define-tactically declarations
function processDefineTacticallyDeclaration(defineTactically: DefineTactically, context: Context, diagnostics: Diagnostic[]): Context {
	try {
		const proofManager = new ProofManager();

		// Start the proof
		const startResult = proofManager.startProof(defineTactically.name, context, defineTactically.location);
		if (startResult instanceof stop) {
			const range = locationToRange(startResult.where);
			const diagnostic: Diagnostic = {
				severity: 'error',
				...range,
				message: `${startResult.message}`
			};
			diagnostics.push(diagnostic);
			return context;
		}

		// Apply each tactic
		for (const tactic of defineTactically.tactics) {
			const tacticResult = proofManager.applyTactic(tactic);
			if (tacticResult instanceof stop) {
				const range = locationToRange(tacticResult.where);
				const diagnostic: Diagnostic = {
					severity: 'error',
					...range,
					message: `Tactic error: ${tacticResult.message}`
				};
				diagnostics.push(diagnostic);
				return context;
			}
		}

		return context;
	} catch (error) {
		const range = locationToRange(defineTactically.location);
		const diagnostic: Diagnostic = {
			severity: 'error',
			...range,
			message: `Error in tactical definition '${defineTactically.name}': ${error}`
		};
		diagnostics.push(diagnostic);
		return context;
	}
}

// Built-in Pie completions
const PIE_COMPLETIONS = [
	// Basic types
	{ label: 'Nat', kind: 'TypeParameter', detail: 'Natural numbers' },
	{ label: 'Atom', kind: 'TypeParameter', detail: 'Atomic values' },
	{ label: 'Universe', kind: 'TypeParameter', detail: 'Type of types' },
	{ label: 'U', kind: 'TypeParameter', detail: 'Type of types (short)' },

	// Constructors
	{ label: 'zero', kind: 'Value', detail: 'Natural number zero' },
	{ label: 'add1', kind: 'Function', detail: 'Add one to a natural number' },
	{ label: 'nil', kind: 'Value', detail: 'Empty list' },
	{ label: '::', kind: 'Function', detail: 'List constructor' },
	{ label: 'cons', kind: 'Function', detail: 'Pair constructor' },
	{ label: 'same', kind: 'Function', detail: 'Reflexivity of equality' },

	// Functions
	{ label: 'lambda', kind: 'Keyword', detail: 'Anonymous function' },
	{ label: 'λ', kind: 'Keyword', detail: 'Anonymous function (Unicode)' },
	{ label: 'the', kind: 'Keyword', detail: 'Type annotation' },
	{ label: 'car', kind: 'Function', detail: 'First element of pair' },
	{ label: 'cdr', kind: 'Function', detail: 'Second element of pair' },

	// Dependent types
	{ label: 'Pi', kind: 'TypeParameter', detail: 'Dependent function type' },
	{ label: 'Π', kind: 'TypeParameter', detail: 'Dependent function type (Unicode)' },
	{ label: 'Sigma', kind: 'TypeParameter', detail: 'Dependent pair type' },
	{ label: 'Σ', kind: 'TypeParameter', detail: 'Dependent pair type (Unicode)' },

	// Type constructors
	{ label: 'List', kind: 'TypeParameter', detail: 'List type constructor' },
	{ label: 'Pair', kind: 'TypeParameter', detail: 'Pair type constructor' },
	{ label: 'Vec', kind: 'TypeParameter', detail: 'Vector type constructor' },
	{ label: 'Either', kind: 'TypeParameter', detail: 'Either type constructor' },
	{ label: '->', kind: 'TypeParameter', detail: 'Function type' },
	{ label: '→', kind: 'TypeParameter', detail: 'Function type (Unicode)' },
	{ label: '=', kind: 'TypeParameter', detail: 'Equality type' },

	// Vector constructors
	{ label: 'vecnil', kind: 'Value', detail: 'Empty vector' },
	{ label: 'vec::', kind: 'Function', detail: 'Vector constructor' },

	// Either constructors
	{ label: 'left', kind: 'Function', detail: 'Left Either constructor' },
	{ label: 'right', kind: 'Function', detail: 'Right Either constructor' },

	// Eliminators
	{ label: 'which-Nat', kind: 'Function', detail: 'Case analysis for Nat' },
	{ label: 'iter-Nat', kind: 'Function', detail: 'Iteration over Nat' },
	{ label: 'rec-Nat', kind: 'Function', detail: 'Recursion over Nat' },
	{ label: 'ind-Nat', kind: 'Function', detail: 'Induction over Nat' },
	{ label: 'rec-List', kind: 'Function', detail: 'Recursion over List' },
	{ label: 'ind-List', kind: 'Function', detail: 'Induction over List' },
	{ label: 'ind-Vec', kind: 'Function', detail: 'Induction over Vec' },
	{ label: 'ind-Either', kind: 'Function', detail: 'Case analysis for Either' },

	// Equality functions
	{ label: 'replace', kind: 'Function', detail: 'Substitution of equals for equals' },
	{ label: 'trans', kind: 'Function', detail: 'Transitivity of equality' },
	{ label: 'cong', kind: 'Function', detail: 'Congruence of equality' },
	{ label: 'symm', kind: 'Function', detail: 'Symmetry of equality' },
	{ label: 'ind-=', kind: 'Function', detail: 'Induction for equality' },

	// Special
	{ label: 'TODO', kind: 'Snippet', detail: 'Placeholder for incomplete code' },
	{ label: 'check-same', kind: 'Keyword', detail: 'Check equality' },

	// Top-level forms
	{ label: 'define', kind: 'Keyword', detail: 'Define a function or value' },
	{ label: 'claim', kind: 'Keyword', detail: 'Claim the type of a name' },
	{ label: 'define-tactically', kind: 'Keyword', detail: 'Define using tactics' }
];

interface SymbolDefinition {
	name: string;
	line: number;
	startColumn: number;
	endColumn: number;
	type: 'define' | 'claim' | 'define-tactically';
	typeInfo?: string;
}

// Extract user-defined symbols from source
function extractUserDefinedSymbols(source: string): {
	completions: any[],
	definitions: Map<string, SymbolDefinition>
} {
	const completions: any[] = [];
	const definitions = new Map<string, SymbolDefinition>();
	const lines = source.split('\n');

	// Regular expressions for Pie constructs
	const definePattern = /\(define\s+([a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*)/;
	const claimPattern = /\(claim\s+([a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*)\s+(.+?)\)/;
	const defineTacticallyPattern = /\(define-tactically\s+([a-zA-Z][a-zA-Z0-9\-_!?*+=<>]*)/;

	lines.forEach((line, lineIndex) => {
		// Check for define
		let match = definePattern.exec(line);
		if (match) {
			const symbolName = match[1];
			const startCol = line.indexOf(symbolName);

			completions.push({
				label: symbolName,
				kind: 'Function',
				detail: 'User-defined function'
			});

			definitions.set(symbolName, {
				name: symbolName,
				line: lineIndex,
				startColumn: startCol,
				endColumn: startCol + symbolName.length,
				type: 'define'
			});
		}

		// Check for claim
		match = claimPattern.exec(line);
		if (match) {
			const symbolName = match[1];
			const typeSpec = match[2];
			const startCol = line.indexOf(symbolName);

			completions.push({
				label: symbolName,
				kind: 'Variable',
				detail: `Claimed type: ${typeSpec.substring(0, 50)}${typeSpec.length > 50 ? '...' : ''}`
			});

			definitions.set(symbolName, {
				name: symbolName,
				line: lineIndex,
				startColumn: startCol,
				endColumn: startCol + symbolName.length,
				type: 'claim',
				typeInfo: typeSpec
			});
		}

		// Check for define-tactically
		match = defineTacticallyPattern.exec(line);
		if (match) {
			const symbolName = match[1];
			const startCol = line.indexOf(symbolName);

			completions.push({
				label: symbolName,
				kind: 'Function',
				detail: 'Tactically defined function'
			});

			definitions.set(symbolName, {
				name: symbolName,
				line: lineIndex,
				startColumn: startCol,
				endColumn: startCol + symbolName.length,
				type: 'define-tactically'
			});
		}
	});

	return { completions, definitions };
}

// Get word at cursor position
function getWordAtPosition(source: string, line: number, column: number): string | null {
	const lines = source.split('\n');

	if (line >= lines.length) {
		return null;
	}

	const lineText = lines[line];

	if (column >= lineText.length) {
		return null;
	}

	// Define what constitutes an identifier in Pie
	const identifierRegex = /[a-zA-Z0-9_\-!?*+=<>λΠΣ→]/;

	// Find start of word
	let start = column;
	while (start > 0 && identifierRegex.test(lineText[start - 1])) {
		start--;
	}

	// Find end of word
	let end = column;
	while (end < lineText.length && identifierRegex.test(lineText[end])) {
		end++;
	}

	if (start === end) {
		return null;
	}

	return lineText.substring(start, end);
}

// Get word at position along with its range and cursor offset within the word
function getWordAndRange(source: string, line: number, column: number): { word: string, start: number, end: number, cursorOffset: number } | null {
	const lines = source.split('\n');

	if (line >= lines.length) {
		return null;
	}

	const lineText = lines[line];

	// Define what constitutes an identifier in Pie
	const identifierRegex = /[a-zA-Z0-9_\-!?*+=<>λΠΣ→]/;

	// Find start of word
	let start = column;
	while (start > 0 && identifierRegex.test(lineText[start - 1])) {
		start--;
	}

	// Find end of word
	let end = column;
	while (end < lineText.length && identifierRegex.test(lineText[end])) {
		end++;
	}

	if (start === end) {
		return null;
	}

	return {
		word: lineText.substring(start, end),
		start,
		end,
		cursorOffset: column - start
	};
}

// Cache for symbols (avoid re-parsing on every completion request)
let cachedSource = '';
let cachedSymbols: { completions: any[], definitions: Map<string, SymbolDefinition> } | null = null;

function getSymbols(source: string) {
	if (source !== cachedSource) {
		cachedSource = source;
		cachedSymbols = extractUserDefinedSymbols(source);
	}
	return cachedSymbols!;
}

// Listen for messages from the main thread
self.onmessage = (event: MessageEvent) => {
	const { type, source, line, column } = event.data;

	if (type === 'validate') {
		try {
			const result = validatePieSource(source);
			self.postMessage({
				type: 'validation-result',
				diagnostics: result.diagnostics
			});
		} catch (error) {
			self.postMessage({
				type: 'validation-error',
				error: String(error)
			});
		}
	} else if (type === 'completion') {
		try {
			// Get the word at cursor position for prefix filtering
			const wordInfo = getWordAndRange(source, line, column);
			const prefix = wordInfo ? wordInfo.word.substring(0, wordInfo.cursorOffset) : '';

			const symbols = getSymbols(source);
			let allCompletions = [...PIE_COMPLETIONS, ...symbols.completions];

			// Filter completions based on prefix
			if (prefix) {
				allCompletions = allCompletions.filter(item =>
					item.label.toLowerCase().startsWith(prefix.toLowerCase())
				);

				// Sort by relevance: exact prefix match > case-sensitive match > case-insensitive match
				allCompletions.sort((a, b) => {
					const aLabel = a.label;
					const bLabel = b.label;

					// Exact match gets highest priority
					if (aLabel === prefix && bLabel !== prefix) return -1;
					if (bLabel === prefix && aLabel !== prefix) return 1;

					// Case-sensitive prefix match
					const aStartsWith = aLabel.startsWith(prefix);
					const bStartsWith = bLabel.startsWith(prefix);
					if (aStartsWith && !bStartsWith) return -1;
					if (bStartsWith && !aStartsWith) return 1;

					// Then sort alphabetically
					return aLabel.localeCompare(bLabel);
				});
			}

			self.postMessage({
				type: 'completion-result',
				completions: allCompletions,
				wordRange: wordInfo ? { start: wordInfo.start, end: wordInfo.end } : null
			});
		} catch (error) {
			self.postMessage({
				type: 'completion-result',
				completions: PIE_COMPLETIONS,
				wordRange: null
			});
		}
	} else if (type === 'definition') {
		try {
			const word = getWordAtPosition(source, line, column);
			if (!word) {
				self.postMessage({
					type: 'definition-result',
					location: null
				});
				return;
			}

			const symbols = getSymbols(source);
			const definition = symbols.definitions.get(word);

			if (definition) {
				self.postMessage({
					type: 'definition-result',
					location: {
						line: definition.line,
						startColumn: definition.startColumn,
						endColumn: definition.endColumn
					}
				});
			} else {
				self.postMessage({
					type: 'definition-result',
					location: null
				});
			}
		} catch (error) {
			self.postMessage({
				type: 'definition-result',
				location: null
			});
		}
	} else if (type === 'hover') {
		try {
			const word = getWordAtPosition(source, line, column);
			if (!word) {
				self.postMessage({
					type: 'hover-result',
					hoverInfo: null
				});
				return;
			}

			// Check for user-defined symbols first
			const symbols = getSymbols(source);
			const definition = symbols.definitions.get(word);

			if (definition) {
				const hoverInfo = {
					title: word,
					summary: `User-defined ${definition.type}`,
					details: definition.typeInfo ? `Type: ${definition.typeInfo}` : undefined,
					examples: undefined
				};
				self.postMessage({
					type: 'hover-result',
					hoverInfo
				});
				return;
			}

			// Fall back to built-in hover info
			const builtinInfo = PIE_HOVER_INFO.get(word);
			if (builtinInfo) {
				self.postMessage({
					type: 'hover-result',
					hoverInfo: {
						title: word,
						summary: builtinInfo.summary,
						details: builtinInfo.details,
						examples: builtinInfo.examples
					}
				});
				return;
			}

			// Check if it's a number
			if (/^\d+$/.test(word)) {
				self.postMessage({
					type: 'hover-result',
					hoverInfo: {
						title: 'Natural number literal',
						summary: `Represents the Nat value ${word}`,
						details: undefined,
						examples: undefined
					}
				});
				return;
			}

			// Check if it's a quoted atom
			if (word.startsWith("'")) {
				self.postMessage({
					type: 'hover-result',
					hoverInfo: {
						title: 'Quoted atom',
						summary: `Type: Atom`,
						details: `Value: ${word}`,
						examples: undefined
					}
				});
				return;
			}

			// No hover info found
			self.postMessage({
				type: 'hover-result',
				hoverInfo: null
			});
		} catch (error) {
			self.postMessage({
				type: 'hover-result',
				hoverInfo: null
			});
		}
	}
};

console.log('Pie Language Server worker (simple) started');
</file>

<file path="web/diagnostics-worker.js">
// Log the worker's location for debugging
console.log('[Worker] Worker location:', self.location.href);
console.log('[Worker] Starting diagnostics worker initialization...');

let analyzePieSource = null;
let initializationError = null;
const messageQueue = [];

// Process a single message
function processMessage(event) {
  const { type, payload } = event.data ?? {};
  if (type !== 'analyze') {
    return;
  }

  // Check if initialization failed
  if (initializationError) {
    console.error('[Worker] Cannot analyze - initialization failed:', initializationError);
    self.postMessage({
      type: 'diagnostics',
      payload: {
        diagnostics: [{
          message: `Failed to load analyzer: ${initializationError.message}`,
          startLineNumber: 1,
          startColumn: 1,
          endLineNumber: 1,
          endColumn: 2,
          severity: 'error'
        }],
        summary: 'Diagnostics initialization failed.'
      }
    });
    return;
  }

  // Check if still loading - should not happen after queue processing
  if (!analyzePieSource) {
    console.warn('[Worker] Unexpected state: analyzePieSource not loaded during queue processing');
    return;
  }

  try {
    const result = analyzePieSource(payload?.source ?? '');
    self.postMessage({
      type: 'diagnostics',
      payload: result
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    const stack = error instanceof Error ? error.stack : '';
    console.error('[Worker] Analysis error:', message, stack);
    self.postMessage({
      type: 'diagnostics',
      payload: {
        diagnostics: [{
          message: `Analysis error: ${message}`,
          startLineNumber: 1,
          startColumn: 1,
          endLineNumber: 1,
          endColumn: 2,
          severity: 'error'
        }],
        summary: 'Analysis failed.'
      }
    });
  }
}

// Dynamically import the bundle
(async () => {
  try {
    // Get the worker's base URL to resolve the bundle path correctly
    const workerUrl = new URL(self.location.href);
    const bundlePath = new URL('./pie-worker-bundle.js', workerUrl).href;

    console.log('[Worker] Attempting to load bundle from:', bundlePath);

    const module = await import(bundlePath);
    analyzePieSource = module.analyzePieSource;

    console.log('[Worker] Bundle loaded successfully');
    console.log('[Worker] analyzePieSource:', typeof analyzePieSource);

    // Process queued messages
    if (messageQueue.length > 0) {
      console.log(`[Worker] Processing ${messageQueue.length} queued message(s)`);
      while (messageQueue.length > 0) {
        const event = messageQueue.shift();
        processMessage(event);
      }
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    const stack = error instanceof Error ? error.stack : '';
    initializationError = { message, stack };
    console.error('[Worker] Failed to load bundle:', message, stack);

    // Send error to all queued messages
    while (messageQueue.length > 0) {
      messageQueue.shift(); // Clear queue
    }
  }
})();

console.log('[Worker] Diagnostics worker loaded successfully');

self.onmessage = event => {
  console.log('[Worker] Received message:', event.data);

  // If bundle is not loaded yet and no error, queue the message
  if (!analyzePieSource && !initializationError) {
    console.log('[Worker] Bundle still loading, queueing message...');
    messageQueue.push(event);
    return;
  }

  // Otherwise process immediately
  processMessage(event);
};
</file>

<file path="src/pie_interpreter/__tests__/test_lsp.pie">
(claim identity (-> Nat Nat))
(define-tactically identity 
  ((intro n)
   (exact TODO)))


(claim nat Nat)
(define nat 'nat)
</file>

<file path="src/pie_interpreter/__tests__/test_parse_evaluate.ts">
import 'jest';
import { evaluatePie } from '../main'

describe("Parser Evaluate Integration Tests", () => {
  it("Evaluate Bool (no params, no indices)", () => {
    const input =
    `(data Bool () ()
      (true () (Bool () ()))
      (false () (Bool () ()))
      ind-Bool)

    (claim my-true (Bool () ()))
    (define my-true (true))

    (claim my-false (Bool () ()))
    (define my-false (false))

    (claim bool-to-nat (-> (Bool () ()) Nat))
    (define bool-to-nat
      (lambda (b)
        (ind-Bool b
          (lambda (x) Nat)
          (add1 zero)
          zero)))

    (claim result1 Nat)
    (define result1 (bool-to-nat my-true))

    (claim result2 Nat)
    (define result2 (bool-to-nat my-false))
    `;
    const result = evaluatePie(input);
  });

  it("Evaluate MyNat (no params, no indices)", () => {
    const input = `
    (data MyNat () ()
      (myZero () (MyNat () ()))
      (mySucc ((n (MyNat () ()))) (MyNat () ()))
      ind-MyNat)

    (claim zero-nat (MyNat () ()))
    (define zero-nat (myZero))

    (claim two-nat (MyNat () ()))
    (define two-nat (mySucc (mySucc zero-nat)))

    (claim count (-> (MyNat () ()) Nat))
    (define count
      (lambda (n)
        (ind-MyNat n
          (lambda (x) Nat)
          zero
          (lambda (n-1 ih) (add1 ih)))))

    (claim result Nat)
    (define result (count two-nat))
    `;
    const result = evaluatePie(input);
  });

  it("Evaluate MyList (parameterized, no indices)", () => {
    const input = `
    (data MyList ((E U)) ()
      (myNil () (MyList (E) ()))
      (myCons ((head E) (tail (MyList (E) ()))) (MyList (E) ()))
      ind-MyList)

    (claim empty-list (MyList (Nat) ()))
    (define empty-list (myNil))

    (claim one-elem-list (MyList (Nat) ()))
    (define one-elem-list (myCons zero empty-list))

    (claim two-elem-list (MyList (Nat) ()))
    (define two-elem-list (myCons (add1 zero) one-elem-list))

    (claim nat-list-length (-> (MyList (Nat) ()) Nat))
    (define nat-list-length
      (lambda (xs)
        (ind-MyList xs
          (lambda (l) Nat)
          zero
          (lambda (h t ih) (add1 ih)))))

    (claim result Nat)
    (define result (nat-list-length two-elem-list))
    `;
    const result = evaluatePie(input);
  });

  it("Evaluate MyVec (parameterized and indexed)", () => {
    const input = `
    (data MyVec ((E U)) ((n Nat))
      (myVecNil () (MyVec (E) (zero)))
      (myVecCons ((k Nat) (head E) (tail (MyVec (E) (k)))) (MyVec (E) ((add1 k))))
      ind-MyVec)

    (claim empty-vec (MyVec (Nat) (zero)))
    (define empty-vec (myVecNil))

    (claim one-vec (MyVec (Nat) ((add1 zero))))
    (define one-vec (myVecCons zero (add1 zero) empty-vec))

    (claim vec-to-nat (Pi ((n Nat)) (-> (MyVec (Nat) (n)) Nat)))
    (define vec-to-nat
      (lambda (n v)
        (ind-MyVec v
          (lambda (len vec) Nat)
          zero
          (lambda (k h t ih) (add1 ih)))))

    (claim result Nat)
    (define result (vec-to-nat (add1 zero) one-vec))
    `;
    const result = evaluatePie(input);
  });

  it("Evaluate Less-Than (no params, indexed)", () => {
    const input = `
    (data Less-Than () ((j Nat) (k Nat))
      (zero-smallest ((n Nat)) (Less-Than () (zero (add1 n))))
      (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than () (j k)))) (Less-Than () ((add1 j) (add1 k))))
      ind-Less-Than)

    (claim proof-0<1 (Less-Than () (zero (add1 zero))))
    (define proof-0<1 (zero-smallest zero))

    (claim proof-1<2 (Less-Than () ((add1 zero) (add1 (add1 zero)))))
    (define proof-1<2 (add1-smaller zero (add1 zero) proof-0<1))

    (claim extract-smaller
      (Pi ((j Nat) (k Nat))
        (-> (Less-Than () (j k)) Nat)))
    (define extract-smaller
      (lambda (j k proof)
        (ind-Less-Than proof
          (lambda (j-idx k-idx p) Nat)
          (lambda (n) zero)
          (lambda (j-arg k-arg j<k-arg ih) (add1 ih)))))

    (claim result Nat)
    (define result (extract-smaller zero (add1 zero) proof-0<1))
    `;
    const result = evaluatePie(input);
  });

  it("Evaluate MyEither (parameterized, no indices)", () => {
    const input = `
    (data MyEither ((L U) (R U)) ()
      (myLeft ((value L)) (MyEither (L R) ()))
      (myRight ((value R)) (MyEither (L R) ()))
      ind-MyEither)

    (claim left-val (MyEither (Nat Atom) ()))
    (define left-val (myLeft zero))

    (claim right-val (MyEither (Nat Atom) ()))
    (define right-val (myRight (quote foo)))

    (claim either-to-nat (-> (MyEither (Nat Atom) ()) Nat))
    (define either-to-nat
      (lambda (e)
        (ind-MyEither e
          (lambda (x) Nat)
          (lambda (lval) (add1 zero))
          (lambda (rval) zero))))

    (claim result1 Nat)
    (define result1 (either-to-nat left-val))

    (claim result2 Nat)
    (define result2 (either-to-nat right-val))
    `;
    const result = evaluatePie(input);
    console.log(result);
  });
});
</file>

<file path="src/pie_interpreter/__tests__/test_subtype.ts">
import 'jest';
import { evaluatePie } from '../main'

describe("Test subtyping", () => {
  it("Evaluate Bool (no params, no indices)", () => {
    const input =
    `
(data Subtype () ((T1 U) (T2 U))
  (refl ((T U))
    (Subtype () (T T)))
  (trans ((T1 U) (T2 U) (T3 U)
          (p1 (Subtype () (T1 T2)))
          (p2 (Subtype () (T2 T3))))
    (Subtype () (T1 T3)))
  ;; Generic injection: if there exists a function A -> B, then A <: B
  (inject ((A U) (B U) (f (-> A B)))
    (Subtype () (A B)))
  ind-Subtype)

(claim coerce
  (Pi ((A U) (B U))
    (-> (Subtype () (A B)) A B)))
(define coerce
  (lambda (A B proof val)
    ((ind-Subtype proof
      (lambda (t1 t2 sub) (-> t1 t2))
      (lambda (TT x) x)
      (lambda (T11 T22 T33 p1 p2 ih1 ih2 x)
        (ih2 (ih1 x)))
      (lambda (AA BB ff x) (ff x))
      )
      val)))

(data Even () ((n Nat))
  (zero-even ()
    (Even () (zero)))
  (add2-even ((k Nat) (k-even (Even () (k))))
    (Even () ((add1 (add1 k)))))
  ind-Even)

(claim even-to-nat
  (Pi ((n Nat))
    (-> (Even () (n)) Nat)))
(define even-to-nat
  (lambda (n proof)
    (ind-Even proof
      (lambda (m ev) Nat)
      zero
      (lambda (k prev ih) (add1 (add1 ih))))))

(claim even-subtype-nat
  (Pi ((n Nat))
    (Subtype () ((Even () (n)) Nat))))
(define even-subtype-nat
  (lambda (n)
    (inject (Even () (n)) Nat (even-to-nat n))))

(claim + (-> Nat Nat Nat))
(define +
  (lambda (a b)
    (rec-Nat a
      b
      (lambda (pred ih) (add1 ih)))))

(claim double (-> Nat Nat))
(define double
  (lambda (n)
    (+ n n)))

;; Use Even with double
(claim double-even
  (Pi ((n Nat))
    (-> (Even () (n)) Nat)))
(define double-even
  (lambda (n ev)
    (double (coerce (Even () (n)) Nat
                    (even-subtype-nat n)
                    ev))))


(claim even-four (Even () ((add1 (add1 (add1 (add1 zero)))))))
(define even-four
  (add2-even (add1 (add1 zero))
    (add2-even zero
      (zero-even))))

(claim result2 Nat)
(define result2 (double-even (add1 (add1 (add1 (add1 zero)))) even-four))
        `
    const result = evaluatePie(input);
    console.log(result);
  })
})
</file>

<file path="src/pie_interpreter/utils/alphaeqv.ts">
import * as C from '../types/core';
import { isVarName } from '../types/utils';
import { SourceLocation } from './locations';

export function alphaEquiv(e1: C.Core, e2: C.Core): boolean {
  return alphaEquivAux(0, new Map(), new Map(), e1, e2);
}

type Bindings = Map<string, number>;

const FV = -1;

function bind(b: Bindings, x: string, lvl: number): Bindings {
  return b.set(x, lvl) as Bindings;
}

function findBinding(x: string, b: Bindings): number {
  if (b.has(x)) {
    return b.get(x)!;
  }
  // x is not bound, return -1.
  return FV;
}

function alphaEquivAux(lvl: number, b1: Bindings, b2: Bindings, e1: C.Core, e2: C.Core): boolean {
  if (e1 instanceof C.VarName && e2 instanceof C.VarName) {
    const n1 = e1.name;
    const n2 = e2.name;
    if (isVarName(n1) && isVarName(n2)) {
      const xBinding = findBinding(n1, b1);
      const yBinding = findBinding(n2, b2);
      // both bound
      if (xBinding !== FV && yBinding !== FV) {
        return xBinding === yBinding;
      } else if (xBinding === FV && yBinding === FV) {
        // both free
        return n1 === n2;
      } else {
        // one bound, one free
        return false;
      }
      // Compare to the original version,
      // the contructor equality is not considered here as our
      // implementations of constructors are different.
      // Orginally using strings, we use classes.
      // they will be dealt with in the following cases.
    } else {
      return false;
    }
  } else if (e1 instanceof C.Quote && e2 instanceof C.Quote) {
    // Atoms must be the same atom
    return e1.sym === e2.sym;

  } else if (e1 instanceof C.Pi && e2 instanceof C.Pi) {
    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type)
      &&
      alphaEquivAux(lvl + 1, bind(b1, e1.name, lvl), bind(b2, e2.name, lvl), e1.body, e2.body);

  } else if (e1 instanceof C.Sigma && e2 instanceof C.Sigma) {
    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type)
      &&
      alphaEquivAux(lvl + 1, bind(b1, e1.name, lvl), bind(b2, e2.name, lvl), e1.body, e2.body);

  } else if (e1 instanceof C.Lambda && e2 instanceof C.Lambda) {
    return alphaEquivAux(
      lvl + 1,
      bind(b1, e1.param, lvl),
      bind(b2, e2.param, lvl),
      e1.body,
      e2.body
    );

  } else if (e1 instanceof C.The
    && e2 instanceof C.The
    && e1.type instanceof C.Absurd
    && e2.type instanceof C.Absurd) {
    return true;

  } else if (e1 instanceof C.Application && e2 instanceof C.Application) {
    return alphaEquivAux(lvl, b1, b2, e1.fun, e2.fun)
      &&
      alphaEquivAux(lvl, b1, b2, e1.arg, e2.arg);

  }
  // following cases are one word constructors 
  else if (
    (e1 instanceof C.Universe && e2 instanceof C.Universe) ||
    (e1 instanceof C.Nat && e2 instanceof C.Nat) ||
    (e1 instanceof C.Zero && e2 instanceof C.Zero) ||
    (e1 instanceof C.Atom && e2 instanceof C.Atom) ||
    (e1 instanceof C.Absurd && e2 instanceof C.Absurd) ||
    (e1 instanceof C.Sole && e2 instanceof C.Sole) ||
    (e1 instanceof C.Nil && e2 instanceof C.Nil) ||
    (e1 instanceof C.VecNil && e2 instanceof C.VecNil) ||
    (e1 instanceof C.Trivial && e2 instanceof C.Trivial)
  ) {
    return true;
  }
  // following cases are for multiple word constructors, and eliminators.
  else if (e1 instanceof C.The && e2 instanceof C.The) {
    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type)
      &&
      alphaEquivAux(lvl, b1, b2, e1.expr, e2.expr);
  } else if (e1 instanceof C.List && e2 instanceof C.List) {
    return alphaEquivAux(lvl, b1, b2, e1.elemType, e2.elemType);
  } else if (e1 instanceof C.Add1 && e2 instanceof C.Add1) {
    return alphaEquivAux(lvl, b1, b2, e1.n, e2.n);

  } else if (e1 instanceof C.WhichNat && e2 instanceof C.WhichNat) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base)
      &&
      alphaEquivAux(lvl, b1, b2, e1.step, e2.step);

  } else if (e1 instanceof C.IterNat && e2 instanceof C.IterNat) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base)
      &&
      alphaEquivAux(lvl, b1, b2, e1.step, e2.step);
  } else if (e1 instanceof C.RecNat && e2 instanceof C.RecNat) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base)
      &&
      alphaEquivAux(lvl, b1, b2, e1.step, e2.step);
  } else if (e1 instanceof C.IndNat && e2 instanceof C.IndNat) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base)
      &&
      alphaEquivAux(lvl, b1, b2, e1.step, e2.step);
  } else if (e1 instanceof C.Cons && e2 instanceof C.Cons) {
    return alphaEquivAux(lvl, b1, b2, e1.first, e2.first)
      &&
      alphaEquivAux(lvl, b1, b2, e1.second, e2.second);
  } else if (e1 instanceof C.Car && e2 instanceof C.Car) {
    return alphaEquivAux(lvl, b1, b2, e1.pair, e2.pair);
  } else if (e1 instanceof C.Cdr && e2 instanceof C.Cdr) {
    return alphaEquivAux(lvl, b1, b2, e1.pair, e2.pair);
  } else if (e1 instanceof C.ListCons && e2 instanceof C.ListCons) {
    return alphaEquivAux(lvl, b1, b2, e1.head, e2.head)
      &&
      alphaEquivAux(lvl, b1, b2, e1.tail, e2.tail);
  } else if (e1 instanceof C.RecList && e2 instanceof C.RecList) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base)
      &&
      alphaEquivAux(lvl, b1, b2, e1.step, e2.step);
  } else if (e1 instanceof C.IndList && e2 instanceof C.IndList) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base)
      &&
      alphaEquivAux(lvl, b1, b2, e1.step, e2.step);
  } else if (e1 instanceof C.IndAbsurd && e2 instanceof C.IndAbsurd) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive);
  } else if (e1 instanceof C.Equal && e2 instanceof C.Equal) {
    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type)
      &&
      alphaEquivAux(lvl, b1, b2, e1.left, e2.left)
      &&
      alphaEquivAux(lvl, b1, b2, e1.right, e2.right);

  } else if (e1 instanceof C.Same && e2 instanceof C.Same) {
    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type);

  } else if (e1 instanceof C.Replace && e2 instanceof C.Replace) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base);

  } else if (e1 instanceof C.Trans && e2 instanceof C.Trans) {
    return alphaEquivAux(lvl, b1, b2, e1.left, e2.left)
      &&
      alphaEquivAux(lvl, b1, b2, e1.right, e2.right);

  } else if (e1 instanceof C.Cong && e2 instanceof C.Cong) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base)
      &&
      alphaEquivAux(lvl, b1, b2, e1.fun, e2.fun);
  } else if (e1 instanceof C.Symm && e2 instanceof C.Symm) {
    return alphaEquivAux(lvl, b1, b2, e1.equality, e2.equality);

  } else if (e1 instanceof C.IndEqual && e2 instanceof C.IndEqual) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base);
  } else if (e1 instanceof C.Vec && e2 instanceof C.Vec) {
    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type)
      &&
      alphaEquivAux(lvl, b1, b2, e1.length, e2.length)
  } else if (e1 instanceof C.VecCons && e2 instanceof C.VecCons) {
    return alphaEquivAux(lvl, b1, b2, e1.head, e2.head)
      &&
      alphaEquivAux(lvl, b1, b2, e1.tail, e2.tail);
  } else if (e1 instanceof C.Head && e2 instanceof C.Head) {
    return alphaEquivAux(lvl, b1, b2, e1.vec, e2.vec);
  } else if (e1 instanceof C.Tail && e2 instanceof C.Tail) {
    return alphaEquivAux(lvl, b1, b2, e1.vec, e2.vec);
  } else if (e1 instanceof C.IndVec && e2 instanceof C.IndVec) {
    return alphaEquivAux(lvl, b1, b2, e1.length, e2.length)
      &&
      alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)
      &&
      alphaEquivAux(lvl, b1, b2, e1.base, e2.base)
      &&
      alphaEquivAux(lvl, b1, b2, e1.step, e2.step);
  } else if (e1 instanceof C.Either && e2 instanceof C.Either) {
    return alphaEquivAux(lvl, b1, b2, e1.left, e2.left)
      &&
      alphaEquivAux(lvl, b1, b2, e1.right, e2.right);
  } else if (e1 instanceof C.Left && e2 instanceof C.Left) {
    return alphaEquivAux(lvl, b1, b2, e1.value, e2.value);
  } else if (e1 instanceof C.Right && e2 instanceof C.Right) {
    return alphaEquivAux(lvl, b1, b2, e1.value, e2.value);
  } else if (e1 instanceof C.IndEither && e2 instanceof C.IndEither) {
    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)
      &&
      alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)
      &&
      alphaEquivAux(lvl, b1, b2, e1.baseLeft, e2.baseLeft)
      &&
      alphaEquivAux(lvl, b1, b2, e1.baseRight, e2.baseRight);
  } else if (e1 instanceof C.TODO && e2 instanceof C.TODO) {
    return sameLocation(e1.loc, e2.loc) && alphaEquivAux(lvl, b1, b2, e1.type, e2.type);
  } else if (e1 instanceof C.InductiveTypeConstructor && e2 instanceof C.InductiveTypeConstructor) {
    // Check that names match and parameters/indices are alpha-equivalent
    if (e1.typeName !== e2.typeName) return false;
    if (e1.parameters.length !== e2.parameters.length) return false;
    if (e1.indices.length !== e2.indices.length) return false;
    for (let i = 0; i < e1.parameters.length; i++) {
      if (!alphaEquivAux(lvl, b1, b2, e1.parameters[i], e2.parameters[i])) return false;
    }
    for (let i = 0; i < e1.indices.length; i++) {
      if (!alphaEquivAux(lvl, b1, b2, e1.indices[i], e2.indices[i])) return false;
    }
    return true;
  }
  // if none of the above cases are met, return false.
  else {
    return false;
  }
}

function sameLocation(e1: SourceLocation, e2: SourceLocation): boolean {
  return e1.startLine === e2.startLine &&
    e1.startColumn === e2.startColumn &&
    e1.endLine === e2.endLine &&
    e1.endColumn === e2.endColumn;
}
</file>

<file path="web/app.js">
const examples = {
  'Hello World': `(claim zero Nat)
(define zero zero)

(claim add1zero Nat)
(define add1zero (add1 zero))`,

  'Natural Number Addition': `(claim +
  (→ Nat Nat Nat))

(claim step-plus
  (→ Nat Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1)))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus)))

(claim result Nat)
(define result (+ 2 3))`,

  'List Length': `(claim length
  (Π ((E U))
    (→ (List E) Nat)))

(claim step-length
  (Π ((E U))
    (→ E (List E) Nat Nat)))

(define step-length
  (λ (E)
    (λ (e es length-es)
      (add1 length-es))))

(define length
  (λ (E)
    (λ (es)
      (rec-List es
        0
        (step-length E)))))

(claim my-list (List Nat))
(define my-list (:: 1 (:: 2 (:: 3 nil))))

(claim list-len Nat)
(define list-len (length Nat my-list))`,

  'Either Type': `(claim either-swap
  (Pi ((A U) (B U))
    (-> (Either A B)
        (Either B A))))

(define either-swap
  (lambda (A B)
    (lambda (e)
      (ind-Either e
        (lambda (x) (Either B A))
        (lambda (a) (right a))
        (lambda (b) (left b))))))

(claim test-either (Either Nat Nat))
(define test-either (left zero))

(claim swapped (Either Nat Nat))
(define swapped (either-swap Nat Nat test-either))`,

  'Vector Map': `(claim vec-map
  (Π ((A U) (B U) (n Nat))
     (-> (-> A B) (Vec A n)
         (Vec B n))))

(define vec-map
  (λ (A B n)
    (λ (f vs)
      (ind-Vec n vs
        (λ (k xs) (Vec B k))
        vecnil
        (λ (k x xs ih) (vec:: (f x) ih))))))

(claim nat-vec (Vec Nat 3))
(define nat-vec (vec:: 1 (vec:: 2 (vec:: 3 vecnil))))

(claim add1-fn (-> Nat Nat))
(define add1-fn (λ (n) (add1 n)))

(claim incremented-vec (Vec Nat 3))
(define incremented-vec (vec-map Nat Nat 3 add1-fn nat-vec))`,
'Tactics: Even or Odd' : `
(claim +
  (→ Nat Nat
    Nat))

(claim step-plus
  (→ Nat
    Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1 ) ))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus )))

(claim double
  (→ Nat
    Nat))

(define double
  (λ (n)
    (iter-Nat n
      0
      (+ 2))))

(claim Even
  (→ Nat
    U ))

(define Even
  (λ (n)
    (Σ ((half Nat))
      (= Nat n (double half )))))

(claim Odd
  (→ Nat
    U ))

(define Odd
  (λ (n)
    (Σ ((haf Nat))
      (= Nat n (add1 (double haf )))))) 

(claim zero-is-even
  (Even 0))

(define zero-is-even
  (cons 0
    (same 0)))

(claim add1-even->odd
  (Π ((n Nat))
    (→ (Even n)
    (Odd (add1 n)))))

(define add1-even->odd
  (λ (n en)
    (cons (car en)
    (cong (cdr en) (+ 1)))))

(claim add1-odd->even
  (Π ((n Nat))
    (→ (Odd n)
      (Even (add1 n)))))

(define add1-odd->even
  (λ (n on)
    (cons (add1 (car on))
      (cong (cdr on) (+ 1)))))

(claim even-or-odd
  (Π ((n Nat))
    (Either (Even n) (Odd n))))

;; This is the proof in The Little Typer
;; (claim mot-even-or-odd
;;   (→ Nat U )) 

;; (define mot-even-or-odd
;;   (λ (k) (Either (Even k) (Odd k))))

;; (claim step-even-or-odd
;;   (Π ((n-1 Nat))
;;      (→ (mot-even-or-odd n-1)
;;      (mot-even-or-odd (add1 n-1)))))

;; (define step-even-or-odd
;;   (λ (n-1)
;;     (λ (e-or-on-1)
;;        (ind-Either e-or-on-1
;;     (λ (e-or-on-1)
;;        (mot-even-or-odd (add1 n-1)))
;;        (λ (en-1)
;;          (right
;;            (add1-even->odd
;;              n-1 en-1)))
;;        (λ (on-1)
;;          (left
;;            (add1-odd->even
;;              n-1 on-1)))))))

;; (define even-or-odd
;;   (λ (n)
;;     (ind-Nat n
;;        mot-even-or-odd
;;        (left zero-is-even)
;;        step-even-or-odd)))


;; This is the proof using our new tactic system
(define-tactically even-or-odd
  ( (intro n)
    (elimNat n)
    (left)
    (exact zero-is-even)
    (intro n-1)
    (intro e-or-on-1)
    (elimEither e-or-on-1)
    (intro xr)
    (right)
    (exact ((add1-even->odd n-1) xr))
    (intro x1)
    (left)
    ;; finish the proof with "(exact ((add1-odd->even n-1) x1))"
   ))`,
   'Inductive Type: Less Than': `;; Define Less Than relation using our new inductive type definiton
    (data Less-Than () ((j Nat) (k Nat))
      (zero-smallest ((n Nat)) (Less-Than () (zero (add1 n))))
      (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than () (j k)))) (Less-Than () ((add1 j) (add1 k))))
      ind-Less-Than)

    (claim proof-0<1 (Less-Than () (zero (add1 zero))))
    (define proof-0<1 (zero-smallest zero))

    (claim proof-1<2 (Less-Than () ((add1 zero) (add1 (add1 zero)))))
    (define proof-1<2 (add1-smaller zero (add1 zero) proof-0<1))

    (claim extract-smaller
      (Pi ((j Nat) (k Nat))
        (-> (Less-Than () (j k)) Nat)))
    (define extract-smaller
      (lambda (j k proof)
        (ind-Less-Than proof
          (lambda (j-idx k-idx p) Nat)
          (lambda (n) zero)
          (lambda (j-arg k-arg j<k-arg ih) (add1 ih)))))

    (claim result Nat)
    (define result (extract-smaller zero (add1 zero) proof-0<1))
    `,
    'Inductive Type: Subtype':`
(data Subtype () ((T1 U) (T2 U))
  (refl ((T U))
    (Subtype () (T T)))
  (trans ((T1 U) (T2 U) (T3 U)
          (p1 (Subtype () (T1 T2)))
          (p2 (Subtype () (T2 T3))))
    (Subtype () (T1 T3)))
  ;; Generic injection: if there exists a function A -> B, then A <: B
  (inject ((A U) (B U) (f (-> A B)))
    (Subtype () (A B)))
  ind-Subtype)

(claim coerce
  (Pi ((A U) (B U))
    (-> (Subtype () (A B)) A B)))
(define coerce
  (lambda (A B proof val)
    ((ind-Subtype proof
      (lambda (t1 t2 sub) (-> t1 t2))
      (lambda (TT x) x)
      (lambda (T11 T22 T33 p1 p2 ih1 ih2 x)
        (ih2 (ih1 x)))
      (lambda (AA BB ff x) (ff x))
      )
      val)))

(data Even () ((n Nat))
  (zero-even ()
    (Even () (zero)))
  (add2-even ((k Nat) (k-even (Even () (k))))
    (Even () ((add1 (add1 k)))))
  ind-Even)

(claim even-to-nat
  (Pi ((n Nat))
    (-> (Even () (n)) Nat)))
(define even-to-nat
  (lambda (n proof)
    (ind-Even proof
      (lambda (m ev) Nat)
      zero
      (lambda (k prev ih) (add1 (add1 ih))))))

(claim even-subtype-nat
  (Pi ((n Nat))
    (Subtype () ((Even () (n)) Nat))))
(define even-subtype-nat
  (lambda (n)
    (inject (Even () (n)) Nat (even-to-nat n))))

(claim + (-> Nat Nat Nat))
(define +
  (lambda (a b)
    (rec-Nat a
      b
      (lambda (pred ih) (add1 ih)))))

(claim double (-> Nat Nat))
(define double
  (lambda (n)
    (+ n n)))

;; Use Even with double
(claim double-even
  (Pi ((n Nat))
    (-> (Even () (n)) Nat)))
(define double-even
  (lambda (n ev)
    (double (coerce (Even () (n)) Nat
                    (even-subtype-nat n)
                    ev))))


(claim even-four (Even () ((add1 (add1 (add1 (add1 zero)))))))
(define even-four
  (add2-even (add1 (add1 zero))
    (add2-even zero
      (zero-even))))

(claim result2 Nat)
(define result2 (double-even (add1 (add1 (add1 (add1 zero)))) even-four))
        `
};

const defaultSource = examples['Hello World'];

const status = document.getElementById('status-pill');
const previewSummary = document.getElementById('preview-summary');
const previewOutput = document.getElementById('preview-output');

let diagnosticsWorker = null;
let monacoApi = null;

function setStatus(message) {
  if (status) {
    status.textContent = message;
  }
}

function setSummary(message, tone = 'neutral') {
  previewSummary.textContent = message;
  previewSummary.dataset.tone = tone;
}

function renderPreviewText(text, tone) {
  if (tone) {
    previewOutput.dataset.tone = tone;
  } else {
    delete previewOutput.dataset.tone;
  }

  if (text === undefined) {
    previewOutput.textContent = 'Program is empty.';
  } else {
    previewOutput.textContent = text;
  }
}

function applyDiagnostics(monaco, editor, payload) {
  const { diagnostics, pretty } = payload;
  const model = editor.getModel();

  const markers = diagnostics.map(d => ({
    startLineNumber: d.startLineNumber,
    startColumn: d.startColumn,
    endLineNumber: d.endLineNumber,
    endColumn: d.endColumn,
    message: d.message,
    severity: d.severity === 'warning'
      ? monaco.MarkerSeverity.Warning
      : monaco.MarkerSeverity.Error
  }));

  monaco.editor.setModelMarkers(model, 'pie-playground', markers);

  if (diagnostics.length === 0) {
    setSummary('SUCCESS', 'success');
    setStatus('All clear');
    renderPreviewText(pretty?.trim() ?? undefined, 'success');
    return;
  }

  const primary = diagnostics[0];
  const tone = primary.severity === 'warning' ? 'warning' : 'error';
  const label = tone === 'warning' ? 'WARNING' : 'ERROR';
  const statusLabel = diagnostics.length > 1
    ? `${diagnostics.length} issues`
    : tone === 'warning' ? 'Warning found' : 'Issue found';

  setSummary(label, tone);
  setStatus(statusLabel);
  const location = `Line ${primary.startLineNumber}, Col ${primary.startColumn}`;
  renderPreviewText(`${location}\n${primary.message}`, tone);
}

function initializeDiagnostics(editor) {
  if (!('Worker' in window)) {
    setSummary('Diagnostics unavailable in this browser.', 'warning');
    return null;
  }

  const worker = new Worker('diagnostics-worker.js', { type: 'module' });
  worker.onmessage = event => {
    const { type, payload } = event.data;
    if (type === 'diagnostics' && monacoApi) {
      applyDiagnostics(monacoApi, editor, payload);
    }
  };

  worker.onerror = (error) => {
    console.error('Worker error event:', error);
    console.error('Error details:', {
      message: error.message,
      filename: error.filename,
      lineno: error.lineno,
      colno: error.colno
    });
    setSummary('Diagnostics worker crashed.', 'error');
    setStatus('Diagnostics error');
    renderPreviewText(
      `Worker failed to load. Check browser console for details.\nError: ${error.message || 'Unknown error'}`,
      'error'
    );
  };

  return worker;
}

function initializeEditor(monaco, registerLanguage) {
  if (typeof registerLanguage === 'function') {
    registerLanguage(monaco);
  } else if (monaco?.languages && !monaco.languages.getLanguages().some(lang => lang.id === 'pie')) {
    monaco.languages.register({ id: 'pie' });
  }

  const editor = monaco.editor.create(document.getElementById('editor'), {
    value: defaultSource,
    language: 'pie',
    theme: 'vs-dark',
    automaticLayout: true,
    minimap: {
      enabled: false
    },
    scrollbar: {
      vertical: 'auto',
      horizontal: 'auto',
      useShadows: false,
      verticalScrollbarSize: 6,
      verticalSliderSize: 4
    },
    padding: { top: 16 },
    fontSize: 14,
    fontFamily: "Menlo, 'Fira Code', 'JetBrains Mono', monospace",
    smoothScrolling: true
  });

  renderPreviewText(defaultSource.trim());
  setSummary('Ready for analysis.', 'neutral');
  setStatus('Editor loaded');

  const debounced = debounce((text) => {
    if (text.trim().length === 0) {
      setSummary('Waiting for input…', 'neutral');
      renderPreviewText(undefined);
    } else {
      setSummary('Running checks…', 'warning');
      renderPreviewText('Analyzing…');
    }
    setStatus('Typing…');
  }, 120);

  const queueDiagnostics = debounce((text) => {
    setSummary('Running checks…', 'warning');
    if (diagnosticsWorker) {
      diagnosticsWorker.postMessage({
        type: 'analyze',
        payload: { source: text }
      });
    }
  }, 220);

  editor.onDidChangeModelContent(() => {
    const content = editor.getValue();
    debounced(content);
    queueDiagnostics(content);
  });

  editor.onDidBlurEditorWidget(() => {
    setStatus('Idle');
  });

  return editor;
}

function initializeExamplePicker(editor) {
  const picker = document.getElementById('example-picker');

  // Populate the dropdown
  Object.keys(examples).forEach(name => {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    picker.appendChild(option);
  });

  // Set initial value
  picker.value = 'Hello World';

  // Handle selection
  picker.addEventListener('change', (e) => {
    const exampleName = e.target.value;
    if (exampleName && examples[exampleName]) {
      editor.setValue(examples[exampleName]);
    }
  });
}

function initializeCopyButton(editor) {
  // Use event delegation on document to handle click even if button is replaced
  // Only attach once by checking a flag
  if (window.__copyBtnInitialized) return;
  window.__copyBtnInitialized = true;

  document.addEventListener('click', async (e) => {
    const copyBtn = e.target.closest('#copy-btn');
    if (!copyBtn) return;

    const code = editor.getValue();
    try {
      await navigator.clipboard.writeText(code);
      copyBtn.textContent = 'Copied!';
      copyBtn.dataset.copied = 'true';
      setTimeout(() => {
        copyBtn.textContent = 'Copy';
        delete copyBtn.dataset.copied;
      }, 1500);
    } catch (err) {
      console.error('Failed to copy:', err);
      copyBtn.textContent = 'Failed';
      setTimeout(() => {
        copyBtn.textContent = 'Copy';
      }, 1500);
    }
  });
}

async function initializeLSP(PieLanguageClientCtor, monacoInstance, editor) {
  if (!PieLanguageClientCtor) {
    return null;
  }

  try {
    const lspClient = new PieLanguageClientCtor(monacoInstance, editor);
    await lspClient.start();
    console.log('LSP client initialized successfully');
    return lspClient;
  } catch (error) {
    console.error('Failed to initialize LSP client:', error);
    console.log('LSP features will not be available. Falling back to basic diagnostics.');
    return null;
  }
}

async function boot() {
  if (!window.require) {
    setStatus('Failed to load editor runtime');
    return;
  }

  window.require.config({
    paths: {
      vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.0/min/vs'
    }
  });

  window.require(['vs/editor/editor.main'], async () => {
    monacoApi = window.monaco;

    let PieLanguageClientCtor = null;
    let registerPieLanguage = null;

    try {
      const lspModule = await import('./lsp/lsp-client-bundle.js');
      PieLanguageClientCtor = lspModule.PieLanguageClient;
      registerPieLanguage = lspModule.registerPieLanguage;
    } catch (error) {
      console.error('Failed to load LSP bundle:', error);
      console.log('Continuing without enhanced LSP features.');
    }

    const editor = initializeEditor(monacoApi, registerPieLanguage);
    diagnosticsWorker = initializeDiagnostics(editor);
    initializeExamplePicker(editor);
    initializeCopyButton(editor);

    const lspClient = await initializeLSP(PieLanguageClientCtor, monacoApi, editor);

    if (diagnosticsWorker) {
      diagnosticsWorker.postMessage({
        type: 'analyze',
        payload: { source: editor.getValue() }
      });
    }
    window.__pieEditor = editor;
    window.__pieLSPClient = lspClient;
  });
}

function debounce(fn, delay) {
  let handle;
  return function debounced(...args) {
    window.clearTimeout(handle);
    handle = window.setTimeout(() => fn.apply(this, args), delay);
  };
}

boot();
</file>

<file path="web/app.ts">
import { PieLanguageClient, registerPieLanguage } from './lsp/lsp-client-simple';
import { ProofTreeVisualizer } from './proof-tree/ProofTreeVisualizer';
import { ContextPanel } from './proof-tree/ContextPanel';
import { GoalPanel } from './proof-tree/GoalPanel';
import type { ProofTreeData } from './proof-tree/types';
import type * as Monaco from 'monaco-editor';

// Extend Window interface to include Monaco globals
declare global {
  interface Window {
    monaco: typeof Monaco;
    require: {
      (modules: string[], callback: (...args: any[]) => void): void;
      config(config: { paths: Record<string, string> }): void;
    };
  }
}

const examples = {
  'Hello World': `(claim zero Nat)
(define zero zero)

(claim add1zero Nat)
(define add1zero (add1 zero))`,

  'Natural Number Addition': `(claim +
  (→ Nat Nat Nat))

(claim step-plus
  (→ Nat Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1)))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus)))

(claim result Nat)
(define result (+ 2 3))`,

  'List Length': `(claim length
  (Π ((E U))
    (→ (List E) Nat)))

(claim step-length
  (Π ((E U))
    (→ E (List E) Nat Nat)))

(define step-length
  (λ (E)
    (λ (e es length-es)
      (add1 length-es))))

(define length
  (λ (E)
    (λ (es)
      (rec-List es
        0
        (step-length E)))))

(claim my-list (List Nat))
(define my-list (:: 1 (:: 2 (:: 3 nil))))

(claim list-len Nat)
(define list-len (length Nat my-list))`,

  'Either Type': `(claim either-swap
  (Pi ((A U) (B U))
    (-> (Either A B)
        (Either B A))))

(define either-swap
  (lambda (A B)
    (lambda (e)
      (ind-Either e
        (lambda (x) (Either B A))
        (lambda (a) (right a))
        (lambda (b) (left b))))))

(claim test-either (Either Nat Nat))
(define test-either (left zero))

(claim swapped (Either Nat Nat))
(define swapped (either-swap Nat Nat test-either))`,

  'Vector Map': `(claim vec-map
  (Π ((A U) (B U) (n Nat))
     (-> (-> A B) (Vec A n)
         (Vec B n))))

(define vec-map
  (λ (A B n)
    (λ (f vs)
      (ind-Vec n vs
        (λ (k xs) (Vec B k))
        vecnil
        (λ (k x xs ih) (vec:: (f x) ih))))))

(claim nat-vec (Vec Nat 3))
(define nat-vec (vec:: 1 (vec:: 2 (vec:: 3 vecnil))))

(claim add1-fn (-> Nat Nat))
(define add1-fn (λ (n) (add1 n)))

(claim incremented-vec (Vec Nat 3))
(define incremented-vec (vec-map Nat Nat 3 add1-fn nat-vec))`,
'Tactics: Even or Odd' : `
(claim +
  (→ Nat Nat
    Nat))

(claim step-plus
  (→ Nat
    Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1 ) ))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus )))

(claim double
  (→ Nat
    Nat))

(define double
  (λ (n)
    (iter-Nat n
      0
      (+ 2))))

(claim Even
  (→ Nat
    U ))

(define Even
  (λ (n)
    (Σ ((half Nat))
      (= Nat n (double half )))))

(claim Odd
  (→ Nat
    U ))

(define Odd
  (λ (n)
    (Σ ((haf Nat))
      (= Nat n (add1 (double haf )))))) 

(claim zero-is-even
  (Even 0))

(define zero-is-even
  (cons 0
    (same 0)))

(claim add1-even->odd
  (Π ((n Nat))
    (→ (Even n)
    (Odd (add1 n)))))

(define add1-even->odd
  (λ (n en)
    (cons (car en)
    (cong (cdr en) (+ 1)))))

(claim add1-odd->even
  (Π ((n Nat))
    (→ (Odd n)
      (Even (add1 n)))))

(define add1-odd->even
  (λ (n on)
    (cons (add1 (car on))
      (cong (cdr on) (+ 1)))))

(claim even-or-odd
  (Π ((n Nat))
    (Either (Even n) (Odd n))))

;; This is the proof in The Little Typer
;; (claim mot-even-or-odd
;;   (→ Nat U )) 

;; (define mot-even-or-odd
;;   (λ (k) (Either (Even k) (Odd k))))

;; (claim step-even-or-odd
;;   (Π ((n-1 Nat))
;;      (→ (mot-even-or-odd n-1)
;;      (mot-even-or-odd (add1 n-1)))))

;; (define step-even-or-odd
;;   (λ (n-1)
;;     (λ (e-or-on-1)
;;        (ind-Either e-or-on-1
;;     (λ (e-or-on-1)
;;        (mot-even-or-odd (add1 n-1)))
;;        (λ (en-1)
;;          (right
;;            (add1-even->odd
;;              n-1 en-1)))
;;        (λ (on-1)
;;          (left
;;            (add1-odd->even
;;              n-1 on-1)))))))

;; (define even-or-odd
;;   (λ (n)
;;     (ind-Nat n
;;        mot-even-or-odd
;;        (left zero-is-even)
;;        step-even-or-odd)))


;; This is the proof using our new tactic system
(define-tactically even-or-odd
  ( (intro n)
    (elimNat n)
    (left)
    (exact zero-is-even)
    (intro n-1)
    (intro e-or-on-1)
    (elimEither e-or-on-1)
    (intro xr)
    (right)
    (exact ((add1-even->odd n-1) xr))
    (intro x1)
    (left)
    ;; finish the proof with "(exact ((add1-odd->even n-1) x1))"
   ))`,
   'Inductive Type: Less Than': `;; Define Less Than relation using our new inductive type definiton
    (data Less-Than () ((j Nat) (k Nat))
      (zero-smallest ((n Nat)) (Less-Than () (zero (add1 n))))
      (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than () (j k)))) (Less-Than () ((add1 j) (add1 k))))
      ind-Less-Than)

    (claim proof-0<1 (Less-Than () (zero (add1 zero))))
    (define proof-0<1 (zero-smallest zero))

    (claim proof-1<2 (Less-Than () ((add1 zero) (add1 (add1 zero)))))
    (define proof-1<2 (add1-smaller zero (add1 zero) proof-0<1))

    (claim extract-smaller
      (Pi ((j Nat) (k Nat))
        (-> (Less-Than () (j k)) Nat)))
    (define extract-smaller
      (lambda (j k proof)
        (ind-Less-Than proof
          (lambda (j-idx k-idx p) Nat)
          (lambda (n) zero)
          (lambda (j-arg k-arg j<k-arg ih) (add1 ih)))))

    (claim result Nat)
    (define result (extract-smaller zero (add1 zero) proof-0<1))
    `,
    'Inductive Type: Subtype':`
(data Subtype () ((T1 U) (T2 U))
  (refl ((T U))
    (Subtype () (T T)))
  (trans ((T1 U) (T2 U) (T3 U)
          (p1 (Subtype () (T1 T2)))
          (p2 (Subtype () (T2 T3))))
    (Subtype () (T1 T3)))
  ;; Generic injection: if there exists a function A -> B, then A <: B
  (inject ((A U) (B U) (f (-> A B)))
    (Subtype () (A B)))
  ind-Subtype)

(claim coerce
  (Pi ((A U) (B U))
    (-> (Subtype () (A B)) A B)))
(define coerce
  (lambda (A B proof val)
    ((ind-Subtype proof
      (lambda (t1 t2 sub) (-> t1 t2))
      (lambda (TT x) x)
      (lambda (T11 T22 T33 p1 p2 ih1 ih2 x)
        (ih2 (ih1 x)))
      (lambda (AA BB ff x) (ff x))
      )
      val)))

(data Even () ((n Nat))
  (zero-even ()
    (Even () (zero)))
  (add2-even ((k Nat) (k-even (Even () (k))))
    (Even () ((add1 (add1 k)))))
  ind-Even)

(claim even-to-nat
  (Pi ((n Nat))
    (-> (Even () (n)) Nat)))
(define even-to-nat
  (lambda (n proof)
    (ind-Even proof
      (lambda (m ev) Nat)
      zero
      (lambda (k prev ih) (add1 (add1 ih))))))

(claim even-subtype-nat
  (Pi ((n Nat))
    (Subtype () ((Even () (n)) Nat))))
(define even-subtype-nat
  (lambda (n)
    (inject (Even () (n)) Nat (even-to-nat n))))

(claim + (-> Nat Nat Nat))
(define +
  (lambda (a b)
    (rec-Nat a
      b
      (lambda (pred ih) (add1 ih)))))

(claim double (-> Nat Nat))
(define double
  (lambda (n)
    (+ n n)))

;; Use Even with double
(claim double-even
  (Pi ((n Nat))
    (-> (Even () (n)) Nat)))
(define double-even
  (lambda (n ev)
    (double (coerce (Even () (n)) Nat
                    (even-subtype-nat n)
                    ev))))


(claim even-four (Even () ((add1 (add1 (add1 (add1 zero)))))))
(define even-four
  (add2-even (add1 (add1 zero))
    (add2-even zero
      (zero-even))))

(claim result2 Nat)
(define result2 (double-even (add1 (add1 (add1 (add1 zero)))) even-four))
        `
};

const defaultSource = examples['Hello World'];

const previewSummary = document.getElementById('preview-summary') as HTMLElement;
const previewOutput = document.getElementById('preview-output') as HTMLElement;

let diagnosticsWorker: Worker | null = null;
let lspClient: PieLanguageClient | null = null;
let monacoApi: typeof Monaco | null = null;
let proofTreeVisualizer: ProofTreeVisualizer | null = null;
let contextPanel: ContextPanel | null = null;
let goalPanel: GoalPanel | null = null;

function setSummary(message: string, tone: 'neutral' | 'success' | 'warning' | 'error' = 'neutral') {
  if (previewSummary) {
    previewSummary.textContent = message;
    previewSummary.dataset.tone = tone;
  }
}

function renderPreviewText(text: string | undefined, tone?: 'neutral' | 'success' | 'warning' | 'error') {
  if (tone) {
    previewOutput.dataset.tone = tone;
  } else {
    delete previewOutput.dataset.tone;
  }

  if (text === undefined) {
    previewOutput.textContent = 'Program is empty.';
  } else {
    previewOutput.textContent = text;
  }
}

function updateProofTree(proofTree: ProofTreeData | undefined) {
  const container = document.getElementById('proof-tree-container');
  if (!container) return;

  if (!proofTree) {
    // Hide the proof tree panel
    container.style.display = 'none';
    if (proofTreeVisualizer) {
      proofTreeVisualizer.clear();
    }
    if (contextPanel) {
      contextPanel.clear();
    }
    if (goalPanel) {
      goalPanel.clear();
    }
    return;
  }

  // Show the proof tree panel
  container.style.display = 'flex';

  // Render the tree
  if (proofTreeVisualizer) {
    proofTreeVisualizer.render(proofTree);
  }

  // Clear panels (user needs to click a goal)
  if (contextPanel) {
    contextPanel.clear();
  }
  if (goalPanel) {
    goalPanel.clear();
  }
}

function initializeProofTreeVisualizer() {
  const canvasContainer = document.getElementById('proof-tree-canvas');
  const contextContainer = document.getElementById('proof-context-panel');
  const goalContainer = document.getElementById('proof-goal-panel');
  const toggleBtn = document.getElementById('proof-tree-toggle');
  const container = document.getElementById('proof-tree-container');

  if (!canvasContainer || !contextContainer || !goalContainer) {
    console.warn('Proof tree containers not found');
    return;
  }

  proofTreeVisualizer = new ProofTreeVisualizer(canvasContainer);
  contextPanel = new ContextPanel(contextContainer);
  goalPanel = new GoalPanel(goalContainer);

  // Connect goal selection to both panels
  proofTreeVisualizer.setOnGoalSelect((goal) => {
    if (contextPanel) {
      contextPanel.display(goal);
    }
    if (goalPanel) {
      goalPanel.display(goal);
    }
    if (proofTreeVisualizer) {
      proofTreeVisualizer.highlightGoal(goal.id);
    }
  });

  // Toggle button functionality
  if (toggleBtn && container) {
    toggleBtn.addEventListener('click', () => {
      const content = container.querySelector('.proof-tree-content') as HTMLElement;
      if (content) {
        if (content.style.display === 'none') {
          content.style.display = 'flex';
          toggleBtn.textContent = 'Hide';
        } else {
          content.style.display = 'none';
          toggleBtn.textContent = 'Show';
        }
      }
    });
  }
}

function applyDiagnostics(monaco: typeof Monaco, editor: Monaco.editor.IStandaloneCodeEditor, payload: any) {
  const { diagnostics, pretty, proofTree } = payload;
  const model = editor.getModel();

  if (!model) return;

  const markers = diagnostics.map((d: any) => ({
    startLineNumber: d.startLineNumber,
    startColumn: d.startColumn,
    endLineNumber: d.endLineNumber,
    endColumn: d.endColumn,
    message: d.message,
    severity: d.severity === 'warning'
      ? monaco.MarkerSeverity.Warning
      : monaco.MarkerSeverity.Error
  }));

  monaco.editor.setModelMarkers(model, 'pie-playground', markers);

  // Update proof tree visualization
  updateProofTree(proofTree);

  if (diagnostics.length === 0) {
    setSummary('SUCCESS', 'success');
    renderPreviewText(pretty?.trim() ?? undefined, 'success');
    return;
  }

  const primary = diagnostics[0];
  const tone = primary.severity === 'warning' ? 'warning' : 'error';
  const label = tone === 'warning' ? 'WARNING' : 'ERROR';

  setSummary(label, tone);
  const location = `Line ${primary.startLineNumber}, Col ${primary.startColumn}`;
  renderPreviewText(`${location}\n${primary.message}`, tone);
}

function initializeDiagnostics(editor: Monaco.editor.IStandaloneCodeEditor) {
  if (!('Worker' in window)) {
    setSummary('Diagnostics unavailable in this browser.', 'warning');
    return null;
  }

  const worker = new Worker('diagnostics-worker.js', { type: 'module' });
  worker.onmessage = event => {
    const { type, payload } = event.data;
    if (type === 'diagnostics' && monacoApi) {
      applyDiagnostics(monacoApi, editor, payload);
    }
  };

  worker.onerror = (error) => {
    console.error('Worker error event:', error);
    console.error('Error details:', {
      message: error.message,
      filename: error.filename,
      lineno: error.lineno,
      colno: error.colno
    });
    setSummary('Diagnostics worker crashed.', 'error');
    renderPreviewText(
      `Worker failed to load. Check browser console for details.\nError: ${error.message || 'Unknown error'}`,
      'error'
    );
  };

  return worker;
}

async function initializeLSP(monacoLib: typeof Monaco, editor: Monaco.editor.IStandaloneCodeEditor) {
  try {
    if (lspClient && lspClient.isRunning()) {
      await lspClient.stop();
    }

    lspClient = new PieLanguageClient(monacoLib, editor);
    await lspClient.start();
    console.log('LSP client initialized successfully');
  } catch (error) {
    console.error('Failed to initialize LSP client:', error);
    setSummary('LSP features unavailable', 'warning');
  }
}

function initializeEditor(monaco: typeof Monaco) {
  // Register Pie language
  registerPieLanguage(monaco);

  const editor = monaco.editor.create(document.getElementById('editor')!, {
    value: defaultSource,
    language: 'pie',
    theme: 'vs-dark',
    automaticLayout: true,
    minimap: {
      enabled: false
    },
    scrollbar: {
      vertical: 'auto',
      horizontal: 'auto',
      useShadows: false,
      verticalScrollbarSize: 6,
      verticalSliderSize: 4
    },
    padding: { top: 16 },
    fontSize: 14,
    fontFamily: "Menlo, 'Fira Code', 'JetBrains Mono', monospace",
    smoothScrolling: true
  });

  renderPreviewText(defaultSource.trim());
  setSummary('Ready for analysis.', 'neutral');

  const debounced = debounce((text: string) => {
    if (text.trim().length === 0) {
      setSummary('Waiting for input…', 'neutral');
      renderPreviewText(undefined);
    } else {
      setSummary('Running checks…', 'warning');
      renderPreviewText('Analyzing…');
    }
  }, 120);

  const queueDiagnostics = debounce((text: string) => {
    setSummary('Running checks…', 'warning');
    if (diagnosticsWorker) {
      diagnosticsWorker.postMessage({
        type: 'analyze',
        payload: { source: text }
      });
    }
  }, 220);

  editor.onDidChangeModelContent(() => {
    const content = editor.getValue();
    debounced(content);
    queueDiagnostics(content);
  });

  return editor;
}

function initializeCopyButton(editor: Monaco.editor.IStandaloneCodeEditor) {
  const copyBtn = document.getElementById('copy-btn') as HTMLButtonElement;

  if (!copyBtn) return;

  copyBtn.addEventListener('click', async () => {
    const code = editor.getValue();
    try {
      await navigator.clipboard.writeText(code);
      copyBtn.textContent = 'Copied!';
      copyBtn.dataset.copied = 'true';
      setTimeout(() => {
        copyBtn.textContent = 'Copy';
        delete copyBtn.dataset.copied;
      }, 1500);
    } catch (err) {
      console.error('Failed to copy:', err);
      copyBtn.textContent = 'Failed';
      setTimeout(() => {
        copyBtn.textContent = 'Copy';
      }, 1500);
    }
  });
}

function initializeExamplePicker(editor: Monaco.editor.IStandaloneCodeEditor) {
  const picker = document.getElementById('example-picker') as HTMLSelectElement;

  if (!picker) return;

  // Populate the dropdown
  Object.keys(examples).forEach(name => {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    picker.appendChild(option);
  });

  // Set initial value
  picker.value = 'Hello World';

  // Handle selection
  picker.addEventListener('change', (e) => {
    const exampleName = (e.target as HTMLSelectElement).value;
    if (exampleName && examples[exampleName as keyof typeof examples]) {
      editor.setValue(examples[exampleName as keyof typeof examples]);
    }
  });
}

async function boot() {
  if (!window.require) {
    console.error('Monaco loader not available');
    return;
  }

  window.require.config({
    paths: {
      vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.0/min/vs'
    }
  });

  window.require(['vs/editor/editor.main'], async () => {
    monacoApi = window.monaco;
    const editor = initializeEditor(monacoApi);
    diagnosticsWorker = initializeDiagnostics(editor);
    initializeExamplePicker(editor);
    initializeCopyButton(editor);
    initializeProofTreeVisualizer();

    // Initialize LSP
    if (monacoApi) {
      await initializeLSP(monacoApi, editor);
    }

    if (diagnosticsWorker) {
      diagnosticsWorker.postMessage({
        type: 'analyze',
        payload: { source: editor.getValue() }
      });
    }

    (window as any).__pieEditor = editor;
  });
}

function debounce<T extends (...args: any[]) => any>(fn: T, delay: number) {
  let handle: number;
  return function debounced(this: any, ...args: Parameters<T>) {
    window.clearTimeout(handle);
    handle = window.setTimeout(() => fn.apply(this, args), delay);
  };
}

boot();
</file>

<file path="web/styles.css">
:root {
  --bg-editor: #1a2520;
  --bg-preview: #1f2d26;
  --bg-app: #0d1612;
  --bg-header: #0f1a14;
  --accent: #3d8b5f;
  --accent-soft: rgba(61, 139, 95, 0.2);
  --text-primary: #e8f4ed;
  --text-secondary: #8fb89d;
  --border: rgba(143, 184, 157, 0.16);
  --font-sans: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}

*,
*::before,
*::after {
  box-sizing: border-box;
}

html,
body {
  margin: 0;
  height: 100%;
  color: var(--text-primary);
  font-family: var(--font-sans);
}

body {
  display: flex;
  align-items: stretch;
  justify-content: center;
  background: radial-gradient(circle at top, rgba(61, 139, 95, 0.15), transparent 60%), var(--bg-app);
}

.app-shell {
  flex: 1;
  display: grid;
  grid-template-columns: minmax(0, 1.8fr) minmax(240px, 1fr);
  grid-template-rows: auto 1fr auto;
  max-width: 1280px;
  width: 100%;
  height: 100vh;
  padding: 24px;
  column-gap: 24px;
  row-gap: 12px;
  min-height: 0;
  align-items: start;
}

.panel-title {
  margin: 0;
  display: inline-flex;
  align-items: center;
  gap: 12px;
  font-size: 16px;
  font-weight: 600;
  color: var(--text-secondary);
  letter-spacing: 0.05em;
  text-transform: uppercase;
}

.panel-icon {
  width: 30px;
  height: 30px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 999px;
  background: rgba(61, 139, 95, 0.25);
  color: var(--accent);
  font-weight: 600;
  font-size: 16px;
}

.editor-header {
  grid-column: 1;
  grid-row: 1;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
}

.editor-title {
  margin: 0;
}

#editor {
  grid-column: 1;
  grid-row: 2;
  min-height: 0;
  height: 100%;
  border-radius: 20px;
  background: var(--bg-editor);
  border: 1px solid var(--border);
  box-shadow: 0 20px 46px rgba(15, 23, 42, 0.45);
  overflow: hidden;
}

.preview-summary {
  grid-column: 2;
  grid-row: 1;
  justify-self: center;
  align-self: end;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  transition: color 0.2s ease;
  text-align: center;
  color: var(--text-secondary);
}

.preview-summary[tone="success"] {
  color: #34d399;
}

.preview-summary[tone="error"] {
  color: #f87171;
}

.preview-summary[tone="warning"] {
  color: #facc15;
}

.preview-code {
  grid-column: 2;
  grid-row: 2;
  min-height: 0;
  height: 100%;
  margin: 0;
  border-radius: 20px;
  background: rgba(15, 23, 42, 0.55);
  border: 1px solid var(--border);
  box-shadow: 0 20px 46px rgba(15, 23, 42, 0.45);
  padding: 20px;
  color: var(--text-primary);
  white-space: pre-wrap;
  word-break: break-word;
  font-family: Menlo, 'Fira Code', 'JetBrains Mono', monospace;
  font-size: 14px;
  line-height: 1.5;
  overflow: auto;
}

.preview-code[tone="error"] {
  color: #fca5a5;
}

.preview-code[tone="success"] {
  color: #bbf7d0;
}

.preview-code[tone="warning"] {
  color: #fde68a;
}

.example-picker {
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid var(--border);
  border-radius: 10px;
  color: var(--text-primary);
  padding: 8px 32px 8px 14px;
  font-family: var(--font-sans);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
  outline: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%2394a3b8' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 12px center;
}

.example-picker:hover {
  background: rgba(15, 23, 42, 0.8);
  border-color: var(--accent);
}

.example-picker:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-soft);
}

.example-picker option {
  background: var(--bg-editor);
  color: var(--text-primary);
  padding: 8px;
}

.copy-btn {
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid var(--border);
  border-radius: 10px;
  color: var(--text-primary);
  padding: 8px 16px;
  font-family: var(--font-sans);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
  outline: none;
}

.copy-btn:hover {
  background: rgba(15, 23, 42, 0.8);
  border-color: var(--accent);
}

.copy-btn:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-soft);
}

.copy-btn[data-copied="true"] {
  background: rgba(52, 211, 153, 0.2);
  border-color: #34d399;
  color: #34d399;
}


@media (max-width: 1024px) {
  .app-shell {
    grid-template-columns: 1fr;
    grid-template-rows: auto minmax(0, 1fr) auto minmax(0, 1fr);
  }

  .editor-header,
  #editor,
  .preview-summary,
  .preview-code {
    grid-column: 1;
  }

  .editor-header {
    grid-row: 1;
  }

  #editor {
    grid-row: 2;
  }

  .preview-summary {
    justify-self: flex-start;
    grid-row: 3;
  }

  .preview-code {
    grid-row: 4;
  }
}

@media (max-width: 720px) {
  .app-shell {
    padding: 16px;
    row-gap: 18px;
  }
}

/* ==================== Proof Tree Visualizer ==================== */

.proof-tree-container {
  grid-column: 1 / -1;
  grid-row: 3;
  min-height: 200px;
  max-height: 400px;
  border-radius: 20px;
  background: rgba(15, 23, 42, 0.55);
  border: 1px solid var(--border);
  box-shadow: 0 20px 46px rgba(15, 23, 42, 0.45);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.proof-tree-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 20px;
  background: rgba(15, 23, 42, 0.3);
  border-bottom: 1px solid var(--border);
}

.proof-tree-title {
  font-size: 14px;
}

.proof-tree-toggle {
  background: rgba(15, 23, 42, 0.6);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text-secondary);
  padding: 4px 12px;
  font-family: var(--font-sans);
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease, border-color 0.2s ease;
}

.proof-tree-toggle:hover {
  background: rgba(15, 23, 42, 0.8);
  border-color: var(--accent);
  color: var(--text-primary);
}

.proof-tree-content {
  flex: 1;
  display: flex;
  min-height: 0;
  overflow: hidden;
}

.proof-context-panel {
  width: 220px;
  border-right: 1px solid var(--border);
  padding: 16px;
  overflow-y: auto;
  background: rgba(15, 23, 42, 0.3);
  font-family: Menlo, 'Fira Code', 'JetBrains Mono', monospace;
  font-size: 12px;
}

.proof-tree-canvas {
  flex: 1;
  overflow: auto;
  padding: 16px;
  display: flex;
  justify-content: center;
}

.proof-goal-panel {
  width: 280px;
  border-left: 1px solid var(--border);
  padding: 16px;
  overflow-y: auto;
  background: rgba(15, 23, 42, 0.3);
  font-family: Menlo, 'Fira Code', 'JetBrains Mono', monospace;
  font-size: 12px;
}

/* Shared Panel Styles */
.panel-placeholder {
  color: var(--text-secondary);
  font-style: italic;
  text-align: center;
  padding: 20px;
}

.panel-header {
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}

.panel-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--text-secondary);
  font-weight: 600;
}

.panel-title-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 6px;
}

.panel-goal-id {
  font-size: 12px;
  color: var(--text-primary);
  font-weight: 600;
}

.panel-status {
  display: inline-block;
  font-size: 10px;
  padding: 2px 8px;
  border-radius: 4px;
  font-weight: 500;
}

.panel-status.status-ongoing {
  background: rgba(245, 158, 11, 0.2);
  color: #f59e0b;
}

.panel-status.status-completed {
  background: rgba(52, 211, 153, 0.2);
  color: #34d399;
}

.panel-status.status-pending {
  background: rgba(100, 116, 139, 0.2);
  color: #94a3b8;
}

.panel-content {
  overflow-y: auto;
}

.panel-empty {
  color: var(--text-secondary);
  font-style: italic;
  opacity: 0.6;
}

/* Context List Styles */
.context-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.context-entry {
  line-height: 1.4;
  word-break: break-word;
}

.context-entry-name {
  color: #93c5fd;
}

.context-entry-colon {
  color: var(--text-secondary);
}

.context-entry-type {
  color: #fde68a;
}

/* Goal Type Tree Styles */
.goal-type-tree {
  padding: 10px;
  background: rgba(15, 23, 42, 0.5);
  border-radius: 6px;
}

/* SVG Goal Node Styles */
.goal-node.highlighted rect {
  filter: drop-shadow(0 0 8px var(--accent));
}

/* Responsive adjustments */
@media (max-width: 1024px) {
  .proof-tree-container {
    grid-column: 1;
    grid-row: 5;
  }

  .proof-tree-content {
    flex-direction: column;
  }

  .proof-context-panel {
    width: 100%;
    border-right: none;
    border-bottom: 1px solid var(--border);
    max-height: 120px;
  }

  .proof-goal-panel {
    width: 100%;
    border-left: none;
    border-top: 1px solid var(--border);
    max-height: 150px;
  }
}

/* ==================== Collapsible Type Tree ==================== */

/* Type color variables */
:root {
  --type-pi: #4ade80;       /* green */
  --type-sigma: #60a5fa;    /* blue */
  --type-either: #fb923c;   /* orange */
  --type-equality: #22d3ee; /* cyan */
  --type-list: #c084fc;     /* purple */
  --type-vec: #f472b6;      /* pink */
  --type-nat: #facc15;      /* yellow */
  --type-universe: #94a3b8; /* gray */
  --type-lambda: #a3e635;   /* lime */
  --type-variable: #93c5fd; /* light blue */
  --type-default: #e2e8f0;  /* slate */
}

/* Main tree container */
.type-tree {
  font-family: Menlo, 'Fira Code', 'JetBrains Mono', monospace;
  font-size: 12px;
  line-height: 1.5;
}

.type-tree__placeholder {
  color: var(--text-secondary);
  font-style: italic;
}

.type-tree__fallback {
  margin: 0;
  padding: 10px;
  background: rgba(15, 23, 42, 0.5);
  border-radius: 6px;
  color: #a5f3fc;
  white-space: pre-wrap;
  word-break: break-word;
  line-height: 1.5;
}

/* Node structure */
.type-node {
  position: relative;
}

.type-node--list {
  margin: 2px 0;
}

.type-node--atom {
  display: inline;
}

.type-node__header {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 2px 0;
  cursor: default;
}

.type-node__toggle {
  width: 14px;
  height: 14px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  cursor: pointer;
  color: var(--text-secondary);
  flex-shrink: 0;
  transition: color 0.15s ease;
  user-select: none;
}

.type-node__toggle:hover {
  color: var(--text-primary);
}

.type-node__toggle-spacer {
  width: 14px;
  flex-shrink: 0;
}

.type-node__kind {
  font-weight: 600;
}

.type-node__binding {
  color: var(--text-secondary);
}

.type-node__abbrev {
  color: var(--text-secondary);
  opacity: 0.7;
  font-style: italic;
}

.type-node__children {
  margin-left: 8px;
  padding-left: 10px;
  border-left: 1px solid var(--border);
}

/* Type kind color classes */
.type-kind--pi {
  color: var(--type-pi);
}

.type-kind--sigma {
  color: var(--type-sigma);
}

.type-kind--either {
  color: var(--type-either);
}

.type-kind--equality {
  color: var(--type-equality);
}

.type-kind--list {
  color: var(--type-list);
}

.type-kind--vec {
  color: var(--type-vec);
}

.type-kind--nat {
  color: var(--type-nat);
}

.type-kind--universe {
  color: var(--type-universe);
}

.type-kind--lambda {
  color: var(--type-lambda);
}

.type-kind--variable {
  color: var(--type-variable);
}

.type-kind--default {
  color: var(--type-default);
}
</file>

<file path=".github/workflows/deploy-github-pages.yml">
name: Deploy to GitHub Pages

on:
  workflow_dispatch:  # Allows manual trigger from GitHub Actions tab
  push:
    branches:
      - new_examples  # Optional: also trigger on push to main branch

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to push to gh-pages branch
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
      
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '22'
      
      - name: Install dependencies with yarn
        run: yarn install
      
      - name: Install dependencies with npm
        run: npm install
      
      - name: Build project
        run: yarn build
      
      - name: Verify dist/index.js exists
        run: |
          if [ ! -f "dist/index.js" ]; then
            echo "Error: dist/index.js was not created by the build"
            exit 1
          fi
          echo "dist/index.js found successfully"
          ls -lh dist/

      - name: Prepare deployment directory
        run: |
          mkdir -p deploy
          cp -r dist deploy/dist
          cp -r web deploy/pie-playground
          cp github-pages-index.html deploy/index.html
          echo "Deployment directory structure:"
          ls -lR deploy/

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./deploy
          publish_branch: gh-pages
          commit_message: 'Deploy dist and Pie Playground to GitHub Pages'
</file>

<file path="src/pie_interpreter/__tests__/test_main.ts">
import 'jest';

import { evaluatePie } from '../main'

describe("demo", () => {
  it("Pie demo", () => {
    const src =
      `
      (claim one Nat)
(define one ((the (-> Nat Nat) (lambda (x) (add1 x))) zero))`
    const result = evaluatePie(src)
  })})
</file>

<file path="src/pie_interpreter/evaluator/utils.ts">
import * as V from "../types/value";
import * as C from '../types/core';
import * as N from '../types/neutral';
import { fresh, extractVarNamesFromValue } from '../types/utils';
import { bindFree, Context, ConstructorTypeBinder, valInContext, contextToEnvironment } from '../utils/context';
import { extendEnvironment } from '../utils/environment';
import { doApp, doCar, doCdr } from "./evaluator";

/**
 *   ## Call-by-need evaluation ##

  Pie is a total language, which means that every program will
  eventually terminate. Because the steps taken during evaluation are
  completely deterministic, and because Pie is total, it is
  acceptable to choose any order of evaluation.

  On the other hand, many useful Pie programs will take many more
  evaluation steps to complete when using strict evaluation. For
  instance, consider zerop from chapter 3 of The Little Typer. zerop
  returns 'nil when its argument's value has V_Add1 at the top, or 't
  if it is zero. If (zerop (double 10000)) is evaluated strictly, the
  evaluator will first need to find out that (double 10000) is 20000,
  requiring 10000 steps.  On the other hand, if it is evaluated
  lazily, then it will need only one step to discover that the value
  has V_Add1 at the top.

  Pie uses call-by-need evaluation. This means that if two different
  expressions make use of some expression, such as a definition, then
  evaluation steps will be shared between them and will not need to
  be repeated.

  Call-by-need evaluation is achieved by introducing a new value that
  represents evaluation that has not yet been performed, but should
  instead be performed on demand. That value, which doesn't represent
  any value in the Pie sense of the word, is called DELAY and is
  defined in basics.rkt. When DELAY represents work that has not yet
  been done, it is filled with a special kind of closure called
  DELAY-CLOS that pairs an expression with its environment.

  Not every DELAY represents evaluation that has not yet been
  performed. Some represent evaluation that was already demanded by
  some other operator. The work is shared by updating the contents of
  DELAY with an actual value.

  later is used to delay evaluation by constructing a DELAY value
  that contains a DELAY-CLOS closure.
*/

// undelay is used to find the value that is contained in a
// DELAY-CLOS closure by invoking the evaluator.
/* export function undelay(c: V.DelayClosure): V.Value {
  return now(c.expr.valOf(c.env));
} */

/*
  now demands the _actual_ value represented by a DELAY. If the value
  is a DELAY-CLOS, then it is computed using undelay. If it is
  anything else, then it has already been computed, so it is
  returned.
  
  now should be used any time that a value is inspected to see what
  form it has, because those situations require that the delayed
  evaluation steps be carried out.
*/
/* export function now(todo: V.Value): V.Value {
  if (todo instanceof V.Delay) { //todo.val is nessarily a Box
    const box = todo.val;
    const content = box.get();
    if (content instanceof V.DelayClosure) {
      let theValue = undelay(content);
      box.set(theValue);
      return theValue;
    } else { // content is a Value (content instanceof Value).
      return box.get() as V.Value;
    }
  }
  return todo;
} */

export function natEqual(nat1: V.Value, nat2: V.Value): boolean {
  const nat1Now = nat1.now();
  const nat2Now = nat2.now();
  if (nat1Now instanceof V.Zero && nat2Now instanceof V.Zero) {
    return true;
  } else if (nat1Now instanceof V.Add1 && nat2Now instanceof V.Add1) {
    return natEqual(nat1Now.smaller, nat2Now.smaller);
  } else {
    return false;
  }
}

export function readBack(context: Context, type: V.Value, value: V.Value): C.Core {
  const typeNow = type.now();
  const valueNow = value.now();

  if (typeNow instanceof V.Universe) {
    return value.readBackType(context);
  } else if (typeNow instanceof V.Nat
    && valueNow instanceof V.Zero) {
    return new C.Zero();
  } else if (typeNow instanceof V.Nat
    && valueNow instanceof V.Add1) {
    return new C.Add1(
      readBack(context, new V.Nat(), valueNow.smaller)
    );
  } else if (typeNow instanceof V.Pi) {
    const y = valueNow instanceof V.Lambda ?
      valueNow.argName : typeNow.argName;
    const freshx = fresh(context, y);
    return new C.Lambda(freshx, readBack(
      bindFree(context, freshx, typeNow.argType),
      typeNow.resultType.valOfClosure(
        new V.Neutral(typeNow.argType, new N.Variable(freshx))
      ),
      doApp(
        valueNow,
        new V.Neutral(typeNow.argType, new N.Variable(freshx))
      )
    ));
  } else if (typeNow instanceof V.Sigma) {
    const car = doCar(value);
    const cdr = doCdr(value);
    return new C.Cons(
      readBack(context, typeNow.carType, car),
      readBack(
        context,
        typeNow.cdrType.valOfClosure(car),
        cdr
      )
    );
  } else if (typeNow instanceof V.Atom
    && valueNow instanceof V.Quote) {
    return new C.Quote(valueNow.name);
  } else if (typeNow instanceof V.Trivial) {
    return new C.Sole();
  } else if (typeNow instanceof V.List
    && valueNow instanceof V.Nil) {
    return new C.Nil();
  } else if (typeNow instanceof V.List
    && valueNow instanceof V.ListCons) {
    return new C.Cons(
      readBack(context, typeNow.entryType, valueNow.head),
      readBack(context, new V.List(typeNow.entryType), valueNow.tail));
  } else if (typeNow instanceof V.Absurd
    && valueNow instanceof V.Neutral) {
    return new C.The(
      new C.Absurd(),
      valueNow.neutral.readBackNeutral(context)
    );
  } else if (typeNow instanceof V.Equal
    && valueNow instanceof V.Same) {
    return new C.Same(
      readBack(context, typeNow.type, valueNow.value));
  } else if (typeNow instanceof V.Vec
    && typeNow.length.now() instanceof V.Zero
    && valueNow instanceof V.VecNil) {
    return new C.VecNil();
  } else if (typeNow instanceof V.Vec
    && typeNow.length.now() instanceof V.Add1
    && valueNow instanceof V.VecCons) {
    const lenNow = typeNow.length.now() as V.Add1;
    return new C.VecCons(
      readBack(context, typeNow.entryType, valueNow.head),
      readBack(
        context,
        new V.Vec(typeNow.entryType, (typeNow.length.now() as V.Add1).smaller),
        valueNow.tail
      )
    );
  } else if (typeNow instanceof V.Either
    && valueNow instanceof V.Left) {
    return new C.Left(
      readBack(context, typeNow.leftType, valueNow.value)
    );
  } else if (typeNow instanceof V.Either
    && valueNow instanceof V.Right) {
    return new C.Right(
      readBack(context, typeNow.rightType, valueNow.value)!
    );
  } else if (typeNow instanceof V.InductiveTypeConstructor
    && valueNow instanceof V.Constructor) {
    // Read back constructor applications
    // Need to substitute concrete parameters from expected type into constructor arg types
    let ctorBinder: ConstructorTypeBinder | undefined;
    for (const [name, binder] of context) {
      if (name === valueNow.name && binder instanceof ConstructorTypeBinder) {
        ctorBinder = binder;
        break;
      }
    }

    if (!ctorBinder) {
      throw new Error(`Constructor ${valueNow.name} not found in context`);
    }

    // Get constructor type (Core) - contains abstract parameters like VarName("E")
    const ctorTypeCore = ctorBinder.constructorType;
    const resultTypeCore = ctorTypeCore.resultType as C.InductiveTypeConstructor;

    // Build substitution environment: parameter names -> concrete values
    // Same pattern as ConstructorApplication.checkOut
    let substEnv = contextToEnvironment(context);

    // Extract parameter names from constructor's return type and map to concrete values
    for (let i = 0; i < resultTypeCore.parameters.length; i++) {
      const paramCore = resultTypeCore.parameters[i];
      if (paramCore instanceof C.VarName) {
        const paramName = paramCore.name;
        const concreteValue = typeNow.parameters[i].now();
        // Override abstract binding (E -> Neutral) with concrete (E -> Nat)
        substEnv = extendEnvironment(substEnv, paramName, concreteValue);
      }
    }

    // Similarly for indices
    for (let i = 0; i < resultTypeCore.indices.length; i++) {
      const indexCore = resultTypeCore.indices[i];
      if (indexCore instanceof C.VarName) {
        const indexName = indexCore.name;
        const concreteValue = typeNow.indices[i].now();
        substEnv = extendEnvironment(substEnv, indexName, concreteValue);
      }
    }

    // Extract constructor argument names from the return type Value (indices only!)
    // We only need to track INDEX arguments for incremental substitution, not parameters
    const returnTypeValue = ctorBinder.type; // V.InductiveTypeConstructor
    const indexArgNames: string[] = [];
    returnTypeValue.indices.forEach(i => {
      indexArgNames.push(...extractVarNamesFromValue(i));
    });

    // Read back arguments with incremental substitution
    const readBackArgs: C.Core[] = [];
    for (let i = 0; i < valueNow.args.length; i++) {
      const argTypeCore = ctorTypeCore.argTypes[i];
      const argTypeValue = argTypeCore.valOf(substEnv);
      const readBackArg = readBack(context, argTypeValue.now(), valueNow.args[i]);
      readBackArgs.push(readBackArg);

      // Extend substEnv with this argument's value for subsequent arguments
      if (i < indexArgNames.length) {
        const argName = indexArgNames[i];
        const argValue = valueNow.args[i].now();
        substEnv = extendEnvironment(substEnv, argName, argValue);
      }
    }

    // Read back recursive arguments with incremental substitution
    const readBackRecArgs: C.Core[] = [];
    const recArgStartIdx = valueNow.args.length;
    for (let i = 0; i < valueNow.recursive_args.length; i++) {
      const recArgTypeCore = ctorTypeCore.rec_argTypes[i];
      const recArgTypeValue = recArgTypeCore.valOf(substEnv);
      const readBackRecArg = readBack(context, recArgTypeValue.now(), valueNow.recursive_args[i]);
      readBackRecArgs.push(readBackRecArg);

      // Extend substEnv with this recursive argument's value
      const argNameIdx = recArgStartIdx + i;
      if (argNameIdx < indexArgNames.length) {
        const argName = indexArgNames[argNameIdx];
        const recArgValue = valueNow.recursive_args[i].now();
        substEnv = extendEnvironment(substEnv, argName, recArgValue);
      }
    }

    return new C.Constructor(
      valueNow.name,
      valueNow.index,
      valueNow.type,
      readBackArgs,
      readBackRecArgs
    );
  } else if (valueNow instanceof V.Neutral) {
    return valueNow.neutral.readBackNeutral(context);
  }

  throw new Error(`Cannot read back ${valueNow.prettyPrint()} : ${typeNow.prettyPrint()}`);
}
</file>

<file path="src/pie_interpreter/tactics/proofmanager.ts">
import { ProofState, Goal, ProofTreeData } from './proofstate';
import { Tactic } from './tactics';
import { Context, Claim} from '../utils/context';

import { Location } from '../utils/locations';
import { Perhaps, go, stop, Message } from '../types/utils';

export class ProofManager {
  public currentState: ProofState | null = null;

  public startProof(name: string, context: Context, location: Location): Perhaps<string> {

    const claim = context.get(name);
    if (! (claim instanceof Claim)) {
      return new stop(location, new Message([`${name} is not a valid type or has already been proved`]));
    }

    this.currentState = ProofState.initialize(context, claim.type, location);

    return new go(`Started proof of ${name}` + `\nCurrent goal: \n${claim.type.readBackType(context).prettyPrint()}`);
  }


  public applyTactic(tactic: Tactic): Perhaps<string> {

    if (!this.currentState) {
      return new stop(tactic.location, new Message([`No proof has been initialized`]));
    }

    // Store the current goal node before applying tactic
    const previousGoalNode = this.currentState.currentGoal;

    const newStateResult = tactic.apply(this.currentState);
    if (newStateResult instanceof stop) {
      return newStateResult;
    }

    this.currentState = (newStateResult as go<ProofState>).result;

    // Record which tactic was applied to create children
    if (previousGoalNode.children.length > 0) {
      previousGoalNode.appliedTactic = tactic.toString();
    }

    let response = `\nApplied tactic: ${tactic}`;

    const currentGoal = this.currentState.getCurrentGoal();
     if (this.currentState.isComplete()) {
      response += "\nAll goals have been solved!";
    } else {
      const curGoal = (currentGoal as go<Goal>).result
      response += `\nCurrent goal: \n` + curGoal.type.readBackType(curGoal.context).prettyPrint();
    }

    return new go(response);
  }

  public getProofTreeData(): ProofTreeData | null {
    if (!this.currentState) {
      return null;
    }
    return this.currentState.getProofTreeData();
  }
}
</file>

<file path="README.md">
# pie-slang
Implementation of Pie, following [The Little Typer](https://mitpress.mit.edu/9780262536431/the-little-typer/)

## Our Online Playground

We have a [online playground](https://source-academy.github.io/pie-slang/) for you to play with Pie.
It is still under construction, especially for the language server part, so it might be buggy.

yarn build python -m http.server 8000
# Then open http://localhost:8000/web/index.html

## Our Language Server

We have published the Pie language server as a VSCode extension, named [pie-lsp](https://marketplace.visualstudio.com/items?itemName=DaoxinLi.pie-lsp&ssr=false#review-details)
## Getting Started

To get started with the Pie interpreter:

1. Clone the repository:
   ```bash
   git clone https://github.com/source-academy/pie-slang.git
   cd pie-slang
   ```

2. Install dependencies:
   ```bash
   yarn install
   ```

3. Build the project:
   ```bash
   yarn build
   ```

4. Use conductor: find dist files in ```./dist``` folder.

5. Try a simple Pie program on Source Academy, or the local web interface:
   ```scheme
   (claim identity (-> Nat Nat))
   (define identity (λ (n) n))
   ```
For more information about the project, please visit our wiki pages.  
To learn more about the language, you may read the book The Little Typer. Our wiki also contains a brief overview of the language.
</file>

<file path=".github/workflows/publish.yml">
name: Publish to NPM

on:
  # use release trigger
  release:
    types: [published]
  workflow_dispatch:

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      
      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '22'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Install dependencies with yarn
        run: yarn install
      
      - name: Install dependencies with npm
        run: npm install
      
      - name: Build
        run: yarn build
      
      - name: Publish to NPM
        run: npm publish --access public
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
</file>

<file path="src/pie_interpreter/__tests__/test_doEliminator_core.ts">
import 'jest';
import * as C from '../types/core';
import * as V from '../types/value';
import * as Evaluator from '../evaluator/evaluator';
import { Environment } from '../utils/environment';
import { readBack } from '../evaluator/utils';
import { Context } from '../utils/context';

// Test examples for doEliminator function using Core data structures

// Example 1: List elimination test
export function createListExample(): {
  listType: C.InductiveTypeConstructor,
  sampleList: C.Core,
  eliminator: C.Eliminator
} {

  const listType = new C.InductiveTypeConstructor(
    "List",
    [new C.Nat()], // parameters
    [],                   // no indices
  );

  // Create List constructors
  const nilConstructor = new C.Constructor(
    "nil",   // name
    0,       // constructor index
    "List",  // type: List A
    [],      // no arguments
    []       // no recursive arguments
  );

  // Create a sample list: cons 1 (cons 2 (cons 3 nil))
  // Create cons 3 nil
  const cons3Nil = new C.Constructor(
    "cons",  // name
    1,       // constructor index
    "List",  // type
    [
      new C.Add1(new C.Add1(new C.Add1(new C.Zero())))
    ],       // arguments (just head, not tail)
    [nilConstructor]  // recursive arguments (tail)
  );

  // Create cons 2 (cons 3 nil)
  const cons2 = new C.Constructor(
    "cons",  // name
    1,       // constructor index
    "List",  // type
    [new C.Add1(new C.Add1(new C.Zero()))], // just head
    [cons3Nil]  // recursive arguments (tail)
  );


  // Create eliminator for summing the list with proper lambda expressions
  const sumEliminator = new C.Eliminator(
    "List",
    cons2,
    new C.Lambda("xs", new C.Nat()), // motive: List A -> Nat
    [
      new C.Zero(), // base case: nil -> 0
      new C.Lambda("head",
        new C.Lambda("tail",
          new C.Lambda(
            'n',
            new C.Add1(new C.VarName('n'))
          )
        )
      ) // step case: head -> tail -> sum_tail -> add1 sum_tail
    ]
  );

  return {
    listType,
    sampleList: cons2,
    eliminator: sumEliminator
  };
}

// // Example 2: Binary Tree elimination test  
// export function createBinaryTreeExample(): {
//   treeType: C.InductiveType,
//   sampleTree: C.Core,
//   eliminator: C.Eliminator
// } {

//   // Create Tree constructors
//   const leafConstructor = new C.Constructor(
//     "leaf",
//     new C.VarName("Tree"), // type: Tree A
//     [],  // no arguments
//     0,   // constructor index
//     false // not recursive
//   );

//   const nodeConstructor = new C.Constructor(
//     "node",
//     new C.Pi("value", new C.VarName("A"),
//       new C.Pi("left", new C.VarName("Tree"),
//         new C.Pi("right", new C.VarName("Tree"), 
//           new C.VarName("Tree")))), // type: A -> Tree A -> Tree A -> Tree A
//     [], // no arguments for constructor schema
//     1,   // constructor index
//     true // recursive (contains Tree A)
//   );

//   // Create the Tree inductive type
//   const treeType = new C.InductiveType(
//     "Tree", 
//     [new C.VarName("A")], // parameters
//     [],                   // no indices
//     [leafConstructor, nodeConstructor],
//     new C.Eliminator("Tree",
//       new C.VarName("tree"), // target
//       new C.VarName("P"),    // motive
//       [
//         new C.VarName("base_leaf"),     // method for leaf
//         new C.VarName("step_node")     // method for node
//       ]
//     )
//   );

//   // Create a sample tree: node 5 (node 3 leaf (node 4 leaf leaf)) (node 7 leaf leaf)

//   // Create leaf instances
//   const leaf1 = new C.Constructor("leaf", new C.VarName("Tree"), [], 0, false);
//   const leaf2 = new C.Constructor("leaf", new C.VarName("Tree"), [], 0, false);
//   const leaf3 = new C.Constructor("leaf", new C.VarName("Tree"), [], 0, false);
//   const leaf4 = new C.Constructor("leaf", new C.VarName("Tree"), [], 0, false);

//   // Create node 4 leaf leaf
//   const node4 = new C.Constructor(
//     "node",
//     new C.VarName("Tree"),
//     [
//       new C.Add1(new C.Add1(new C.Add1(new C.Add1(new C.Zero())))), // 4
//       leaf1,
//       leaf2
//     ],
//     1,
//     true
//   );

//   // Create node 3 leaf (node 4 leaf leaf)
//   const node3 = new C.Constructor(
//     "node", 
//     new C.VarName("Tree"),
//     [
//       new C.Add1(new C.Add1(new C.Add1(new C.Zero()))), // 3
//       leaf3,
//       node4
//     ],
//     1,
//     true
//   );

//   // Create node 7 leaf leaf
//   const node7 = new C.Constructor(
//     "node",
//     new C.VarName("Tree"),
//     [
//       new C.Add1(new C.Add1(new C.Add1(new C.Add1(new C.Add1(new C.Add1(new C.Add1(new C.Zero()))))))), // 7
//       leaf4,
//       new C.Constructor("leaf", new C.VarName("Tree"), [], 0, false)
//     ],
//     1,
//     true
//   );

//   // Create root node 5 (node 3 ...) (node 7 ...)
//   const sampleTree = new C.Constructor(
//     "node",
//     new C.VarName("Tree"),
//     [
//       new C.Add1(new C.Add1(new C.Add1(new C.Add1(new C.Add1(new C.Zero()))))), // 5
//       node3,
//       node7
//     ],
//     1,
//     true
//   );

//   // Create eliminator for summing tree values
//   const sumEliminator = new C.Eliminator(
//     "Tree",
//     sampleTree,
//     new C.Lambda("tree", new C.Nat()), // motive: always Nat
//     [
//       new C.Zero(), // base case: leaf -> 0
//       new C.Lambda("value",
//         new C.Lambda("left",
//           new C.Lambda("right", 
//             new C.Lambda("left_sum",
//               new C.Lambda("right_sum",
//                 new C.Application( // value + (left_sum + right_sum)
//                   new C.Application(
//                     new C.VarName("+"),
//                     new C.VarName("value")
//                   ),
//                   new C.Application(
//                     new C.Application(
//                       new C.VarName("+"),
//                       new C.VarName("left_sum")
//                     ),
//                     new C.VarName("right_sum")
//                   )
//                 )
//               )
//             )
//           )
//         )
//       ) // step case: value -> left -> right -> left_sum -> right_sum -> value + left_sum + right_sum
//     ]
//   );

//   return {
//     treeType,
//     sampleTree,
//     eliminator: sumEliminator
//   };
// }

// Jest test cases
describe("doEliminator tests", () => {

  it("should handle list elimination", () => {
    const env: Environment = new Map();
    const listExample = createListExample();

    expect(() => {
      const listResult = Evaluator.doEliminator(
        "List",
        listExample.sampleList.toLazy(env),
        listExample.eliminator.motive.toLazy(env),
        listExample.eliminator.methods.map(m => m.toLazy(env))
      );
      const context: Context = new Map();
      const normalizedResult = readBack(context, new V.Nat(), listResult);
    }).not.toThrow();
  });

  // it("should handle binary tree elimination", () => {
  
  //   const env: Environment = new Map();
  //   const treeExample = createBinaryTreeExample();

  //   expect(() => {
  //     const treeResult = Evaluator.doEliminator(
  //       "Tree", 
  //       treeExample.sampleTree.toLazy(env),
  //       treeExample.eliminator.motive.toLazy(env),
  //       treeExample.eliminator.methods.map(m => m.toLazy(env))
  //     );
  //     console.log("Tree elimination result:", treeResult);
  //   }).not.toThrow();
  // });

  it("should test list elimination with specific values", () => {
    const env: Environment = new Map();
    const listExample = createListExample();

    const listResult = Evaluator.doEliminator(
      "List",
      listExample.sampleList.toLazy(env),
      listExample.eliminator.motive.toLazy(env),
      listExample.eliminator.methods.map(m => m.toLazy(env))
    );

    // Add specific assertions based on expected behavior
    expect(listResult).toBeDefined();
  });

  // it("should test tree elimination with specific values", () => {
  //   const env: Environment = new Map();
  //   const treeExample = createBinaryTreeExample();

  //   const treeResult = Evaluator.doEliminator(
  //     "Tree",
  //     treeExample.sampleTree.toLazy(env),
  //     treeExample.eliminator.motive.toLazy(env),
  //     treeExample.eliminator.methods.map(m => m.toLazy(env))
  //   );

  //   // Add specific assertions based on expected behavior
  //   expect(treeResult).toBeDefined();
  //   });
});
</file>

<file path="src/pie_interpreter/__tests__/test_tactics_example.ts">
import 'jest'
import { evaluatePie } from '../main';

describe("examples", () => {
    it("even and odd", () => {
        const str =
        `
(claim +
  (→ Nat Nat
    Nat))

(claim step-plus
  (→ Nat
    Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1 ) ))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus )))

(claim double
  (→ Nat
    Nat))

(define double
  (λ (n)
    (iter-Nat n
      0
      (+ 2))))


(claim Even
(→ Nat
U ))
(define Even
(λ (n)
(Σ ((half Nat))
(= Nat n (double half )))))

(claim Odd
(→ Nat
U ))
(define Odd
(λ (n)
(Σ ((haf Nat))
(= Nat n (add1 (double haf )))))) 

(claim zero-is-even
(Even 0))
(define zero-is-even
(cons 0
(same 0)))

(claim add1-even->odd
(Π ((n Nat))
(→ (Even n)
(Odd (add1 n)))))

(define add1-even->odd
(λ (n en)
(cons (car en)
(cong (cdr en) (+ 1)))))

(claim add1-odd->even
(Π ((n Nat))
(→ (Odd n)
(Even (add1 n)))))

(define add1-odd->even
(λ (n on)
(cons (add1 (car on))
(cong (cdr on) (+ 1)))))

(claim even-or-odd
(Π ((n Nat))
(Either (Even n) (Odd n))))

(claim mot-even-or-odd
(→ Nat
U )) 

(define mot-even-or-odd
(λ (k)
(Either (Even k) (Odd k))))

(claim step-even-or-odd
(Π ((n-1 Nat))
(→ (mot-even-or-odd n-1)
(mot-even-or-odd (add1 n-1)))))

(define step-even-or-odd
(λ (n-1)
(λ (e-or-on-1)
(ind-Either e-or-on-1
(λ (e-or-on-1)
(mot-even-or-odd
(add1 n-1)))
(λ (en-1)
(right
(add1-even->odd
n-1 en-1)))
(λ (on-1)
(left
(add1-odd->even
n-1 on-1)))))))

(define even-or-odd
(λ (n)
(ind-Nat n
mot-even-or-odd
(left zero-is-even)
step-even-or-odd)))


        `
        console.log(evaluatePie(str))
    })

    it("even and odd tactics", () => {
        const str =
        `
(claim +
  (→ Nat Nat
    Nat))

(claim step-plus
  (→ Nat
    Nat))

(define step-plus
  (λ (n-1)
    (add1 n-1 ) ))

(define +
  (λ (n j)
    (iter-Nat n
      j
      step-plus )))

(claim double
  (→ Nat
    Nat))

(define double
  (λ (n)
    (iter-Nat n
      0
      (+ 2))))

(claim Even
  (→ Nat
    U ))

(define Even
  (λ (n)
    (Σ ((half Nat))
      (= Nat n (double half )))))

(claim Odd
  (→ Nat
    U ))

(define Odd
  (λ (n)
    (Σ ((haf Nat))
      (= Nat n (add1 (double haf )))))) 

(claim zero-is-even
  (Even 0))

(define zero-is-even
  (cons 0
    (same 0)))

(claim add1-even->odd
  (Π ((n Nat))
    (→ (Even n)
    (Odd (add1 n)))))

(define add1-even->odd
  (λ (n en)
    (cons (car en)
    (cong (cdr en) (+ 1)))))

(claim add1-odd->even
  (Π ((n Nat))
    (→ (Odd n)
      (Even (add1 n)))))

(define add1-odd->even
  (λ (n on)
    (cons (add1 (car on))
      (cong (cdr on) (+ 1)))))

(claim even-or-odd
  (Π ((n Nat))
    (Either (Even n) (Odd n))))

;; This is the proof in The Little Typer
;; (claim mot-even-or-odd
;;   (→ Nat U )) 

;; (define mot-even-or-odd
;;   (λ (k) (Either (Even k) (Odd k))))

;; (claim step-even-or-odd
;;   (Π ((n-1 Nat))
;;      (→ (mot-even-or-odd n-1)
;;      (mot-even-or-odd (add1 n-1)))))

;; (define step-even-or-odd
;;   (λ (n-1)
;;     (λ (e-or-on-1)
;;        (ind-Either e-or-on-1
;;     (λ (e-or-on-1)
;;        (mot-even-or-odd (add1 n-1)))
;;        (λ (en-1)
;;          (right
;;            (add1-even->odd
;;              n-1 en-1)))
;;        (λ (on-1)
;;          (left
;;            (add1-odd->even
;;              n-1 on-1)))))))

;; (define even-or-odd
;;   (λ (n)
;;     (ind-Nat n
;;        mot-even-or-odd
;;        (left zero-is-even)
;;        step-even-or-odd)))


;; This is the proof using our new tactic system
(define-tactically even-or-odd
  ( (intro n)
    (elimNat n)
    (left)
    (exact zero-is-even)
    (intro n-1)
    (intro e-or-on-1)
    (elimEither e-or-on-1)
    (intro xr)
    (right)
    (exact ((add1-even->odd n-1) xr))
    (intro x1)
    (left)
    (exact ((add1-odd->even n-1) x1))
   ))


        `
        console.log(evaluatePie(str))
    })
})
</file>

<file path="src/pie_interpreter/parser/makers.ts">
import { Syntax } from "../utils/locations";
import * as S from "../types/source";
import { syntaxToLocation } from "./parser";
import { SiteBinder, TypedBinder } from "../types/utils";
import { EliminateNatTactic, EliminateListTactic, ExactTactic, IntroTactic, Tactic, EliminateVecTactic, EliminateEqualTactic, ExistsTactic, LeftTactic, RightTactic, EliminateEitherTactic, SpiltTactic, EliminateAbsurdTactic } from "../tactics/tactics";
import { DefineDatatypeSource, GeneralConstructor } from "../typechecker/definedatatype";


export function makeU(stx: Syntax): S.Source {

  return new S.Universe(syntaxToLocation(stx));

}



export function makeArrow(stx: Syntax, args: [S.Source, S.Source, S.Source[]]): S.Source {

  return new S.Arrow(syntaxToLocation(stx), args[0], args[1], args[2]);

}



export function makeNat(stx: Syntax): S.Source {

  return new S.Nat(syntaxToLocation(stx));

}



export function makeZero(stx: Syntax): S.Source {

  return new S.Zero(syntaxToLocation(stx));

}



export function makeAdd1(stx: Syntax, n: S.Source): S.Source {

  return new S.Add1(syntaxToLocation(stx), n);

}



export function makeLambda(stx: Syntax, binders: SiteBinder[], body: S.Source): S.Source {

  return new S.Lambda(syntaxToLocation(stx), binders, body);

}



export function makePi(stx: Syntax, binders: TypedBinder[], body: S.Source): S.Source {

  return new S.Pi(syntaxToLocation(stx), binders, body);

}



export function makeSigma(stx: Syntax, binders: TypedBinder[], body: S.Source): S.Source {

  return new S.Sigma(syntaxToLocation(stx), binders, body);

}



export function makeTypedBinders(head: TypedBinder, tail: TypedBinder[]): TypedBinder[] {

  return [head, ...tail];

}



export function makeApp(stx: Syntax, func: S.Source, arg0: S.Source, args: S.Source[]): S.Source {

  return new S.Application(syntaxToLocation(stx), func, arg0, args);

}



export function makeAtom(stx: Syntax): S.Source {

  return new S.Atom(syntaxToLocation(stx));

}



export function makeTrivial(stx: Syntax): S.Source {

  return new S.Trivial(syntaxToLocation(stx));

}



export function makeSole(stx: Syntax): S.Source {

  return new S.Sole(syntaxToLocation(stx));

}



export function makeList(stx: Syntax, type: S.Source): S.Source {

  return new S.List(syntaxToLocation(stx), type);

}



export function makeVec(stx: Syntax, type: S.Source, len: S.Source): S.Source {

  return new S.Vec(syntaxToLocation(stx), type, len);

}



export function makeEither(stx: Syntax, left: S.Source, right: S.Source): S.Source {

  return new S.Either(syntaxToLocation(stx), left, right);

}



export function makeNil(stx: Syntax): S.Source {

  return new S.Nil(syntaxToLocation(stx));

}



export function makeVecCons(stx: Syntax, head: S.Source, tail: S.Source): S.Source {

  return new S.VecCons(syntaxToLocation(stx), head, tail);

}



export function makeVecNil(stx: Syntax): S.Source {

  return new S.VecNil(syntaxToLocation(stx));

}



export function makeAbsurd(stx: Syntax): S.Source {

  return new S.Absurd(syntaxToLocation(stx));

}



export function makePair(stx: Syntax, head: S.Source, tail: S.Source): S.Source {

  return new S.Pair(syntaxToLocation(stx), head, tail);

}



export function makeCons(stx: Syntax, head: S.Source, tail: S.Source): S.Source {

  return new S.Cons(syntaxToLocation(stx), head, tail);

}



export function makeListCons(stx: Syntax, head: S.Source, tail: S.Source): S.Source {

  return new S.ListCons(syntaxToLocation(stx), head, tail);

}



export function makeThe(stx: Syntax, type: S.Source, value: S.Source): S.Source {

  return new S.The(syntaxToLocation(stx), type, value);

}



export function makeIndAbsurd(stx: Syntax, head: S.Source, tail: S.Source): S.Source {

  return new S.IndAbsurd(syntaxToLocation(stx), head, tail);

}



export function makeTrans(stx: Syntax, from: S.Source, to: S.Source): S.Source {

  return new S.Trans(syntaxToLocation(stx), from, to);

}



export function makeCong(stx: Syntax, from: S.Source, to: S.Source): S.Source {

  return new S.Cong(syntaxToLocation(stx), from, to);

}



export function makeIndEqual(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source): S.Source {

  return new S.IndEqual(syntaxToLocation(stx), target, mot, base);

}



export function makeWhichNat(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source {

  return new S.WhichNat(syntaxToLocation(stx), target, base, step);

}



export function makeIterNat(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source {

  return new S.IterNat(syntaxToLocation(stx), target, base, step);

}



export function makeRecNat(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source {

  return new S.RecNat(syntaxToLocation(stx), target, base, step);

}



export function makeIndNat(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source {

  return new S.IndNat(syntaxToLocation(stx), target, mot, base, step);

}



export function makeRecList(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source {

  return new S.RecList(syntaxToLocation(stx), target, base, step);

}



export function makeIndList(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source {

  return new S.IndList(syntaxToLocation(stx), target, mot, base, step);

}



export function makeIndEither(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source {

  return new S.IndEither(syntaxToLocation(stx), target, mot, base, step);

}



export function makeIndVec(stx: Syntax, length: S.Source, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source {

  return new S.IndVec(syntaxToLocation(stx), length, target, mot, base, step);

}



export function makeEqual(stx: Syntax, type: S.Source, left: S.Source, right: S.Source): S.Source {

  return new S.Equal(syntaxToLocation(stx), type, left, right);

}



export function makeReplace(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source): S.Source {

  return new S.Replace(syntaxToLocation(stx), target, mot, base);

}



export function makeSymm(stx: Syntax, equality: S.Source): S.Source {

  return new S.Symm(syntaxToLocation(stx), equality);

}



export function makeHead(stx: Syntax, vec: S.Source): S.Source {

  return new S.Head(syntaxToLocation(stx), vec);

}



export function makeTail(stx: Syntax, vec: S.Source): S.Source {

  return new S.Tail(syntaxToLocation(stx), vec);

}



export function makeSame(stx: Syntax, type: S.Source): S.Source {

  return new S.Same(syntaxToLocation(stx), type);

}



export function makeLeft(stx: Syntax, value: S.Source): S.Source {

  return new S.Left(syntaxToLocation(stx), value);

}



export function makeRight(stx: Syntax, value: S.Source): S.Source {

  return new S.Right(syntaxToLocation(stx), value);

}



export function makeCar(stx: Syntax, pair: S.Source): S.Source {

  return new S.Car(syntaxToLocation(stx), pair);

}



export function makeCdr(stx: Syntax, pair: S.Source): S.Source {

  return new S.Cdr(syntaxToLocation(stx), pair);

}



export function makeQuote(stx: Syntax, quoted: string): S.Source {

  return new S.Quote(syntaxToLocation(stx), quoted);

}



export function makeVarRef(stx: Syntax, ref: string): S.Source {

  return new S.Name(syntaxToLocation(stx), ref);

}



export function makeNatLiteral(stx: Syntax, num: string): S.Source {

  return new S.Number(syntaxToLocation(stx), Number(num));

}



export function makeTODO(stx: Syntax): S.Source {

  return new S.TODO(syntaxToLocation(stx));

}



export function makeIntro(stx: Syntax, name?: string): Tactic {

  return new IntroTactic(syntaxToLocation(stx), name);

}



export function makeExact(stx: Syntax, expr: S.Source): Tactic {

  return new ExactTactic(syntaxToLocation(stx), expr);

}

export function makeExists(stx: Syntax, value: S.Source, name?: string): Tactic {

  return new ExistsTactic(syntaxToLocation(stx), value, name);

}



export function makeElimNat(stx: Syntax, target: string): Tactic {

  return new EliminateNatTactic(syntaxToLocation(stx), target);

}

export function makeElimList(stx: Syntax, target: string, motive?: S.Source): Tactic {

  return new EliminateListTactic(syntaxToLocation(stx), target, motive);

}

export function makeElimVec(stx: Syntax, target: string, motive: S.Source, length: S.Source): Tactic {

  return new EliminateVecTactic(syntaxToLocation(stx), target, motive, length);

}

export function makeElimEqual(stx: Syntax, target: string, motive?: S.Source): Tactic {

  return new EliminateEqualTactic(syntaxToLocation(stx), target, motive);

}

export function makeLeftTactic(stx: Syntax): Tactic {

  return new LeftTactic(syntaxToLocation(stx))

}

export function makeRightTactic(stx: Syntax): Tactic {

  return new RightTactic(syntaxToLocation(stx))

}

export function makeElimEither(stx: Syntax, target: string, motive?: S.Source): Tactic {

  return new EliminateEitherTactic(syntaxToLocation(stx), target, motive);

}

export function makeSplit(stx: Syntax) {

  return new SpiltTactic(syntaxToLocation(stx));

}

export function makeElimAbsurd(stx: Syntax, target: string, motive?: S.Source): Tactic {

  return new EliminateAbsurdTactic(syntaxToLocation(stx), target, motive);

}



export function makeDefineDatatype(
  stx: Syntax,
  name: string,
  parameters: TypedBinder[],
  indices: TypedBinder[],
  constructors: GeneralConstructor[],
  eliminatorName?: string
): DefineDatatypeSource {

  return new DefineDatatypeSource(
    syntaxToLocation(stx),
    name,
    parameters,
    indices,
    constructors,
    eliminatorName
  );

}



export function makeGeneralConstructor(
  stx: Syntax,
  name: string,
  args: TypedBinder[],
  returnType: S.GeneralTypeConstructor
): GeneralConstructor {

  return new GeneralConstructor(
    syntaxToLocation(stx),
    name,
    args,
    returnType
  );

}



export function makeConstructorApplication(
  stx: Syntax,
  constructorName: string,
  args: S.Source[]
): S.ConstructorApplication {

  return new S.ConstructorApplication(
    syntaxToLocation(stx),
    constructorName,
    args
  );

}



export function makeEliminatorApplication(
  stx: Syntax,
  typeName: string,
  target: S.Source,
  motive: S.Source,
  methods: S.Source[]
): S.EliminatorApplication {

  return new S.EliminatorApplication(
    syntaxToLocation(stx),
    typeName,
    target,
    motive,
    methods
  );

}



export function makeGeneralTypeConstructor(
  stx: Syntax,
  name: string,
  params: S.Source[],
  indices: S.Source[]
): S.GeneralTypeConstructor {

  return new S.GeneralTypeConstructor(
    syntaxToLocation(stx),
    name,
    params,
    indices
  );

}
</file>

<file path="web/worker-entry.ts">
import { schemeParse, pieDeclarationParser, Claim, Definition, SamenessCheck, DefineTactically } from '../src/pie_interpreter/parser/parser';
import { initCtx, addClaimToContext, addDefineToContext, addDefineTacticallyToContext, Context, Define } from '../src/pie_interpreter/utils/context';
import { checkSame, represent } from '../src/pie_interpreter/typechecker/represent';
import { go, stop, Message } from '../src/pie_interpreter/types/utils';
import { readBack } from '../src/pie_interpreter/evaluator/utils';
import { prettyPrintCore } from '../src/pie_interpreter/unparser/pretty';
import { DefineDatatypeSource, handleDefineDatatype } from '../src/pie_interpreter/typechecker/definedatatype';
import { ProofTreeData } from '../src/pie_interpreter/tactics/proofstate';

export interface Diagnostic {
  message: string;
  startLineNumber: number;
  startColumn: number;
  endLineNumber: number;
  endColumn: number;
  severity: 'error' | 'warning';
}

export interface AnalysisResult {
  diagnostics: Diagnostic[];
  summary: string;
  pretty?: string;
  messages?: string;
  proofTree?: ProofTreeData;
}

export function analyzePieSource(source: string): AnalysisResult {
  const trimmed = source.trim();
  if (!trimmed) {
    return {
      diagnostics: [],
      summary: 'Waiting for input…'
    };
  }

  const diagnostics: Diagnostic[] = [];
  const ctx = cloneContext(initCtx);
  let messages = '';
  let proofTree: ProofTreeData | undefined;

  try {
    const astList = schemeParse(source);

    for (const ast of astList) {
      const declaration = pieDeclarationParser.parseDeclaration(ast);
      const result = processDeclaration(ctx, declaration);
      // Capture message and proofTree even when there's a diagnostic
      // (e.g., incomplete proofs still have useful visualization data)
      if (result.message) {
        messages += result.message;
      }
      if (result.proofTree) {
        proofTree = result.proofTree;
      }
      if (result.diagnostic) {
        diagnostics.push(result.diagnostic);
        break;
      }
      if (result.message) {
        messages += result.message;
      }
    }
  } catch (error) {
    diagnostics.push(parseThrownError(error));
  }

  const summary = diagnostics.length === 0
    ? 'No issues detected.'
    : diagnostics.some(item => item.severity === 'error') ? 'Errors detected.' : 'Warnings detected.';

  let pretty: string | undefined;
  if (diagnostics.length === 0) {
    const contextOutput = formatContext(ctx);
    // Combine messages (tactic output) with context output
    pretty = messages ? messages + '\n' + contextOutput : contextOutput;
  }

  return {
    diagnostics,
    summary,
    pretty,
    messages: messages || undefined,
    proofTree
  };
}

interface DeclarationResult {
  diagnostic: Diagnostic | null;
  message?: string;
  proofTree?: ProofTreeData;
}

function processDeclaration(ctx: Context, declaration: ReturnType<typeof pieDeclarationParser.parseDeclaration>): DeclarationResult {
  try {
    if (declaration instanceof Claim) {
      const result = addClaimToContext(ctx, declaration.name, declaration.location, declaration.type);
      if (result instanceof go) {
        assignContext(ctx, result.result);
        return { diagnostic: null };
      }
      return { diagnostic: diagnosticFromStop(result as stop) };
    } else if (declaration instanceof Definition) {
      const result = addDefineToContext(ctx, declaration.name, declaration.location, declaration.expr);
      if (result instanceof go) {
        assignContext(ctx, result.result);
        return { diagnostic: null };
      }
      return { diagnostic: diagnosticFromStop(result as stop) };
    } else if (declaration instanceof SamenessCheck) {
      const outcome = checkSame(ctx, declaration.location, declaration.type, declaration.left, declaration.right);
      if (outcome instanceof go) {
        return { diagnostic: null };
      }
      return { diagnostic: diagnosticFromStop(outcome as stop) };
    } else if (declaration instanceof DefineTactically) {
      const result = addDefineTacticallyToContext(ctx, declaration.name, declaration.location, declaration.tactics);
      if (result instanceof go) {
        assignContext(ctx, result.result.context);
        // Check if proof was incomplete
        if (result.result.isIncomplete) {
          const loc = declaration.location.locationToSrcLoc();
          return {
            diagnostic: {
              message: 'Proof incomplete. Not all goals have been solved.',
              startLineNumber: loc.startLine,
              startColumn: Math.max(1, loc.startColumn),
              endLineNumber: loc.endLine ?? loc.startLine,
              endColumn: Math.max(loc.endColumn ?? loc.startColumn + 1, loc.startColumn + 1),
              severity: 'error' as const
            },
            message: result.result.message,
            proofTree: result.result.proofTree
          };
        }
        return { diagnostic: null, message: result.result.message, proofTree: result.result.proofTree };
      }
      return { diagnostic: diagnosticFromStop(result as stop) };
    } else if (declaration instanceof DefineDatatypeSource) {
      const result = handleDefineDatatype(ctx, new Map(), declaration);
      if (result instanceof go) {
        assignContext(ctx, result.result);
        return { diagnostic: null };
      }
      return { diagnostic: diagnosticFromStop(result as stop) };
    } else {
      const outcome = represent(ctx, declaration);
      if (outcome instanceof go) {
        return { diagnostic: null };
      }
      return { diagnostic: diagnosticFromStop(outcome as stop) };
    }
  } catch (error) {
    return { diagnostic: parseThrownError(error) };
  }
}

function diagnosticFromStop(result: stop): Diagnostic {
  const loc = result.where.locationToSrcLoc();
  return {
    message: formatMessage(result.message),
    startLineNumber: loc.startLine,
    startColumn: Math.max(1, loc.startColumn),
    endLineNumber: loc.endLine ?? loc.startLine,
    endColumn: Math.max(loc.endColumn ?? loc.startColumn + 1, loc.startColumn + 1),
    severity: 'error'
  };
}

function parseThrownError(error: unknown): Diagnostic {
  if (error instanceof Error) {
    const message = error.message || 'Unknown error';
    const parsed = parseLocationFromMessage(message);
    return parsed ?? fallbackDiagnostic(message);
  }
  return fallbackDiagnostic(typeof error === 'string' ? error : 'Unknown error');
}

function parseLocationFromMessage(message: string): Diagnostic | null {
  const goOnMatch = /Error message: (.*) at (.*):(\d+):(\d+)/s.exec(message);
  if (goOnMatch) {
    const [, rawMsg, , line, column] = goOnMatch;
    return {
      message: cleanMessage(rawMsg),
      startLineNumber: Number(line),
      startColumn: Number(column),
      endLineNumber: Number(line),
      endColumn: Number(column) + 1,
      severity: 'error'
    };
  }

  const genericMatch = /(.*):(\d+):(\d+)(.*)/s.exec(message);
  if (genericMatch) {
    const [, , line, column, tail] = genericMatch;
    const msg = message.replace(/^[^:]+:\d+:\d+/, '').trim();
    return {
      message: cleanMessage(msg || tail || 'Error'),
      startLineNumber: Number(line),
      startColumn: Number(column),
      endLineNumber: Number(line),
      endColumn: Number(column) + 1,
      severity: 'error'
    };
  }

  return null;
}

function fallbackDiagnostic(message: string): Diagnostic {
  return {
    message: cleanMessage(message),
    startLineNumber: 1,
    startColumn: 1,
    endLineNumber: 1,
    endColumn: 2,
    severity: 'error'
  };
}

function cleanMessage(message: string): string {
  return message
    .replace(/^\[|\]$/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

function formatMessage(message: Message): string {
  return message.message
    .map(part => typeof part === 'string' ? part : part.prettyPrint())
    .join(' ');
}

function cloneContext(ctx: Context): Context {
  return new Map(ctx);
}

function assignContext(target: Context, next: Context): void {
  target.clear();
  for (const [key, value] of next) {
    target.set(key, value);
  }
}

function formatContext(ctx: Context): string {
  const lines: string[] = [];
  for (const [name, binder] of ctx) {
    if (binder instanceof Define) {
      const type = prettyPrintCore(binder.type.readBackType(ctx));
      const value = prettyPrintCore(readBack(ctx, binder.type, binder.value));
      lines.push(`${name} : ${type}`);
      lines.push(`${name} = ${value}`);
    } else if (binder.type) {
      const type = prettyPrintCore(binder.type.readBackType(ctx));
      lines.push(`${name} : ${type}`);
    }
  }
  return lines.join('\n');
}
</file>

<file path="src/pie_interpreter/typechecker/utils.ts">
import { Value } from "../types/value";
import { Source } from "../types/source";
import { Application } from "../types/source";
import { Core } from "../types/core";
import { Location } from "../utils/locations";
import { Context, SerializableContext } from "../utils/context";
import { go, stop, Perhaps, Message } from "../types/utils";
import { alphaEquiv } from "../utils/alphaeqv";
import { readBack } from "../evaluator/utils";
import { todoQueue } from "../solver/todo_solver";


type What = 'definition'
  | ['binding-site', Core]
  | ['is-type', Core]
  | ['has-type', Core]
  | ['TODO', SerializableContext, Core, Renaming];


// TODO: Implement PieInfoHook

export function PieInfoHook(where: Location, what: What): void {
  if (Array.isArray(what) && what[0] === 'TODO') {
    const [_, serializedCtx, expectedTypeCore, renaming] = what;

    // Reconstruct the actual Context from SerializableContext
    // For now, we'll use a simpler approach - just pass empty context
    // TODO: Properly deserialize SerializableContext to Context
    const ctx = new Map();

    // Convert Core type to Value for storage
    const expectedTypeValue = expectedTypeCore.valOf(new Map());

    // Queue for processing with real objects
    todoQueue.push({
      location: where,
      context: ctx,
      expectedType: expectedTypeValue,
      renaming: renaming
    });
  }
}

export function SendPieInfo(where: Location, what: What): void {
  if (where.forInfo) {
    PieInfoHook(where, what);
  }
}

// ### Renamings

export type Renaming = Map<string, string>;

// Function to rename a symbol using the Renaming list
export function rename(renames: Renaming, x: string): string {
  const rename = renames.get(x);
  return rename ? rename : x;
}

// Function to extend the Renaming list with a new pair
export function extendRenaming(renames: Renaming, from: string, to: string): Renaming {
  const newRenames = new Map([[from, to], ...renames]);
  return newRenames;
}

// ### Check the form of judgment Γ ⊢ c ≡ c type
export function sameType(ctx: Context, where: Location, given: Value, expected: Value): Perhaps<undefined> {
  const givenE = given.readBackType(ctx);
  const expectedE = expected.readBackType(ctx);
  if (alphaEquiv(givenE, expectedE)) {
    return new go(undefined);
  } else {
    return new stop(
      where,
      new Message([`Expected ${expectedE} but got ${givenE}`])
    );
  }
}

// ### Check the form of judgment Γ ⊢ c : A type
export function convert(ctx: Context, where: Location, type: Value, from: Value, to: Value): Perhaps<undefined> {
  const fromE = readBack(ctx, type, from);
  const toE = readBack(ctx, type, to);
  if (alphaEquiv(fromE, toE)) {
    return new go(undefined);
  } else {
    return new stop(
      where,
      new Message([`The terms ${from.prettyPrint()} and ${to.prettyPrint()} are not the same ${type.prettyPrint()}.`])
    );
  }
}

// ### Claims + defines ###

export function atomOk(a: string): boolean {
  return allOkAtom(a.split(''));
}

function allOkAtom(cs: string[]): boolean {
  if (cs.length === 0) {
    return true;
  } else if (isAlphabetic(cs[0]) || cs[0] === '-') {
    return allOkAtom(cs.slice(1));
  } else {
    return false;
  }
}

function isAlphabetic(char: string): boolean {
  return /^[a-zA-Z]$/.test(char);
}

// Helper to concoct a function application form in source syntax
export function makeApp(a: Source, b: Source, cs: Source[]): Source {
  return new Application(a.location, a, b, cs);
}
</file>

<file path="rollup.config.js">
import nodeResolve from "@rollup/plugin-node-resolve";
import terser from "@rollup/plugin-terser";
import typescript from '@rollup/plugin-typescript';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

// Plugin to stub out Node.js built-in modules for browser bundles
function stubNodeBuiltins() {
  const stubs = {
    'fs': 'export default {}',
    'path': 'export default {}',
    'fs/promises': 'export default {}',
    'process': 'export default { argv: [] }',
    'escodegen': 'export default {}',
    'dotenv': 'export const config = () => ({ parsed: {} }); export default { config };',
    'dotenv/config': 'export const config = () => ({ parsed: {} }); export default config;',
    'util': 'export function inspect() { return ""; } export default { inspect };'
  };

  return {
    name: 'stub-node-builtins',
    resolveId(source) {
      if (stubs[source]) {
        return source;
      }
      return null;
    },
    load(id) {
      if (stubs[id]) {
        return stubs[id];
      }
      return null;
    }
  };
}

export default [
  // Main bundle for distribution
  {
    input: 'src/pie_interpreter/index.ts',
    output: {
      file: 'dist/index.js',
      format: 'iife',
      sourcemap: true
    },
    plugins: [typescript(), nodeResolve(), terser()]
  },
  // Web worker bundle for the playground
  {
    input: 'web/worker-entry.ts',
    output: {
      file: 'web/pie-worker-bundle.js',
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      (function workerTodoSolverStub() {
        const filename = fileURLToPath(import.meta.url);
        const dirname = path.dirname(filename);
        const browserTodoSolverPath = path.resolve(dirname, 'src/pie_interpreter/solver/todo_solver.browser.ts');
        const browserTodoSolverSpecifiers = new Set([
          '../solver/todo_solver',
          '../../solver/todo_solver',
        ]);
        return {
          name: 'worker-todo-solver-stub',
          resolveId(source) {
            if (browserTodoSolverSpecifiers.has(source)) {
              return browserTodoSolverPath;
            }
            return null;
          }
        };
      })(),
      stubNodeBuiltins(), // Stub out Node.js modules before other plugins
      typescript({
        tsconfig: false,
        compilerOptions: {
          module: 'ESNext',
          target: 'ES2020',
          lib: ['ES2022', 'DOM'],
          sourceMap: true,
          strict: true,
          esModuleInterop: true,
          allowSyntheticDefaultImports: true,
          skipLibCheck: true,
          declaration: false,
          declarationMap: false
        }
      }),
      nodeResolve({
        browser: true,
        preferBuiltins: false
      }),
      terser()
    ]
  },
  // LSP worker bundle for the web interface (simple version)
  {
    input: 'web/lsp/pie-language-server-simple.worker.ts',
    output: {
      file: 'web/lsp/pie-lsp-worker-bundle.js',
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      (function workerTodoSolverStub() {
        const filename = fileURLToPath(import.meta.url);
        const dirname = path.dirname(filename);
        const browserTodoSolverPath = path.resolve(dirname, 'src/pie_interpreter/solver/todo_solver.browser.ts');
        const browserTodoSolverSpecifiers = new Set([
          '../solver/todo_solver',
          '../../solver/todo_solver',
        ]);
        return {
          name: 'worker-todo-solver-stub',
          resolveId(source) {
            if (browserTodoSolverSpecifiers.has(source)) {
              return browserTodoSolverPath;
            }
            return null;
          }
        };
      })(),
      stubNodeBuiltins(), // Stub out Node.js modules before other plugins
      typescript({
        tsconfig: false,
        compilerOptions: {
          module: 'ESNext',
          target: 'ES2020',
          lib: ['ES2022', 'DOM', 'WebWorker'],
          sourceMap: true,
          strict: false, // Disable strict for simpler worker
          esModuleInterop: true,
          allowSyntheticDefaultImports: true,
          skipLibCheck: true,
          declaration: false,
          declarationMap: false
        }
      }),
      nodeResolve({
        browser: true,
        preferBuiltins: false
      }),
      terser()
    ]
  },
  // LSP client bundle for the web interface (simple version without monaco-languageclient)
  {
    input: 'web/lsp/lsp-client-simple.ts',
    output: {
      file: 'web/lsp/lsp-client-bundle.js',
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      stubNodeBuiltins(),
      typescript({
        tsconfig: false,
        compilerOptions: {
          module: 'ESNext',
          target: 'ES2020',
          lib: ['ES2022', 'DOM'],
          sourceMap: true,
          strict: false, // Disable strict mode for Monaco any types
          esModuleInterop: true,
          allowSyntheticDefaultImports: true,
          skipLibCheck: true,
          declaration: false,
          declarationMap: false
        }
      }),
      nodeResolve({
        browser: true,
        preferBuiltins: false
      }),
      terser()
    ]
  },
  // Main app bundle for the playground
  {
    input: 'web/app.ts',
    output: {
      file: 'web/app.bundle.js',
      format: 'esm',
      sourcemap: true
    },
    plugins: [
      stubNodeBuiltins(),
      typescript({
        tsconfig: false,
        compilerOptions: {
          module: 'ESNext',
          target: 'ES2020',
          lib: ['ES2022', 'DOM'],
          sourceMap: true,
          strict: false, // Disable strict mode for Monaco any types
          esModuleInterop: true,
          allowSyntheticDefaultImports: true,
          skipLibCheck: true,
          declaration: false,
          declarationMap: false
        }
      }),
      nodeResolve({
        browser: true,
        preferBuiltins: false
      }),
      terser()
    ]
  }
];
</file>

<file path="src/pie_interpreter/__tests__/test_parser.ts">
import 'jest';
import { schemeParse, pieDeclarationParser } from '../parser/parser';

function testParser(input: string) {
  const parsed = schemeParse(input);
  return pieDeclarationParser.parseDeclaration(parsed[0]);
}

describe("Inductive Types Parser", () => {
  it("Parse Bool (no params, no indices)", () => {
    const input =
    `(data Bool () ()
      (true () (Bool () ()))
      (false () (Bool () ()))
      ind-Bool)

    (claim my-true (Bool () ()))
    (define my-true (true))

    (claim my-false (Bool () ()))
    (define my-false (false))

    (claim bool-to-nat (-> (Bool () ()) Nat))
    (define bool-to-nat
      (lambda (b)
        (ind-Bool b
          (lambda (x) Nat)
          (add1 zero)
          zero)))

    (claim result1 Nat)
    (define result1 (bool-to-nat my-true))

    (claim result2 Nat)
    (define result2 (bool-to-nat my-false))
    `;
    const result = testParser(input);
  });

  it("Parse MyNat (no params, no indices)", () => {
    const input = `
    (data MyNat () ()
      (myZero () (MyNat () ()))
      (mySucc ((n (MyNat () ()))) (MyNat () ()))
      ind-MyNat)

    (claim zero-nat (MyNat () ()))
    (define zero-nat (myZero))

    (claim two-nat (MyNat () ()))
    (define two-nat (mySucc (mySucc zero-nat)))

    (claim count (-> (MyNat () ()) Nat))
    (define count
      (lambda (n)
        (ind-MyNat n
          (lambda (x) Nat)
          zero
          (lambda (n-1 ih) (add1 ih)))))

    (claim result Nat)
    (define result (count two-nat))
    `;
    const result = testParser(input);
  });

  it("Parse MyList (parameterized, no indices)", () => {
    const input = `
    (data MyList ((E U)) ()
      (myNil () (MyList (E) ()))
      (myCons ((head E) (tail (MyList (E) ()))) (MyList (E) ()))
      ind-MyList)

    (claim empty-list (MyList (Nat) ()))
    (define empty-list (myNil))

    (claim one-elem-list (MyList (Nat) ()))
    (define one-elem-list (myCons zero empty-list))

    (claim two-elem-list (MyList (Nat) ()))
    (define two-elem-list (myCons (add1 zero) one-elem-list))

    (claim nat-list-length (-> (MyList (Nat) ()) Nat))
    (define nat-list-length
      (lambda (xs)
        (ind-MyList xs
          (lambda (l) Nat)
          zero
          (lambda (h t ih) (add1 ih)))))

    (claim result Nat)
    (define result (nat-list-length two-elem-list))
    `;
    const result = testParser(input);
  });

  it("Parse MyVec (parameterized and indexed)", () => {
    const input = `
    (data MyVec ((E U)) ((n Nat))
      (myVecNil () (MyVec (E) (zero)))
      (myVecCons ((k Nat) (head E) (tail (MyVec (E) (k)))) (MyVec (E) ((add1 k))))
      ind-MyVec)

    (claim empty-vec (MyVec (Nat) (zero)))
    (define empty-vec (myVecNil))

    (claim one-vec (MyVec (Nat) ((add1 zero))))
    (define one-vec (myVecCons zero (add1 zero) empty-vec))

    (claim vec-to-nat (Pi ((n Nat)) (-> (MyVec (Nat) (n)) Nat)))
    (define vec-to-nat
      (lambda (n v)
        (ind-MyVec v
          (lambda (len vec) Nat)
          zero
          (lambda (k h t ih) (add1 ih)))))

    (claim result Nat)
    (define result (vec-to-nat (add1 zero) one-vec))
    `;
    const result = testParser(input);
  });

  it("Parse Less-Than (no params, indexed)", () => {
    const input = `
    (data Less-Than () ((j Nat) (k Nat))
      (zero-smallest ((n Nat)) (Less-Than () (zero (add1 n))))
      (add1-smaller ((j Nat) (k Nat) (j<k (Less-Than () (j k)))) (Less-Than () ((add1 j) (add1 k))))
      ind-Less-Than)

    (claim proof-0<1 (Less-Than () (zero (add1 zero))))
    (define proof-0<1 (zero-smallest zero))

    (claim proof-1<2 (Less-Than () ((add1 zero) (add1 (add1 zero)))))
    (define proof-1<2 (add1-smaller zero (add1 zero) proof-0<1))

    (claim extract-smaller
      (Pi ((j Nat) (k Nat))
        (-> (Less-Than () (j k)) Nat)))
    (define extract-smaller
      (lambda (j k proof)
        (ind-Less-Than proof
          (lambda (j-idx k-idx p) Nat)
          (lambda (n) zero)
          (lambda (j-arg k-arg j<k-arg ih) (add1 ih)))))

    (claim result Nat)
    (define result (extract-smaller zero (add1 zero) proof-0<1))
    `;
    const result = testParser(input);
  });

  it("Parse MyEither (parameterized, no indices)", () => {
    const input = `
    (data MyEither ((L U) (R U)) ()
      (myLeft ((value L)) (MyEither (L R) ()))
      (myRight ((value R)) (MyEither (L R) ()))
      ind-MyEither)

    (claim left-val (MyEither (Nat Atom) ()))
    (define left-val (myLeft zero))

    (claim right-val (MyEither (Nat Atom) ()))
    (define right-val (myRight (quote foo)))

    (claim either-to-nat (-> (MyEither (Nat Atom) ()) Nat))
    (define either-to-nat
      (lambda (e)
        (ind-MyEither e
          (lambda (x) Nat)
          (lambda (lval) (add1 zero))
          (lambda (rval) zero))))

    (claim result1 Nat)
    (define result1 (either-to-nat left-val))

    (claim result2 Nat)
    (define result2 (either-to-nat right-val))
    `;
    const result = testParser(input);
  });
})
</file>

<file path="src/pie_interpreter/types/utils.ts">
import { Source } from "./source"
import { Core } from "./core"
import * as C from "./core";
import { Location } from "../utils/locations";
import { Value } from "./value";
import * as V from "./value";
import * as N from "./neutral";
import { Environment, extendEnvironment} from "../utils/environment";
import { Context } from "../utils/context";
import { freshen } from "../utils/fresh";


// A SiteBinder is a variable name and its location, substitute BindingSite in original code.

export class SiteBinder {
  constructor(
    public location: Location,
    public varName: string,
  ) { }

  public prettyPrint(): string {
    return `${this.varName}`;
  }
}

// Define TypedBinder, which is a SiteBinder associated with a expression in Pie.

export class TypedBinder {
  constructor(
    public binder: SiteBinder,
    public type: Source,
  ) {}

  public prettyPrint(): string {
    return `${this.binder.prettyPrint()} : ${this.type.prettyPrint()}`;
  }

  public findNames(): string {
    return this.binder.varName;
  }
}

export function isPieKeywords(str : string) : boolean {
  return str === 'U' ? true : 
    str === 'Nat' ? true :
    str === 'zero' ? true :
    str === 'add1' ? true :
    str === 'which-Nat' ? true :
    str === 'iter-Nat' ? true :
    str === 'rec-Nat' ? true :
    str === 'ind-Nat' ? true :
    str === '->' ? true :
    str === '→' ? true :
    str === 'Π' ? true :
    str === 'λ' ? true :
    str === 'Pi' ? true :
    str === '∏' ? true :
    str === 'lambda' ? true :
    str === 'quote' ? true :
    str === 'Atom' ? true :
    str === 'car' ? true :
    str === 'cdr' ? true :
    str === 'cons' ? true :
    str === 'Σ' ? true :
    str === 'Sigma' ? true :
    str === 'Pair' ? true :
    str === 'Trivial' ? true :
    str === 'sole' ? true :
    str === 'List' ? true :
    str === '::' ? true :
    str === 'nil' ? true :
    str === 'rec-List' ? true :
    str === 'ind-List' ? true :
    str === 'Absurd' ? true :
    str === 'ind-Absurd' ? true :
    str === '=' ? true :
    str === 'same' ? true :
    str === 'replace' ? true :
    str === 'trans' ? true :
    str === 'cong' ? true :
    str === 'symm' ? true :
    str === 'ind-=' ? true :
    str === 'Vec' ? true :
    str === 'vecnil' ? true :
    str === 'vec::' ? true :
    str === 'head' ? true :
    str === 'tail' ? true :
    str === 'ind-Vec' ? true :
    str === 'Either' ? true :
    str === 'left' ? true :
    str === 'right' ? true :
    str === 'ind-Either' ? true :
    str === 'TODO' ? true :
    str === 'the' ? true :
    false;
}


export class Message {
  
  constructor(public message: Array<string|Core>) { }
  
  public toString(): string {
    return this.message.map(m => typeof m === 'string' ? m : (m as Core).prettyPrint()).join(' ');
  }

}

export abstract class Perhaps<T> { // eslint-disable-line @typescript-eslint/no-unused-vars

}

export class go<T> extends Perhaps<T> {
  constructor(public result: T) { super() }
}

// A failure result named "stop"
export class stop extends Perhaps<undefined> {
  constructor(
    public where: Location,
    public message: Message
  ) { super() }
}

export class PerhapsM<T> {
  // name is majorly for debugging use.
  constructor(public name: string, public value: T = null as any) { }
}

/*
  go-on is very much like let*. The difference is that if any of the
  values bound to variables in it are stop, then the entire
  expression becomes that first stop. Otherwise, the variables are
  bound to the contents of each go.
*/

export function goOn<T>( bindings: [PerhapsM<unknown>, () => Perhaps<unknown>][], finalExpr: () => T): T {
  for(const [meta, lazy] of bindings) {
    const val = lazy();
    if (val instanceof go) {
      meta.value = (val as go<unknown>).result;
    } else {
      // Propagate a well-formed error if computation returned a stop; otherwise guard against unexpected values
      if (val instanceof stop) {
        // Message has a custom toString; Location should stringify meaningfully as well
        throw new Error(`Error: ${val.message.toString()} at ${val.where}`);
      }
      throw new Error(`Internal error: expected go/stop, got ${typeof val}`);
    }
  }
  return finalExpr();
}

/*
  ### Closures ### 

  There are two kinds of closures: first-order closures and
  higher-order closures. They are used for different purposes in
  Pie. It would be possible to have only one representation, but they
  are good for different things, so both are included. See
  val-of-closure in normalize.rkt for how to find the value of a
  closure, given the value for its free variable.
*/


export abstract class Closure { 

  constructor() { }
  /*
    General-purpose helpers
   
    Given a value for a closure's free variable, find the value. This
    cannot be used for DELAY-CLOS, because DELAY-CLOS's laziness
    closures do not have free variables, but are instead just delayed
    computations.
  */
  public abstract valOfClosure(v: Value): Value;

  public abstract prettyPrint(): string;

}

/*
  First-order closures, which are a pair of an environment an an
  expression whose free variables are given values by the
  environment, are used for most closures in Pie. They are easier to
  debug, because their contents are visible rather than being part of
  a compiled Racket function. On the other hand, they are more
  difficult to construct out of values, because it would be necessary
  to first read the values back into Core Pie syntax.
*/

export class FirstOrderClosure extends Closure {
  constructor(
    public env: Environment,
    public varName: string,
    public expr: Core
  ) { super() }

  public valOfClosure(v: Value): Value {
    return this.expr.valOf(extendEnvironment(this.env, this.varName, v));
  }

  public prettyPrint(): string {
    return `(CLOS ${this.varName} ${this.expr.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }
  
}

/*
  Higher-order closures re-used Racket's built-in notion of
  closure. They are more convenient when constructing closures from
  existing values, which happens both during type checking, where
  these values are used for things like the type of a step, and
  during evaluation, where they are used as type annotations on THE
  and NEU.
*/

export class HigherOrderClosure extends Closure {
  constructor(
    public proc: (value: Value) => Value
  ) { super() };

  public valOfClosure(v: Value): Value {
    return this.proc(v);
  }

  public prettyPrint(): string {
    return this.proc.toString();
  }

  public toString(): string {
    return this.prettyPrint();
  }

}


/*
  ## Recognizing variable names ##

  This macro causes a name to be defined both for Racket macros and
  for use in ordinary Racket programs. In Racket, these are
  separated.

  Variable name recognition is needed in Racket macros in order to
  parse Pie into the Src type, and it is needed in ordinary programs
  in order to implement the type checker.

  Here the codes are largely removed since the macro is not needed in TS.
*/

/*
  The type of var-name? guarantees that the implementation will
  always accept symbols that are not Pie keywords, and never accept
  those that are.
*/

export function isVarName(name: string): boolean {
  return !isPieKeywords(name) && isNaN(Number(name));
}

/*
  ### Finding fresh names ###

  Find a fresh name, using none of those described in a context.

  This is the implementation of the Γ ⊢ fresh ↝ x form of
  judgment. Unlike the rules in the appendix to The Little Typer,
  this implementation also accepts a name suggestion so that the code
  produced by elaboration has names that are as similar as possible
  to those written by the user.
*/

/*
  Find the names that are described in a context, so they can be
  avoided.
*/
function namesInContext(ctx: Context): string[] {
  return Array.from(ctx.keys());
}

export function fresh(ctx: Context, name: string): string {
  return freshen(namesInContext(ctx), name);
}

/*
  Find a fresh name, using none of those described in a context nor
  occurring in an expression. This is used when constructing a fresh
  binding to avoid capturing a free variable that would otherwise be
  an error because it points at the context.
*/

export function freshBinder(ctx: Context, src: Source, name: string): string {
  return freshen(namesInContext(ctx).concat(src.findNames()), name);
}

export function occurringBinderNames(binder: TypedBinder): string[] {
  return [binder.binder.varName].concat(binder.type.findNames());
}

/*
  ## Extract variable names from Values ##

  Used to extract constructor argument names from the constructor's return type.
  For example, given return type (Less-Than () ((add1 j) (add1 k))),
  this extracts ["j", "k"] by traversing the value structure.
*/

export function extractVarNamesFromValue(val: Value): string[] {
  const names: string[] = [];
  collectVarNames(val, names);
  return names;
}

function collectVarNames(val: Value, names: string[]): void {
  // Handle Delay specially - don't force it, traverse its closure
  if (val instanceof V.Delay) {
    const boxContent = val.val.get();
    if (boxContent instanceof V.DelayClosure) {
      // Traverse the Core expression in the closure to find VarNames
      collectVarNamesFromCore(boxContent.expr, names);
      return;
    } else {
      // Already evaluated - proceed with the value
      val = boxContent as Value;
    }
  }

  const valNow = val.now();

  // Variable reference - add the name
  if (valNow instanceof V.Neutral && valNow.neutral instanceof N.Variable) {
    if (!names.includes(valNow.neutral.name)) {
      names.push(valNow.neutral.name);
    }
  }
  // Add1 - recurse into the smaller value
  else if (valNow instanceof V.Add1) {
    collectVarNames(valNow.smaller, names);
  }
  // Inductive type constructor - recurse into parameters and indices
  else if (valNow instanceof V.InductiveTypeConstructor) {
    valNow.parameters.forEach(p => collectVarNames(p, names));
    valNow.indices.forEach(i => collectVarNames(i, names));
  }
  // Add other composite value types as needed
  // For now, these cover the common cases for indexed constructors
}

// Helper to extract VarNames from Core expressions (for Delay closures)
function collectVarNamesFromCore(core: C.Core, names: string[]): void {
  if (core instanceof C.VarName) {
    if (!names.includes(core.name)) {
      names.push(core.name);
    }
  } else if (core instanceof C.Add1) {
    collectVarNamesFromCore(core.n, names);
  } else if (core instanceof C.InductiveTypeConstructor) {
    core.parameters.forEach(p => collectVarNamesFromCore(p, names));
    core.indices.forEach(i => collectVarNamesFromCore(i, names));
  }
  // Add other composite Core types as needed
}
</file>

<file path=".gitignore">
*.css
!web/*.css
web/*-bundle.js
web/*-bundle.js.map
web/lsp/*-bundle.js
web/lsp/*-bundle.js.map
.DS_Store
*.cjs
*~
*#
.travis.yml
COPYING
yarn.lock
package-lock.json

# Environment variables (contains API keys)
.env
.env.local
/src/**/*.js
/src/**/*.js.map
/src/**/*.d.ts
/src/**/*.d.ts.map
*.vsix
out

compiled
/doc
node_modules
/conductor
/.vscode/
dist
dist-*
</file>

<file path="src/pie_interpreter/parser/parser.ts">
import * as S from "../types/source";

import { SchemeLexer } from "../../scheme_parser/transpiler/lexer/scheme-lexer";
import { SchemeParser } from "../../scheme_parser/transpiler/parser/scheme-parser";

import {
  Extended, Atomic, Expression
} from '../../scheme_parser/transpiler/types/nodes/scheme-node-types';
import { Location, Syntax } from "../utils/locations";
import { Location as Loc } from '../../scheme_parser/transpiler/types/location';
import { isVarName, SiteBinder, TypedBinder } from "../types/utils";
import { Tactic } from "../tactics/tactics";
import { DefineDatatypeSource, GeneralConstructor } from "../typechecker/definedatatype";
import * as Maker from "./makers"

type Element = Extended.List | Atomic.Symbol | Atomic.NumericLiteral | Atomic.Nil;

// ### Helper functions

export function syntaxToLocation(syntax: Syntax): Location {
  return new Location(
    syntax,
    true,
  );
}

function syntaxToSiteBinder(syntax: Syntax): SiteBinder {
  return new SiteBinder(
    syntaxToLocation(syntax),
    syntax.source
  )
}

function getValue(element: Element): string {
  if (element instanceof Atomic.Symbol) {
    return element.value;
  } else if (element instanceof Atomic.NumericLiteral) {
    return element.value;
  } else if (element instanceof Extended.List) {
    return getValue(element.elements[0] as Element);
  } else if (element instanceof Atomic.Nil) {
    // Empty list - return empty string or some placeholder
    return "()";
  } else {
    const elem = element as any;
    throw new Error(`Expected a Element, but got: ${JSON.stringify(elem)} (type: ${typeof elem}, constructor: ${elem?.constructor?.name})`);
  }
}

function locationToSyntax(source: string, location: Loc): Syntax {
  return new Syntax(
    location.start,
    location.end,
    source,
  );
}

function elementToSyntax(element: Element, location: Loc): Syntax {
  return locationToSyntax(getValue(element), location);
}

// ### Parser
// The parser class is responsible for parsing the AST generated by the SchemeParser
export function schemeParse(stx: string): Extended.List[] {
  const lexer = new SchemeLexer(stx);
  const parser = new SchemeParser('', lexer.scanTokens());
  const ast: Extended.List[] = parser.parse() as Extended.List[];
  return ast;
}

export class Parser {
  public static parsePie(stx: string): S.Source {
    return Parser.parseElements(schemeParse(stx)[0]);
  }

  public static parseElements(element: Element): S.Source {
    const parsee = getValue(element);
    if (parsee === 'U') {
      return Maker.makeU(locationToSyntax('U', element.location));
    } else if (parsee === 'the') {
      const elements = (element as Extended.List).elements;
      const loc = element.location;
      return Maker.makeThe(
        locationToSyntax('the', loc),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'Nat') {
      return Maker.makeNat(locationToSyntax('Nat', element.location));
    } else if (parsee === 'zero') {
      return Maker.makeZero(locationToSyntax('zero', element.location));
    } else if (parsee === 'add1') {
      return Maker.makeAdd1(
        locationToSyntax('add1', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === '->' || parsee === '→') {
      const elements = (element as Extended.List).elements;
      const loc = element.location;
      return Maker.makeArrow(
        locationToSyntax('->', loc),
        [
          this.parseElements(elements[1] as Element),
          this.parseElements(elements[2] as Element),
          elements.slice(3).map((x: Expression) => this.parseElements(x as Element))
        ]
      );
    } else if (parsee === 'lambda' || parsee === 'λ') {
      const elements = (element as Extended.List).elements;
      const loc = element.location;
      const args = elements[1] as Extended.List;
      const body = elements[2] as Element;
      return Maker.makeLambda(
        locationToSyntax('λ', loc),
        args.elements.map(
          (x: Expression) =>
            syntaxToSiteBinder(
              elementToSyntax(x as Element, element.location)
            )
        ),
        this.parseElements(body)
      );
    } else if (parsee === 'Pi' || parsee === 'Π') {
      const elements = (element as Extended.List).elements;
      const args = elements[1] as Extended.List;
      const body = elements[2] as Element;

      // Get first binding pair
      const firstPair = args.elements[0] as Extended.List;
      const x0 = firstPair.elements[0] as Element;
      const A0 = firstPair.elements[1] as Element;

      // Process remaining binding pairs
      const remainingPairs = args.elements.slice(1) as Extended.List[];
      const processedPairs = remainingPairs.map(pair => {
        const x = pair.elements[0] as Element;
        const A = pair.elements[1] as Element;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(x, pair.location)),
          this.parseElements(A)
        );
      });
      return Maker.makePi(
        locationToSyntax('Π', (element as Extended.List).location),
        Maker.makeTypedBinders(
          new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),
            this.parseElements(A0)
          ),
          processedPairs
        ),
        this.parseElements(body)
      );
    } else if (parsee === 'Sigma' || parsee === 'Σ') {
      const elements = (element as Extended.List).elements;
      const args = elements[1] as Extended.List;
      const body = elements[2] as Element;

      // Get first binding pair
      const firstPair = args.elements[0] as Extended.List;
      const x0 = firstPair.elements[0] as Element;
      const A0 = firstPair.elements[1] as Element;

      // Process remaining binding pairs
      const remainingPairs = args.elements.slice(1) as Extended.List[];
      const processedPairs = remainingPairs.map(pair => {
        const x = pair.elements[0] as Element;
        const A = pair.elements[1] as Element;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(x, pair.location)),
          this.parseElements(A)
        );
      });
      return Maker.makeSigma(
        locationToSyntax('Π', (element as Extended.List).location),
        Maker.makeTypedBinders(
          new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),
            this.parseElements(A0)
          ),
          processedPairs
        ),
        this.parseElements(body));
    } else if (parsee === 'Pair') {
      const elements = (element as Extended.List).elements;
      return Maker.makePair(
        locationToSyntax('Pair', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'cons') {
      const elements = (element as Extended.List).elements;
      return Maker.makeCons(
        locationToSyntax('Cons', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'car') {
      return Maker.makeCar(
        locationToSyntax('car', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'cdr') {
      return Maker.makeCdr(
        locationToSyntax('cdr', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'which-Nat') {
      const elements = (element as Extended.List).elements;
      return Maker.makeWhichNat(
        locationToSyntax('which-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'iter-Nat') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIterNat(
        locationToSyntax('iter-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'rec-Nat') {
      const elements = (element as Extended.List).elements;
      return Maker.makeRecNat(
        locationToSyntax('rec-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'ind-Nat') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndNat(
        locationToSyntax('ind-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === 'Atom') {
      return Maker.makeAtom(locationToSyntax('Atom', element.location));
    } else if (parsee === 'quote') {
      return Maker.makeQuote(
        locationToSyntax('Quote', element.location),
        getValue((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'Trivial') {
      return Maker.makeTrivial(locationToSyntax('Trivial', element.location));
    } else if (parsee === 'sole') {
      return Maker.makeSole(locationToSyntax('sole', element.location));
    } else if (parsee === 'List') {
      return Maker.makeList(
        locationToSyntax('List', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'nil') {
      return Maker.makeNil(locationToSyntax('nil', element.location));
    } else if (parsee === '::') {
      const elements = (element as Extended.List).elements;
      return Maker.makeListCons(
        locationToSyntax('::', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'rec-List') {
      const elements = (element as Extended.List).elements;
      return Maker.makeRecList(
        locationToSyntax('rec-List', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'ind-List') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndList(
        locationToSyntax('ind-List', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === '=') {
      const elements = (element as Extended.List).elements;
      return Maker.makeEqual(
        locationToSyntax('=', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'same') {
      return Maker.makeSame(
        locationToSyntax('same', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'replace') {
      const elements = (element as Extended.List).elements;
      return Maker.makeReplace(
        locationToSyntax('replace', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'trans') {
      const elements = (element as Extended.List).elements;
      return Maker.makeTrans(
        locationToSyntax('trans', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'cong') {
      const elements = (element as Extended.List).elements;
      return Maker.makeCong(
        locationToSyntax('cong', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'ind-=') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndEqual(
        locationToSyntax('ind-=', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'symm') {
      return Maker.makeSymm(
        locationToSyntax('symm', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'Vec') {
      const elements = (element as Extended.List).elements;
      return Maker.makeVec(
        locationToSyntax('Vec', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'vecnil') {
      return Maker.makeVecNil(
        locationToSyntax('vecnil', element.location),
      );
    } else if (parsee === 'vec::') {
      const elements = (element as Extended.List).elements;
      return Maker.makeVecCons(
        locationToSyntax('vec::', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'head') {
      return Maker.makeHead(
        locationToSyntax('head', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'tail') {
      return Maker.makeTail(
        locationToSyntax('tail', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'ind-Vec') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndVec(
        locationToSyntax('ind-Vec', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
        this.parseElements(elements[5] as Element),
      );
    } else if (parsee === 'Either') {
      const elements = (element as Extended.List).elements;
      return Maker.makeEither(
        locationToSyntax('Either', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'left') {
      return Maker.makeLeft(
        locationToSyntax('left', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    }
    else if (parsee === 'right') {
      return Maker.makeRight(
        locationToSyntax('right', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'ind-Either') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndEither(
        locationToSyntax('ind-Either', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === 'Absurd') {
      return Maker.makeAbsurd(
        locationToSyntax('Absurd', element.location),
      );
    } else if (parsee === 'ind-Absurd') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndAbsurd(
        locationToSyntax('ind-Absurd', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'TODO') {
      return Maker.makeTODO(locationToSyntax('TODO', element.location));
    } else if (parsee.startsWith('ind-') && element instanceof Extended.List && element.elements[0] instanceof Atomic.Symbol) {
      // Eliminator application: (ind-TypeName target motive methods...)
      // Only match if first element is directly a symbol (not a nested list)
      const typeName = parsee.substring(4); // Remove 'ind-' prefix
      const elements = (element as Extended.List).elements;

      if (elements.length < 3) {
        throw new Error(`Eliminator ${parsee} requires at least target and motive`);
      }

      const target = this.parseElements(elements[1] as Element);
      const motive = this.parseElements(elements[2] as Element);
      const methods = elements.slice(3).map(x => this.parseElements(x as Element));

      return Maker.makeEliminatorApplication(
        locationToSyntax(parsee, element.location),
        typeName,
        target,
        motive,
        methods
      );
    } else if (element instanceof Extended.List && (element as Extended.List).elements.length >= 3) {
      const elements = (element as Extended.List).elements;
      const firstElem = elements[0];

      // Check if this is a GeneralTypeConstructor without prefix
      // (used in constructor return types OR in user code): (TypeName (params) (indices))
      // We require type names to start with a capital letter
      if (firstElem instanceof Atomic.Symbol) {
        const name = firstElem.value;
        // If starts with capital letter and has exactly 3 elements, might be type constructor
        if (name && name[0] === name[0].toUpperCase() && name[0] !== name[0].toLowerCase() && elements.length === 3) {
          const secondElem = elements[1];
          const thirdElem = elements[2];

          // Check if second and third are lists or nils (param/index lists)
          if ((secondElem instanceof Extended.List || secondElem instanceof Atomic.Nil) &&
              (thirdElem instanceof Extended.List || thirdElem instanceof Atomic.Nil)) {
            // Parse as GeneralTypeConstructor
            let params: S.Source[] = [];
            if (secondElem instanceof Extended.List) {
              params = (secondElem.elements || []).map(p => this.parseElements(p as Element));
            }

            let indices: S.Source[] = [];
            if (thirdElem instanceof Extended.List) {
              indices = (thirdElem.elements || []).map(idx => this.parseElements(idx as Element));
            }

            return Maker.makeGeneralTypeConstructor(
              locationToSyntax(name, element.location),
              name,
              params,
              indices
            );
          }
        }
      }

      // Otherwise, parse as application
      return Maker.makeApp(
        locationToSyntax('App', element.location),
        this.parseElements(elements[0] as Element),
        this.parseElements(elements[1] as Element),
        elements.slice(2).map((x: Expression) => this.parseElements(x as Element)
        )
      );
    } else if (element instanceof Extended.List && (element as Extended.List).elements.length > 1) {
      // For lists with 2+ elements, parse as Application by default
      // The typechecker will disambiguate between function application and constructor application
      const elements = (element as Extended.List).elements;
      return Maker.makeApp(
        locationToSyntax('App', element.location),
        this.parseElements(elements[0] as Element),
        this.parseElements(elements[1] as Element),
        elements.slice(2).map((x: Expression) => this.parseElements(x as Element)
        )
      );
    } else if (element instanceof Extended.List && (element as Extended.List).elements.length === 1) {
      // Single-element lists like (zero-even) - could be zero-argument constructor
      // Parse as ConstructorApplication with empty args
      // The typechecker will validate if it's actually a constructor
      const elements = (element as Extended.List).elements;
      const name = getValue(elements[0] as Element);
      return Maker.makeConstructorApplication(
        locationToSyntax(name, element.location),
        name,
        []
      );
    } else if (isVarName(parsee)) {
      return Maker.makeVarRef(locationToSyntax(parsee, element.location), parsee);
    } else if (!isNaN(Number(parsee))) { // numeric literal
      return Maker.makeNatLiteral(locationToSyntax(parsee, element.location), parsee);
    }
    throw new Error('Unexpected element: ' + element);
  }

  public static parseToTactics(element: Element): Tactic {
    const parsee = getValue(element);
    if (parsee === 'exact') {
      return Maker.makeExact(
        locationToSyntax('exact', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'intro') {
      return Maker.makeIntro(
        locationToSyntax('intro', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value
      );
    } else if (parsee === 'exists') {
      return Maker.makeExists(
        locationToSyntax('exists', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
        ((element as Extended.List).elements[2] as Atomic.Symbol).value
      );
    } else if (parsee === 'elimNat') {
      return Maker.makeElimNat(
        locationToSyntax('elimNat', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value
      );
    } else if (parsee === 'elimList') {
      const listElem = element as Extended.List;
      return Maker.makeElimList(
        locationToSyntax('elimList', element.location),
        (listElem.elements[1] as Atomic.Symbol).value,
        listElem.elements[2] ? this.parseElements(listElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'elimVec') {
      return Maker.makeElimVec(
        locationToSyntax('elimVec', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value,
        this.parseElements((element as Extended.List).elements[2] as Element),
        this.parseElements((element as Extended.List).elements[3] as Element))
    } else if (parsee === 'elimEqual') {
      const equalElem = element as Extended.List;
      return Maker.makeElimEqual(
        locationToSyntax('elimEqual', element.location),
        (equalElem.elements[1] as Atomic.Symbol).value,
        equalElem.elements[2] ? this.parseElements(equalElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'left') {
      return Maker.makeLeftTactic(
        locationToSyntax('left', element.location)
      );
    } else if (parsee === 'right') {
      return Maker.makeRightTactic(
        locationToSyntax('right', element.location)
      );
    } else if (parsee === 'elimEither') {
      const eitherElem = element as Extended.List;
      return Maker.makeElimEither(
        locationToSyntax('elimEither', element.location),
        (eitherElem.elements[1] as Atomic.Symbol).value,
        eitherElem.elements[2] ? this.parseElements(eitherElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'split') {
      return Maker.makeSplit(
        locationToSyntax('split', element.location)
      );
    } else if (parsee === 'elimAbsurd') {
      const absurdElem = element as Extended.List;
      return Maker.makeElimAbsurd(
        locationToSyntax('elimAbsurd', element.location),
        (absurdElem.elements[1] as Atomic.Symbol).value,
        absurdElem.elements[2] ? this.parseElements(absurdElem.elements[2] as Element) : undefined
      );
    }
    throw new Error('Unexpected tactic: ' + element);
  }
}



// ### Helper functions for parsing the AST

export class Claim {
  constructor(
    public location: Location,
    public name: string,
    public type: S.Source
  ) { }
}

export class Definition {
  constructor(
    public location: Location,
    public name: string,
    public expr: S.Source
  ) { }
}

export class SamenessCheck {
  constructor(
    public location: Location,
    public type: S.Source,
    public left: S.Source,
    public right: S.Source
  ) { }
}

export class DefineTactically {
  constructor(
    public location: Location,
    public name: string,
    public tactics: Tactic[]
  ) { }
}



export type Declaration = Claim | Definition | SamenessCheck | DefineTactically | DefineDatatypeSource | S.Source;


export class pieDeclarationParser {
  public static parseDeclaration(ast: Extended.List): Declaration {
    const parsee = getValue(ast);
    if (parsee === 'claim') {
      const elements = (ast as Extended.List).elements;
      return new Claim(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        Parser.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'define') {
      const elements = (ast as Extended.List).elements;
      return new Definition(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        Parser.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'check-same') {
      const elements = (ast as Extended.List).elements;
      return new SamenessCheck(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        Parser.parseElements(elements[1] as Element),
        Parser.parseElements(elements[2] as Element),
        Parser.parseElements(elements[3] as Element)
      );
    } else if (parsee === 'define-tactically') {
      const elements = (ast as Extended.List).elements;
      return new DefineTactically(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        (elements[2] as Extended.List).elements.map((x: Expression) => Parser.parseToTactics(x as Element))
      );
    } else if (parsee === 'data') {
      const elements = (ast as Extended.List).elements;
      const loc = ast.location;

      // elements[0] = 'data' (keyword)
      // elements[1] = type name (e.g., 'Less-Than')
      // elements[2] = parameters list (e.g., () or ((E U)))
      // elements[3] = indices list (e.g., ((j Nat) (k Nat)))
      // elements[4...n-1] = constructor definitions
      // elements[n] = eliminator name (optional, e.g., 'ind-Less-Than')

      const typeName = getValue(elements[1] as Element);
      const paramsRaw = (elements[2] as Extended.List).elements || [];
      const indicesRaw = (elements[3] as Extended.List).elements || [];

      // Parse parameters: ((E U)) -> [TypedBinder(E, U)]
      const parameters = paramsRaw.map(p => {
        const pair = p as Extended.List;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(pair.elements[0] as Element, pair.location)),
          Parser.parseElements(pair.elements[1] as Element)
        );
      });

      // Parse indices: ((j Nat) (k Nat)) -> [TypedBinder(j, Nat), TypedBinder(k, Nat)]
      const indices = indicesRaw.map(idx => {
        const pair = idx as Extended.List;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(pair.elements[0] as Element, pair.location)),
          Parser.parseElements(pair.elements[1] as Element)
        );
      });

      // Find where constructors end (last element might be eliminator name)
      const lastElement = elements[elements.length - 1];
      const hasEliminator = lastElement instanceof Atomic.Symbol;
      const constructorEndIdx = hasEliminator ? elements.length - 1 : elements.length;
      const eliminatorName = hasEliminator ? getValue(lastElement as Element) : undefined;

      // Parse constructors: (constructor-name ((args...)) (ReturnType ...))
      const constructors: GeneralConstructor[] = [];
      for (let i = 4; i < constructorEndIdx; i++) {
        const ctorElement = elements[i] as Extended.List;
        const ctorName = getValue(ctorElement.elements[0] as Element);
        
        // Handle constructor arguments - could be () (Nil) or ((arg1) (arg2)...) (List)
        const ctorArgsElem = ctorElement.elements[1];
        let ctorArgsRaw: Expression[] = [];
        if (ctorArgsElem instanceof Extended.List) {
          ctorArgsRaw = ctorArgsElem.elements || [];
        } else if (ctorArgsElem instanceof Atomic.Nil) {
          ctorArgsRaw = []; // Empty arguments
        }
        
        const ctorReturnType = ctorElement.elements[2] as Element;

        // Parse constructor arguments: ((n Nat)) or ((j Nat) (k Nat) (j<k (Less-Than () (j k))))
        const ctorArgs = ctorArgsRaw.map(arg => {
          const pair = arg as Extended.List;
          const argType = pair.elements[1] as Element;

          // Parse the argument type using standard parsing
          const parsedArgType: S.Source = Parser.parseElements(argType);

          return new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(pair.elements[0] as Element, pair.location)),
            parsedArgType
          );
        });

        // Parse return type: (TypeName (params...) (indices...))
        // Note: Constructor return types do NOT use  prefix
        const returnTypeList = ctorReturnType as Extended.List;
        const returnTypeName = getValue(returnTypeList.elements[0] as Element);

        if (returnTypeList.elements.length < 3) {
          throw new Error(`Constructor return type must specify parameters and indices: (${returnTypeName} (params...) (indices...))`);
        }

        // Parse parameters list
        const returnParamsElem = returnTypeList.elements[1];
        let returnParams: S.Source[] = [];
        if (returnParamsElem instanceof Extended.List) {
          returnParams = (returnParamsElem.elements || []).map(p => Parser.parseElements(p as Element));
        } else if (returnParamsElem instanceof Atomic.Nil) {
          returnParams = []; // Empty list
        }

        // Parse indices list
        const returnIndicesElem = returnTypeList.elements[2];
        let returnIndices: S.Source[] = [];
        if (returnIndicesElem instanceof Extended.List) {
          returnIndices = (returnIndicesElem.elements || []).map(idx => Parser.parseElements(idx as Element));
        } else if (returnIndicesElem instanceof Atomic.Nil) {
          returnIndices = []; // Empty list
        }

        const returnType = Maker.makeGeneralTypeConstructor(
          elementToSyntax(returnTypeList.elements[0] as Element, returnTypeList.location),
          returnTypeName,
          returnParams,
          returnIndices
        );

        constructors.push(
          new GeneralConstructor(
            syntaxToLocation(elementToSyntax(ctorElement.elements[0] as Element, ctorElement.location)),
            ctorName,
            ctorArgs,
            returnType
          )
        );
      }

      return new DefineDatatypeSource(
        syntaxToLocation(elementToSyntax(elements[0] as Element, loc)),
        typeName,
        parameters,
        indices,
        constructors,
        eliminatorName
      );
    } else {
      return Parser.parseElements(ast);
    }
  }
}
</file>

<file path="src/pie_interpreter/tactics/tactics.ts">
import { ProofState, Goal, GoalNode } from './proofstate';
import { Perhaps, go, stop, Message, FirstOrderClosure, HigherOrderClosure } from '../types/utils';
import { Source } from '../types/source';
import { Core } from '../types/core';
import { Value, Pi, Neutral, Nat } from '../types/value';
import { Context, contextToEnvironment, Define, extendContext, Free, valInContext } from '../utils/context';

import { doApp, indVecStepType } from '../evaluator/evaluator';
import { fresh } from '../types/utils';
import { Variable } from '../types/neutral';
import { convert, extendRenaming, Renaming} from '../typechecker/utils';
import { Location } from '../utils/locations';
import * as V from '../types/value';
import * as C from '../types/core';

export abstract class Tactic {
  constructor(public location: Location) { }

  abstract apply(state: ProofState): Perhaps<ProofState>;

  abstract toString(): string;
}

export class IntroTactic extends Tactic {
  constructor(
    public location: Location,
    private varName?: string
  ) {
    super(location);
  }

  getName(): string {
    return "intro";
  }

  toString(): string {
    return `intro ${this.varName || ""}`;
  }

  apply(state: ProofState): Perhaps<ProofState> {

    const currentGoal = state.currentGoal.goal
    const goalType = currentGoal.type;

    if (!(goalType instanceof Pi)) {
      return new stop(state.location,
        new Message([`Cannot introduce a variable for non-function type: ${goalType.prettyPrint()}`]));
    }

    const name = this.varName || goalType.argName || fresh(currentGoal.context, "x");

    const newRenaming = currentGoal.renaming
    if (name !== goalType.argName) {
      extendRenaming(newRenaming, goalType.argName, name)
    }

    const newContext = extendContext(currentGoal.context, name, new Free(goalType.argType))

    const newGoalType = goalType.resultType.valOfClosure(
      new Neutral(goalType.argType, new Variable(name))
    );

    const newGoalNode = new GoalNode(new Goal(state.generateGoalId(), newGoalType, newContext, newRenaming))
    state.addGoal([newGoalNode])

    return new go(state);
  }
}

export class ExactTactic extends Tactic {
  constructor(
    public location: Location,
    private term: Source
  ) {
    super(location);
  }

  toString(): string {
    return `exact ${this.term.prettyPrint()}`;
  }

  apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result;
    const goalType = currentGoal.type

    const result = this.term.check(currentGoal.context, currentGoal.renaming, goalType)

    if (result instanceof stop) {
      return result;
    }

    state.currentGoal.isComplete = true;
    state.currentGoal.completedBy = this.toString();

    state.nextGoal()

    return new go(state);
  }
}

export class ExistsTactic extends Tactic {
  constructor(
    public location: Location,
    public value: Source,
    private varName?: string
  ) {
    super(location);
  }

  toString(): string {
    return `exists ${this.varName || ""}`;
  }

  apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result;
    const goalType = currentGoal.type;

    if (!(goalType instanceof V.Sigma)) {
      return new stop(state.location,
        new Message([`Cannot use exists on non-product type: ${goalType.prettyPrint()}`]));
    }

    const name = this.varName || goalType.carName || fresh(currentGoal.context, "x");

    const newRenaming = currentGoal.renaming
    if (name !== goalType.carName) {
      extendRenaming(newRenaming, goalType.carName, name)
    }

    const result_temp = this.value.check(currentGoal.context, currentGoal.renaming, goalType.carType);

    if (result_temp instanceof stop) {
      return result_temp;
    }

    const result = (result_temp as go<Core>).result.valOf(contextToEnvironment(currentGoal.context));

    const newContext = extendContext(currentGoal.context, name, new Define(goalType.carType, result));


    const newGoalType = goalType.cdrType.valOfClosure(
      result
    );

    const newGoalNode = new GoalNode(new Goal(state.generateGoalId(), newGoalType, newContext, newRenaming))
    state.addGoal([newGoalNode])

    return new go(state);
  }
}

export class EliminateNatTactic extends Tactic {
  constructor(
    public location: Location,
    private target: string,
  ) {
    super(location);
  }

  toString(): string {
    return `ind-nat ${this.target}`;
  }

  apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result;
    const targetType_temp = currentGoal.context.get(this.target);

    if (!targetType_temp) {
      return new stop(state.location, new Message([`target not found in current context: ${this.target}`]));
    }

    let targetType
    if (targetType_temp instanceof Free) {
      targetType = targetType_temp.type.now()
    } else {
      throw new Error(`Expected target to be a free variable`);
    }

    if (!(targetType instanceof Nat)) {
      return new stop(state.location, new Message([`Cannot eliminate non-Nat type: ${targetType.prettyPrint()}`]));
    }

    // Use the same variable name as the target for the motive parameter
    const motiveRst = this.generateNatMotive(currentGoal.context, currentGoal.type, this.target);
      const rst = this.eliminateNat(currentGoal.context, currentGoal.renaming,motiveRst)
      state.addGoal(
        rst.map((type) => {
          const newGoalNode = new GoalNode(
            new Goal(state.generateGoalId(), type, currentGoal.context, currentGoal.renaming)
          );
          return newGoalNode;
        }))
      return new go(state);

  }

  private generateNatMotive(context: Context, goal: Value, targetVar: string): Value {
    // The goal contains references to targetVar as a neutral variable.
    // We need to create a lambda (λ (targetVar) goal) such that when applied to a value v,
    // it produces the goal with targetVar substituted by v.

    // Directly create a Lambda value without read-back round-trip.
    // Read back the goal to Core, then create a FirstOrderClosure.
    const goalCore = goal.readBackType(context);

    // Remove targetVar from context so it becomes a free variable in goalCore
    const contextWithoutTarget = new Map(context);
    contextWithoutTarget.delete(targetVar);
    const env = contextToEnvironment(contextWithoutTarget);

    // Create a Lambda with a FirstOrderClosure that will bind targetVar when applied
    return new V.Lambda(
      targetVar,
      new FirstOrderClosure(env, targetVar, goalCore)
    );
  }

  private eliminateNat(context: Context, r: Renaming, motiveType: Value): Value[] {
    // 1. A base case: (motive zero)
    const baseType = doApp(motiveType, new V.Zero());

    // 2. A step case: (Π (n-1 Nat) (→ (motive n-1) (motive (add1 n-1))))
    const stepType = new V.Pi(
      fresh(context, "n-1"),
      new V.Nat(),
      new HigherOrderClosure((n_minus_1) => {
        return new V.Pi(
          fresh(context, "ih"),
          doApp(motiveType, n_minus_1),
          new HigherOrderClosure((_) =>
            doApp(motiveType, new V.Add1(n_minus_1))
          )
        );
      })
    );

    return [baseType, stepType]
  }
}

export class EliminateListTactic extends Tactic {
  constructor(
    public location: Location,
    private target: string,
    private motive?: Source
  ) {
    super(location);
  }

  toString(): string {
    return this.motive
      ? `ind-list ${this.target} to prove ${this.motive.prettyPrint()}`
      : `ind-list ${this.target}`;
  }

  apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result;

    const targetType_temp = currentGoal.context.get(this.target);

    if (!targetType_temp) {
      return new stop(state.location, new Message([`target not found in current context: ${this.target}`]));
    }

    let targetType
    if (targetType_temp instanceof Free) {
      targetType = targetType_temp.type.now()
    } else {
      throw new Error(`Expected target to be a free variable`);
    }

    // Check that target is actually a List
    if (!(targetType instanceof V.List)) {
      return new stop(state.location, new Message([`Cannot eliminate non-List type: ${targetType.prettyPrint()}`]));
    }

    const E = targetType.entryType

    let motiveType: Value;
    if (this.motive) {
      // User provided a motive
      const motiveRst = this.motive.check(currentGoal.context, currentGoal.renaming,
        new V.Pi(
          'xs',
          new V.List(E),
          new FirstOrderClosure(
            contextToEnvironment(currentGoal.context),
            'xs',
            new C.Universe()
          )
        ))

      if (motiveRst instanceof stop) {
        return motiveRst;
      }
      motiveType = (motiveRst as go<Core>).result.valOf(contextToEnvironment(currentGoal.context));
    } else {
      // Auto-generate motive from goal
      motiveType = this.generateListMotive(currentGoal.context, currentGoal.type, this.target);
    }

    const rst = this.eliminateList(currentGoal.context, currentGoal.renaming, motiveType, E);
    state.addGoal(
      rst.map((type) => {
        const newGoalNode = new GoalNode(
          new Goal(state.generateGoalId(), type, currentGoal.context, currentGoal.renaming)
        );
        return newGoalNode;
      }))
    return new go(state);
  }

  private generateListMotive(context: Context, goal: Value, targetVar: string): Value {
    // Create a lambda (λ (targetVar) goal) for List elimination
    const goalCore = goal.readBackType(context);

    const contextWithoutTarget = new Map(context);
    contextWithoutTarget.delete(targetVar);
    const env = contextToEnvironment(contextWithoutTarget);

    return new V.Lambda(
      targetVar,
      new FirstOrderClosure(env, targetVar, goalCore)
    );
  }

  private eliminateList(context: Context, r: Renaming, motiveType: Value, entryType: Value): Value[] {
    //1. A base case: (motive nil)
    const baseType = doApp(motiveType, new V.Nil());

    //2. A step case: (Π (x E) (Π (xs (V.List E)) (→ (motive xs) (motive (cons x xs)))))
    const stepType = new V.Pi(
      fresh(context, "x"),
      entryType,
      new HigherOrderClosure(
        (x) => new V.Pi(
          fresh(context, "xs"),
          new V.List(entryType),
          new HigherOrderClosure(
            (xs) => new V.Pi(
              fresh(context, "ih"),
              doApp(motiveType, xs),
              new HigherOrderClosure(
                (_) => doApp(motiveType, new V.ListCons(x, xs))
              )
            )
          )
        )
      )
    )
    return [baseType, stepType];
  }
}

export class EliminateVecTactic extends Tactic {
  constructor(
    public location: Location,
    private target: string,
    private motive: Source,
    private length: Source
  ) {
    super(location);
  }

  toString(): string {
    return `ind-list ${this.target} to prove ${this.motive.prettyPrint()}`;
  }

  apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result;

    const targetType_temp = currentGoal.context.get(this.target);

    if (!targetType_temp) {
      return new stop(state.location, new Message([`target not found in current context: ${this.target}`]));
    }

    let targetType
    if (targetType_temp instanceof Free) {
      targetType = targetType_temp.type.now()
    } else {
      throw new Error(`Expected target to be a free variable`);
    }

    // Check that target is actually a List
    if (!(targetType instanceof V.Vec)) {
      return new stop(state.location, new Message([`Cannot eliminate non-Vec type: ${targetType.prettyPrint()}`]));
    }

    const lenout = this.length.check(currentGoal.context, currentGoal.renaming, new V.Nat())

    if (lenout instanceof stop) {
      return lenout;
    }

    const [E, len2v] = [targetType.entryType, targetType.length]
    convert(
      currentGoal.context, this.location, new V.Nat(),
      valInContext(currentGoal.context, (lenout as go<Core>).result),
      len2v
    )
    
    const motiveRst = this.motive.check(currentGoal.context, currentGoal.renaming,
      new V.Pi(
        'k',
        new V.Nat(),
        new HigherOrderClosure(
          (k) => new V.Pi(
            'es',
            new V.Vec(E, k),
            new HigherOrderClosure(
              (_) => new V.Universe()
            )
          )
        )
      ))

    if (motiveRst instanceof stop) {
      return motiveRst;
    } else {
      const motiveType = (motiveRst as go<Core>).result.valOf(contextToEnvironment(currentGoal.context));
      const rst = this.eliminateVec(currentGoal.context, currentGoal.renaming, motiveType, E);
      state.addGoal(
        rst.map((type) => {
          const newGoalNode = new GoalNode(
            new Goal(state.generateGoalId(), type, currentGoal.context, currentGoal.renaming)
          );
          return newGoalNode;
        }))
      return new go(state);
    }
  }

  private eliminateVec(context: Context, r: Renaming, motiveType: Value, entryType: Value): Value[] {
    const baseType = doApp(doApp(motiveType, new V.Zero()), new V.VecNil())
    const stepType = indVecStepType(entryType, motiveType)
    return [baseType, stepType];
  }
}

export class EliminateEqualTactic extends Tactic {
  constructor(
    public location: Location,
    public target: string,
    public motive?: Source
  ) {
    super(location);
  }

  toString(): string {
    return this.motive
      ? `ind-equal ${this.target} with motive ${this.motive.prettyPrint()}`
      : `ind-equal ${this.target}`;
  }

  public apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result;
    const targetType_temp = currentGoal.context.get(this.target);

    if (!targetType_temp) {
      return new stop(state.location, new Message([`target not found in current context: ${this.target}`]));
    }

    let targetType
    if (targetType_temp instanceof Free) {
      targetType = targetType_temp.type.now()
    } else {
      throw new Error(`Expected target to be a free variable`);
    }

    if (!(targetType instanceof V.Equal)) {
      return new stop(state.location, new Message([`Cannot eliminate non-Equal type: ${targetType.prettyPrint()}`]));
    }

    const [Av, fromv, tov] = [targetType.type, targetType.from, targetType.to]

    let motiveType: Value;
    if (this.motive) {
      // User provided a motive
      const motiveRst = this.motive.check(currentGoal.context, currentGoal.renaming,
        new V.Pi(
          'to',
          Av,
          new HigherOrderClosure(
            (to) => new V.Pi(
              'p',
              new V.Equal(Av, fromv, to),
              new HigherOrderClosure(
                (_) => new V.Universe()
              )
            )
          )
        )
      )

      if (motiveRst instanceof stop) {
        return motiveRst;
      }
      motiveType = (motiveRst as go<Core>).result.valOf(contextToEnvironment(currentGoal.context));
    } else {
      // Auto-generate motive from goal
      // For = elimination, the motive doesn't depend on the target variable directly
      // but rather needs to abstract over the 'to' and the equality proof
      // This is too complex for auto-generation, so we require the user to provide it
      return new stop(this.location, new Message([`Motive required for = elimination (too complex for auto-generation)`]));
    }

    const rst = [doApp(doApp(motiveType, fromv), new V.Same(fromv))];
    state.addGoal(
      rst.map((type) => {
        const newGoalNode = new GoalNode(
          new Goal(state.generateGoalId(), type, currentGoal.context, currentGoal.renaming)
          );
          return newGoalNode;
        }))
      return new go(state);
  }
}

export class LeftTactic extends Tactic {
  constructor(
    public location: Location,
  ) {
    super(location);
  }

  toString(): string {
    return `left`;
  }

  public apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result;
    if (!(currentGoal.type.now() instanceof V.Either)) {
      return new stop(state.location, new Message([`"left" expected goal type to be Either, but got: ${currentGoal.type.prettyPrint()}`]));
    }

    const leftType = (currentGoal.type as V.Either).leftType.now();

    state.addGoal([new GoalNode(
      new Goal(
        state.generateGoalId(),
        leftType,
        currentGoal.context,
        currentGoal.renaming
      )
    )]);
    return new go(state);
  }
}

export class RightTactic extends Tactic {
  constructor(
    public location: Location,
  ) {
    super(location);
  }

  toString(): string {
    return `right`;
  }

  public apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result;
    if (!(currentGoal.type.now() instanceof V.Either)) {
      return new stop(state.location, new Message([`"right" expected goal type to be Either, but got: ${currentGoal.type.prettyPrint()}`]));
    }

    const rightType = (currentGoal.type as V.Either).rightType.now();

    state.addGoal([new GoalNode(
      new Goal(
        state.generateGoalId(),
        rightType,
        currentGoal.context,
        currentGoal.renaming
      )
    )]);
    return new go(state);
  }
}

export class EliminateEitherTactic extends Tactic {
  constructor(
    public location: Location,
    private target: string,
    private motive?: Source
  ) {
    super(location);
  }

  toString(): string {
    return this.motive
      ? `ind-either ${this.target} with motive ${this.motive.prettyPrint()}`
      : `ind-either ${this.target}`;
  }

  public apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result
    const targetType_temp = currentGoal.context.get(this.target)
    if (!targetType_temp) {
      return new stop(state.location, new Message([`target not found in current context: ${this.target}`]));
    }

    let targetType
    if (targetType_temp instanceof Free) {
      targetType = targetType_temp.type.now()
    } else {
      throw new Error(`Expected target to be a free variable`);
    }

    if (!(targetType instanceof V.Either)) {
      return new stop(state.location, new Message([`Cannot eliminate non-Either type: ${targetType.prettyPrint()}`]));
    }

    const [Lv, Rv] = [targetType.leftType, targetType.rightType]

    let motiveType: Value;
    if (this.motive) {
      // User provided a motive
      const motiveRst = this.motive.check(currentGoal.context, currentGoal.renaming,
        new V.Pi(
          'x',
          new V.Either(Lv, Rv),
          new HigherOrderClosure(
            (_) => new V.Universe()
          )
        )
      )

      if (motiveRst instanceof stop) {
        return motiveRst;
      }
      motiveType = (motiveRst as go<Core>).result.valOf(contextToEnvironment(currentGoal.context));
    } else {
      // Auto-generate motive from goal
      motiveType = this.generateEitherMotive(currentGoal.context, currentGoal.type, this.target);
    }

    const leftType = new V.Pi(
      'x',
      Lv,
      new HigherOrderClosure(
        (x) => doApp(motiveType, new V.Left(x))
      )
    )
    const rightType = new V.Pi(
      'x',
      Rv,
      new HigherOrderClosure(
        (x) => doApp(motiveType, new V.Right(x))
      )
    )

    state.addGoal(
      [
        new GoalNode(
          new Goal(
            state.generateGoalId(),
            leftType,
            currentGoal.context,
            currentGoal.renaming
          )
        ),
        new GoalNode(
          new Goal(
            state.generateGoalId(),
            rightType,
            currentGoal.context,
            currentGoal.renaming
          )
        )
        ]);
      return new go(state);
    }

  private generateEitherMotive(context: Context, goal: Value, targetVar: string): Value {
    // Create a lambda (λ (targetVar) goal) for Either elimination
    const goalCore = goal.readBackType(context);

    const contextWithoutTarget = new Map(context);
    contextWithoutTarget.delete(targetVar);
    const env = contextToEnvironment(contextWithoutTarget);

    return new V.Lambda(
      targetVar,
      new FirstOrderClosure(env, targetVar, goalCore)
    );
  }
}

export class SpiltTactic extends Tactic {
  constructor(
    location: Location
  ) {
    super(location);
  } 

  toString(): string {
    return `split`;
  }

  public apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state. getCurrentGoal() as go<Goal>).result

    if (!(currentGoal.type.now() instanceof V.Sigma)) {
      return new stop(state.location, new Message([`"split" expected goal type to be Sigma, but got: ${currentGoal.type.prettyPrint()}`]));
    }

    const pairType = currentGoal.type.now() as V.Sigma;
    const carType = pairType.carType.now();
    const cdrType = pairType.cdrType.valOfClosure(
      pairType
    );

    state.addGoal(
      [
        new GoalNode(
          new Goal(
            state.generateGoalId(),
            carType,
            currentGoal.context,
            currentGoal.renaming
          )
        ),
        new GoalNode(
          new Goal(
            state.generateGoalId(),
            cdrType,
            currentGoal.context,
            currentGoal.renaming
          )
        )
      ]
    )
    return new go(state);
  }
}

export class EliminateAbsurdTactic extends Tactic {
  constructor(
    public location: Location,
    private target: string,
    private motive?: Source
  ) {
    super(location);
  }

  toString(): string {
    return this.motive
      ? `ind-absurd ${this.target} with motive ${this.motive.prettyPrint()}`
      : `ind-absurd ${this.target}`;
  }

  apply(state: ProofState): Perhaps<ProofState> {
    const currentGoal = (state.getCurrentGoal() as go<Goal>).result;

    const targetType_temp = currentGoal.context.get(this.target);

    if (!targetType_temp) {
      return new stop(state.location, new Message([`target not found in current context: ${this.target}`]));
    }

    let targetType: Value;
    if (targetType_temp instanceof Free) {
      targetType = targetType_temp.type.now();
    } else {
      throw new Error(`Expected target to be a free variable`);
    }

    if (!(targetType instanceof V.Absurd)) {
      return new stop(state.location, new Message([`Cannot eliminate non-Absurd type: ${targetType.prettyPrint()}`]));
    }

    if (this.motive) {
      // User provided a motive, check it
      const motiveRst = this.motive.check(
        currentGoal.context,
        currentGoal.renaming,
        new V.Universe()
      );

      if (motiveRst instanceof stop) {
        return motiveRst;
      }
    }
    // For Absurd elimination, the motive is irrelevant since we can derive anything
    // Just mark the goal as complete
    state.currentGoal.isComplete = true;
    state.currentGoal.completedBy = this.toString();
    state.nextGoal()

    return new go(state);
  }
}
</file>

<file path="src/pie_interpreter/evaluator/evaluator.ts">
import * as V from "../types/value";
import * as N from "../types/neutral";
import { HigherOrderClosure } from '../types/utils';
import { natEqual } from './utils';

//TODO: add else cases and throw errors

/*
  ### Evaluator ###

  Functions whose names begin with "do-" are helpers that implement
  the corresponding eliminator.
*/

/**
 * 
 * @param operator 
 * @param operand 
 * @returns result of applying operator to operand
 */
export function doApp(operator: V.Value, operand: V.Value): V.Value {
  const operatorNow = operator.now();
  if (operatorNow instanceof V.Lambda) {
    return operatorNow.body.valOfClosure(operand);
  } else if (operatorNow instanceof V.Neutral) {
    const typeNow = operatorNow.type.now();
    if (typeNow instanceof V.Pi) {
      return new V.Neutral(
        typeNow.resultType.valOfClosure(operand),
        new N.Application(
          operatorNow.neutral,
          new N.Norm(typeNow.argType, operand)
        )
      );
    }
  }
  throw new Error(`doApp: invalid input ${[operatorNow, operand.now()]}`);
}

/**
 * 
 * @param target 
 * @param baseType 
 * @param base 
 * @param step 
 * @returns result of applying whichNat eliminator
 */
export function doWhichNat(target: V.Value, baseType: V.Value, base: V.Value, step: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Zero) {
    return base;
  } else if (targetNow instanceof V.Add1) {
    return doApp(step, targetNow.smaller);
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Nat) {
      return new V.Neutral(
        baseType,
        new N.WhichNat(
          targetNow.neutral,
          new N.Norm(baseType, base),
          new N.Norm(
            new V.Pi(
              "n",
              new V.Nat(),
              new HigherOrderClosure((_) => baseType)),
            step)
        )
      );
    }
  }
  throw new Error(`invalid input for whichNat ${[target, baseType, base, step]}`);
}

export function doIterNat(target: V.Value, baseType: V.Value, base: V.Value, step: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Zero) {
    return base;
  } else if (targetNow instanceof V.Add1) {
    return doApp(
      step,
      doIterNat(targetNow.smaller, baseType, base, step)
    );
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Nat) {
      return new V.Neutral(baseType, new N.IterNat(
        targetNow.neutral,
        new N.Norm(baseType, base),
        new N.Norm(
          new V.Pi(
            "n",
            new V.Nat(),
            new HigherOrderClosure((_) => baseType)),
          step)
      )
      );
    }
  }
  throw new Error(`invalid input for iterNat ${[target, baseType, base, step]}`);
}

export function doRecNat(target: V.Value, baseType: V.Value, base: V.Value, step: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Zero) {
    return base;
  } else if (targetNow instanceof V.Add1) {
    return doApp(
      doApp(step, targetNow.smaller),
      doRecNat(targetNow.smaller, baseType, base, step),
    );
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Nat) {
      return new V.Neutral(
        baseType,
        new N.RecNat(
          targetNow.neutral,
          new N.Norm(baseType, base),
          new N.Norm(
            new V.Pi(
              "n-1",
              new V.Nat(),
              new HigherOrderClosure(
                (_) => new V.Pi(
                  "ih",
                  baseType,
                  new HigherOrderClosure(
                    (_) => baseType
                  )
                )
              )
            ),
            step
          )
        )
      );
    }
  }
  throw new Error(`invalid input for recNat ${[target, baseType, base, step]}`);

}

export function doIndNat(target: V.Value, motive: V.Value, base: V.Value, step: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Zero) {
    return base;
  } else if (targetNow instanceof V.Add1) {
    return doApp(
      doApp(step, targetNow.smaller),
      doIndNat(targetNow.smaller, motive, base, step)
    );
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Nat) {
      return new V.Neutral(
        doApp(motive, target),
        new N.IndNat(
          targetNow.neutral,
          new N.Norm(new V.Pi(
            "x",
            new V.Nat(),
            new HigherOrderClosure((_) => new V.Universe())
          ), motive),
          new N.Norm(doApp(motive, new V.Zero()), base),
          new N.Norm(
            new V.Pi(
              "n-1",
              new V.Nat(),
              new HigherOrderClosure(
                (n_minus_1) =>
                  new V.Pi(
                    "ih",
                    doApp(motive, n_minus_1),
                    new HigherOrderClosure(
                      (_) => doApp(motive, new V.Add1(n_minus_1))
                    )
                  )
              )
            ), step
          )
        )
      );
    }
  }
  throw new Error(`invalid input for indNat ${[target, motive, base, step]}`);

}


export function doCar(pair: V.Value): V.Value {
  const pairNow: V.Value = pair.now();
  if (pairNow instanceof V.Cons) {
    return pairNow.car;
  } else if (pairNow instanceof V.Neutral) {
    const pairType = pairNow.type.now();
    if (pairType instanceof V.Sigma) {
      const sigma = pairType;
      const neutral = pairNow.neutral;
      return new V.Neutral(sigma.carType, new N.Car(neutral));
    }
  }
  throw new Error(`invalid input for car ${pair}`);

}


export function doCdr(pair: V.Value): V.Value {
  const pairNow: V.Value = pair.now();
  if (pairNow instanceof V.Cons) {
    return pairNow.cdr;
  } else if (pairNow instanceof V.Neutral) {
    const pairType = pairNow.type.now();
    if (pairType instanceof V.Sigma) {
      const sigma = pairType;
      const neutral = pairNow.neutral;
      return new V.Neutral(
        sigma.cdrType.valOfClosure(doCar(pair)),
        new N.Cdr(neutral)
      );
    }

  }
  throw new Error(`invalid input for cdr ${pair}`);

}


export function doIndList(target: V.Value, motive: V.Value, base: V.Value, step: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Nil) {
    return base;
  } else if (targetNow instanceof V.ListCons) {
    return doApp(
      doApp(
        doApp(
          step,
          targetNow.head
        ),
        targetNow.tail
      ),
      doIndList(targetNow.tail, motive, base, step)
    );
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.List) {
      const entryType = typeNow.entryType;
      const neutral = targetNow.neutral;
      const motiveType = new V.Pi(
        "xs",
        new V.List(entryType),
        new HigherOrderClosure((_) => new V.Universe())
      );
      return new V.Neutral(
        doApp(motive, target),
        new N.IndList(
          neutral,
          new N.Norm(motiveType, motive),
          new N.Norm(doApp(motive, new V.Nil()), base),
          new N.Norm(
            new V.Pi(
              "h",
              entryType,
              new HigherOrderClosure((h) =>
                new V.Pi(
                  "t",
                  new V.List(entryType),
                  new HigherOrderClosure((t) =>
                    new V.Pi(
                      "ih",
                      doApp(motive, t),
                      new HigherOrderClosure((_) =>
                        doApp(motive, new V.ListCons(h, t))
                      )
                    )
                  )
                )
              )
            ),
            step
          )
        )
      );
    }
  }
  throw new Error(`invalid input for indList ${[targetNow, motive, base, step]}`);

}

export function doRecList(target: V.Value, baseType: V.Value, base: V.Value, step: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Nil) {
    return base;
  } else if (targetNow instanceof V.ListCons) {
    const head = targetNow.head;
    const tail = targetNow.tail;
    return doApp(
      doApp(
        doApp(step, head),
        tail),
      doRecList(tail, baseType, base, step)
    );
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.List) {
      const entryType = typeNow.entryType;
      const neutral = targetNow.neutral;
      return new V.Neutral(
        baseType,
        new N.RecList(
          neutral,
          new N.Norm(baseType, base),
          new N.Norm(
            new V.Pi(
              "h",
              entryType,
              new HigherOrderClosure((_) =>
                new V.Pi(
                  "t",
                  new V.List(entryType),
                  new HigherOrderClosure((_) =>
                    new V.Pi(
                      "ih",
                      baseType,
                      new HigherOrderClosure((_) =>
                        baseType,
                      )
                    )
                  )
                )
              )
            ),
            step
          ),
        )
      );
    }
  }
  throw new Error(`invalid input for recList ${[targetNow, baseType, base, step]}`);

}


export function doIndAbsurd(target: V.Value, motive: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Absurd) {
      return new V.Neutral(
        motive,
        new N.IndAbsurd(
          targetNow.neutral,
          new N.Norm(new V.Universe(), motive)
        )
      );
    }
  }
  throw new Error(`invalid input for indAbsurd ${[target, motive]}`);
}


export function doReplace(target: V.Value, motive: V.Value, base: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Same) {
    return base;
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Equal) {
      const neutral = targetNow.neutral;
      const eqType = typeNow.type;
      const from = typeNow.from;
      const to = typeNow.to;
      return new V.Neutral(
        doApp(motive, to),
        new N.Replace(
          neutral,
          new N.Norm(
            new V.Pi(
              "x",
              eqType,
              new HigherOrderClosure(
                (_) => new V.Universe()
              )
            ),
            motive
          ),
          new N.Norm(doApp(motive, from), base)
        )
      );
    }
  }
  throw new Error(`invalid input for replace ${[target, motive, base]}`);

}


export function doTrans(target1: V.Value, target2: V.Value): V.Value {
  const target1Now = target1.now();
  const target2Now = target2.now();
  if (target1Now instanceof V.Same && target2Now instanceof V.Same) {
    return new V.Same(target1Now.value);
  } else if (target1Now instanceof V.Same && target2Now instanceof V.Neutral) {
    const type2Now = target2Now.type.now();
    if (type2Now instanceof V.Equal) {
      const from = target1Now.value;
      const to = type2Now.to;
      const eqType = type2Now.type;
      const neutral2 = target2Now.neutral;
      return new V.Neutral(
        new V.Equal(eqType, from, to),
        new N.Trans2(
          new N.Norm(
            new V.Equal(eqType, from, from),
            new V.Same(from)
          ),
          neutral2
        )
      )
    }
  } else if (target1Now instanceof V.Neutral && target2Now instanceof V.Same) {
    const type1Now = target1Now.type.now();
    if (type1Now instanceof V.Equal) {
      const from = type1Now.from;
      const to = target2Now.value;
      const eqType = type1Now.type;
      const neutral1 = target1Now.neutral;
      return new V.Neutral(
        new V.Equal(eqType, from, to),
        new N.Trans1(
          neutral1,
          new N.Norm(
            new V.Equal(eqType, to, to),
            new V.Same(to)
          )
        )
      );
    }
  } else if (
    target1Now instanceof V.Neutral && target2Now instanceof V.Neutral) {
    const type1Now = target1Now.type.now();
    const type2Now = target2Now.type.now();
    if (type1Now instanceof V.Equal && type2Now instanceof V.Equal) {
      const from = type1Now.from;
      const to = type2Now.to;
      const eqType = type1Now.type;
      const neutral1 = target1Now.neutral;
      const neutral2 = target2Now.neutral;
      return new V.Neutral(
        new V.Equal(eqType, from, to),
        new N.Trans12(neutral1, neutral2)
      );
    }
  }
  throw new Error(`invalid input for do-trans: ${[target1, target2]}`);
}


export function doCong(target: V.Value, base: V.Value, func: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Same) {
    return new V.Same(doApp(func, targetNow.value));
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Equal) {
      const eqType = typeNow.type;
      const from = typeNow.from;
      const to = typeNow.to;
      const neutral = targetNow.neutral;
      return new V.Neutral(
        new V.Equal(
          base,
          doApp(func, from),
          doApp(func, to)
        ),
        new N.Cong(
          neutral,
          new N.Norm(
            new V.Pi(
              "x",
              eqType,
              new HigherOrderClosure((_) => base)
            ),
            func
          )
        )
      );
    }
  }
  throw new Error(`invalid input for cong ${[target, base, func]}`);
}

export function doSymm(target: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Same) {
    return new V.Same(targetNow.value);
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Equal) {
      return new V.Neutral(
        new V.Equal(
          typeNow.type,
          typeNow.to,
          typeNow.from
        ),
        new N.Symm(targetNow.neutral)
      );
    }
  }
  throw new Error(`invalid input for symm ${target}`);
}


export function doIndEqual(target: V.Value, motive: V.Value, base: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Same) {
    return base;
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Equal) {
      const eqType = typeNow.type;
      const from = typeNow.from;
      const to = typeNow.to;
      const neutral = targetNow.neutral;
      return new V.Neutral(
        doApp(doApp(motive, to), target),
        new N.IndEqual(
          neutral,
          new N.Norm(
            new V.Pi(
              "to",
              eqType,
              new HigherOrderClosure(
                (to) => new V.Pi(
                  "p",
                  new V.Equal(eqType, from, to),
                  new HigherOrderClosure(
                    (_) => new V.Universe()
                  )
                )
              )
            ),
            motive
          ),
          new N.Norm(
            doApp(doApp(motive, from), new V.Same(from)),
            base
          )
        )
      );
    }
  }
  throw new Error(`invalid input for indEqual ${[target, motive, base]}`);
}

export function doHead(target: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.VecCons) {
    return targetNow.head;
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Vec) {
      const lengthNow = typeNow.length.now();
      if (lengthNow instanceof V.Add1) {
        return new V.Neutral(
          typeNow.entryType,
          new N.Head(targetNow.neutral)
        );
      }
    }
  }
  throw new Error(`invalid input for head ${target}`);
}


export function doTail(target: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.VecCons) {
    return targetNow.tail;
  } else if (targetNow instanceof V.Neutral &&
    targetNow.type.now() instanceof V.Vec &&
    ((targetNow.type.now() as V.Vec).length).now() instanceof V.Add1) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Vec) {
      const lengthNow = typeNow.length.now();
      if (lengthNow instanceof V.Add1) {
        return new V.Neutral(
          new V.Vec(
            (targetNow.type.now() as V.Vec).entryType,
            ((targetNow.type.now() as V.Vec).length.now() as V.Add1).smaller
          ),
          new N.Tail(targetNow.neutral)
        );
      }
    }
  }
  throw new Error(`invalid input for tail ${target.prettyPrint()}`);
}

export function indVecStepType(Ev: V.Value, mot: V.Value): V.Value {
  return new V.Pi(
    "k",
    new V.Nat(),
    new HigherOrderClosure(
      (k) => new V.Pi(
        "e",
        Ev,
        new HigherOrderClosure(
          (e) => new V.Pi(
            "es",
            new V.Vec(Ev, k),
            new HigherOrderClosure(
              (es) => new V.Pi(
                "ih",
                doApp(doApp(mot, k), es),
                new HigherOrderClosure(
                  (_) =>
                    doApp(
                      doApp(mot, new V.Add1(k)),
                      new V.VecCons(e, es)
                    )
                )
              )
            )
          )
        )
      )
    )
  );
}


export function doIndVec(len: V.Value, vec: V.Value, motive: V.Value, base: V.Value, step: V.Value): V.Value {
  const lenNow = len.now();
  const vecNow = vec.now();
  if (lenNow instanceof V.Zero && vecNow instanceof V.VecNil) {
    return base;
  } else if (lenNow instanceof V.Add1 && vecNow instanceof V.VecCons) {
    return doApp(
      doApp(
        doApp(
          doApp(step, lenNow.smaller),
          vecNow.head
        ),
        doTail(vec)
      ),
      doIndVec(
        lenNow.smaller,
        vecNow.tail,
        motive,
        base,
        step
      )
    );
  } else if (lenNow instanceof V.Neutral && vecNow instanceof V.Neutral
    && lenNow.type.now() instanceof V.Nat && vecNow.type.now() instanceof V.Vec) {
    const entryType = (vecNow.type.now() as V.Vec).entryType;
    return new V.Neutral(
      doApp(doApp(motive, len), vec),
      new N.IndVec12(
        lenNow.neutral,
        vecNow.neutral,
        new N.Norm(
          new V.Pi(
            "k",
            new V.Nat(),
            new HigherOrderClosure(
              (k) => new V.Pi(
                "es",
                new V.Vec(entryType, k),
                new HigherOrderClosure(
                  (_) => new V.Universe()
                )
              )
            )
          ),
          motive
        ),
        new N.Norm(
          doApp(
            doApp(motive, new V.Zero), new V.VecNil()
          ),
          base
        ),
        new N.Norm(
          indVecStepType(
            (vecNow.type.now() as V.Vec).entryType, motive), step)
      )
    );
  } else if (natEqual(lenNow, len) && vecNow instanceof V.Neutral && (vecNow.type.now()) instanceof V.Vec) {
    const entryType = (vecNow.type.now() as V.Vec).entryType;
    return new V.Neutral(
      doApp(doApp(motive, len), vec),
      new N.IndVec2(
        new N.Norm(new V.Nat(), len),
        vecNow.neutral,
        new N.Norm(
          new V.Pi(
            "k",
            new V.Nat(),
            new HigherOrderClosure(
              (k) => new V.Pi(
                "es",
                new V.Vec(entryType, k),
                new HigherOrderClosure(
                  (_) => new V.Universe()
                )
              )
            )
          ),
          motive
        ),
        new N.Norm(
          doApp(
            doApp(motive, new V.Nat()),
            new V.VecNil
          ),
          base),
        new N.Norm(
          indVecStepType(
            entryType, motive
          ),
          step
        ),
      )
    );
  } else {
    throw new Error(`invalid input for indVec ${[len, vec, motive, base, step]}`);
  }
}

export function doIndEither(target: V.Value, motive: V.Value, left: V.Value, right: V.Value): V.Value {
  const targetNow = target.now();
  if (targetNow instanceof V.Left) {
    return doApp(left, targetNow.value);
  } else if (targetNow instanceof V.Right) {
    return doApp(right, targetNow.value);
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.Either) {
      const leftType = typeNow.leftType;
      const rightType = typeNow.rightType;
      const motiveType = new V.Pi(
        "x",
        new V.Either(leftType, rightType),
        new HigherOrderClosure((_) => new V.Universe())
      )
      return new V.Neutral(
        doApp(motive, target),
        new N.IndEither(
          targetNow.neutral,
          new N.Norm(motiveType, motive),
          new N.Norm(
            new V.Pi(
              "x",
              leftType,
              new HigherOrderClosure(
                (x) => doApp(motive, new V.Left(x))
              )
            ),
            left
          ),
          new N.Norm(
            new V.Pi(
              "x",
              rightType,
              new HigherOrderClosure(
                (x) => doApp(motive, new V.Right(x))
              )
            ),
            right
          )
        )
      )
    }
  }
  throw new Error(`invalid input for indEither: ${[target, motive, left, right]}`);
}

export function doEliminator(name: string, target: V.Value, motive: V.Value, methods: V.Value[], methodTypes?: V.Value[], motiveType?: V.Value): V.Value {
  const targetNow = target.now();

  // Check if target is a constructor application of the inductive type
  if (targetNow instanceof V.Constructor) {
    if (targetNow.type != name) {
      throw new Error(`doEliminator: wrong eliminator used. Got constructor of type: ${targetNow.type}; Expected: ${name}`);
    }
    const constructorIndex = targetNow.index;
    if (constructorIndex >= 0 && constructorIndex < methods.length) {
      const method = methods[constructorIndex];
      let result = method;

      // Apply method to constructor arguments
      // Pattern: apply all non-recursive arguments first, then recursive arguments with their inductive hypotheses
      for (let i = 0; i < targetNow.args.length; i++) {
        const arg = targetNow.args[i].now();
        result = doApp(result, arg);
      }

      for (let i = 0; i < targetNow.recursive_args.length; i++) {
        const arg = targetNow.recursive_args[i].now();
        result = doApp(result, arg);
        const recursiveResult = doEliminator(name, arg, motive, methods, methodTypes, motiveType);
        result = doApp(result, recursiveResult);
      }

      return result;
    }
  } else if (targetNow instanceof V.Neutral) {
    const typeNow = targetNow.type.now();
    if (typeNow instanceof V.InductiveTypeConstructor && typeNow.name === name) {
      // Create neutral eliminator application
      // For indexed types, apply motive to indices first, then to target
      let resultType = motive;
      for (const indexValue of typeNow.indices) {
        resultType = doApp(resultType, indexValue);
      }
      resultType = doApp(resultType, target);

      return new V.Neutral(
        resultType,
        new N.GenericEliminator(
          name,
          targetNow.neutral,
          new N.Norm(
            motiveType ? motiveType : new V.Pi(
              "x",
              typeNow,
              new HigherOrderClosure((_) => new V.Universe())
            ),
            motive
          ),
          methods.map((method, i) =>
            new N.Norm(
              methodTypes && methodTypes[i] ? methodTypes[i] : typeNow,  // Use provided method type or fallback
              method
            )
          )
        )
      );
    }
  }

  throw new Error(`doEliminator: invalid input for ${name}: ${[target, motive, methods]}`);
}
</file>

<file path="src/pie_interpreter/main.ts">
import { schemeParse, pieDeclarationParser, Claim, Definition, SamenessCheck, DefineTactically } from './parser/parser'
import { DefineDatatypeSource } from './typechecker/definedatatype';
import { checkSame, represent } from './typechecker/represent';
import { go, stop } from './types/utils';
import { prettyPrintCore } from './unparser/pretty';
import { addClaimToContext, addDefineToContext, addDefineTacticallyToContext, Define, initCtx } from './utils/context';
import { The } from './types/core';
import { readBack } from './evaluator/utils';

export function evaluatePie(str: string): string {
  const astList = schemeParse(str);
  let ctx = initCtx;
  let renaming = new Map<string, string>();
  let output = "";
  for (const ast of astList) {
    const src = pieDeclarationParser.parseDeclaration(ast);
    if (src instanceof Claim) {
      const result = addClaimToContext(ctx, src.name, src.location, src.type);
      if (result instanceof go) {
        ctx = result.result;
      } else if (result instanceof stop) {
        throw new Error("" + result.where + result.message);
      }
    } else if (src instanceof Definition) {
      const result = addDefineToContext(ctx, src.name, src.location, src.expr);
      if (result instanceof go) {
        ctx = result.result;
      } else if (result instanceof stop) {
        throw new Error("" + result.where + result.message);
      }
    } else if (src instanceof SamenessCheck) {
      const result = checkSame(ctx, src.location, src.type, src.left, src.right);
      if (result instanceof go) {
          // check-same verifies equality but does not modify the context
          // -- fallthrough on success!
      } else if (result instanceof stop) {
        throw new Error("" + result.where + result.message);
      }
    } else if (src instanceof DefineDatatypeSource) {
      // Handle datatype definition
      const [newCtx, newRenaming] = src.normalizeConstructor(ctx, renaming);
      ctx = newCtx;
      renaming = newRenaming;
    } else if (src instanceof DefineTactically) {
      const result = addDefineTacticallyToContext(ctx, src.name, src.location, src.tactics);
      if (result instanceof go) {
        ctx = result.result.context;
        output += result.result.message;
      } else if (result instanceof stop) {
        throw new Error("" + result.where + result.message);
      }
    } else {
      const result = represent(ctx, src);
      if (result instanceof go) {
        const core = result.result as The;
        output += `${prettyPrintCore(core.expr)}: ${prettyPrintCore(core.type)}\n`;
      } else if (result instanceof stop) {
        throw new Error(`${result.message} at ${result.where}`);
      }
    }
  }
  for (const [name, binder] of ctx) {
    if (binder instanceof Define) {
      output += name + " : " + prettyPrintCore(binder.type.readBackType(ctx)) + "\n";
      output += name + " = " + prettyPrintCore(readBack(ctx, binder.type, binder.value)) + "\n";
    } else {
      output += name + " : " + prettyPrintCore(binder.type.readBackType(ctx)) + "\n";
    }
  }
  return output;

}
</file>

<file path="src/pie_interpreter/typechecker/synthesizer.ts">
import * as C from "../types/core";
import * as S from "../types/source";
import * as V from "../types/value";

import {
  go, Perhaps, stop, Message, freshBinder, PerhapsM, goOn,
  fresh, FirstOrderClosure, HigherOrderClosure,
  TypedBinder
} from '../types/utils';
import { bindFree, Context, contextToEnvironment, Define, valInContext, varType, getInductiveType, InductiveDatatypeBinder, ConstructorTypeBinder } from '../utils/context';
import { Environment, extendEnvironment } from '../utils/environment';
import { atomOk, convert, extendRenaming, makeApp, PieInfoHook, rename, Renaming, sameType } from "./utils";
import { notForInfo } from "../utils/locations";
import { doApp, doCar, indVecStepType } from "../evaluator/evaluator";
import { readBack } from '../evaluator/utils';
import { Location } from '../utils/locations';


export class synthesizer {

  public static synthNat(ctx: Context, r: Renaming): Perhaps<C.The> {
    return new go(new C.The(
      new C.Universe(),
      new C.Nat()
    ));
  }

  public static synthUniverse(ctx: Context, r: Renaming, location: Location): Perhaps<C.The> {
    return new stop(location,
      new Message(["U is a type, but it does not have a type."])
    );
  }

  public static synthArrow(context: Context, r: Renaming, location: Location, arg1: S.Source, arg2: S.Source, args: S.Source[]): Perhaps<C.The> {
    if (args.length === 0) {
      const z = freshBinder(context, arg2, 'x');
      const Aout = new PerhapsM<C.Core>("Aout");
      const Bout = new PerhapsM<C.Core>('Bout');
      return goOn(
        [
          [Aout, () =>
            arg1.check(context, r, new V.Universe())],
          [Bout, () =>
            arg2.check(
              bindFree(context, z, valInContext(context, Aout.value)),
              r,
              new V.Universe()
            )
          ],
        ],
        (() => {
          return new go<C.The>(
            new C.The(
              new C.Universe(),
              new C.Pi(
                z,
                Aout.value,
                Bout.value
              )))
        })
      );
    } else {
      const [first, ...rest] = args;
      const z = freshBinder(context, makeApp(arg2, first, rest), 'x');
      const Aout = new PerhapsM<C.Core>("Aout");
      const tout = new PerhapsM<C.Core>('tout');
      return goOn(
        [
          [Aout, () => arg1.check(context, r, new V.Universe())],
          [tout, () =>
            new S.Arrow(notForInfo(location), arg2, first, rest)
              .check(
                bindFree(context, z, valInContext(context, Aout.value)),
                r,
                new V.Universe()
              )
          ]
        ],
        () => {
          return new go<C.The>(
            new C.The(
              new C.Universe(),
              new C.Pi(
                z,
                Aout.value,
                tout.value
              )
            )
          )
        })
    }
  }

  public static synthPi(context: Context, r: Renaming, location: Location, binders: TypedBinder[], body: S.Source): Perhaps<C.The> {
    if (binders.length === 1) {
      const [binder, type] = [binders[0].binder, binders[0].type];
      const xhat = fresh(context, binder.varName);
      const xloc = binder.location;
      const Aout = new PerhapsM<C.Core>('Aout');
      const Bout = new PerhapsM<C.Core>('Bout');
      return goOn(
        [
          [Aout, () => type.check(context, r, new V.Universe())],
          [Bout, () => body.check(
            bindFree(context, xhat, valInContext(context, Aout.value)),
            extendRenaming(r, binder.varName, xhat),
            new V.Universe())],
        ],
        () => {
          PieInfoHook(xloc, ['binding-site', Aout.value!]);
          return new go<C.The>(
            new C.The(
              new C.Universe(),
              new C.Pi(
                xhat,
                Aout.value,
                Bout.value
              )
            )
          )
        }
      )
    } else if (binders.length > 1) {
      const [fst, ...rest] = binders;
      const [binder, type] = [fst.binder, fst.type];
      const xloc = binder.location;
      const x = binder.varName;
      const xhat = fresh(context, x);
      const Aout = new PerhapsM<C.Core>('Aout');
      const Bout = new PerhapsM<C.Core>('Bout');
      return goOn(
        [
          [Aout, () => type.check(context, r, new V.Universe())],
          [Bout, () =>
            new S.Pi(notForInfo(location), rest, body)
              .check(
                bindFree(context, xhat, valInContext(context, Aout.value)),
                extendRenaming(r, x, xhat),
                new V.Universe()
              )
          ],
        ],
        () => {
          PieInfoHook(xloc, ['binding-site', Aout.value!]);
          return new go<C.The>(
            new C.The(
              new C.Universe(),
              new C.Pi(
                xhat,
                Aout.value,
                Bout.value
              )
            )
          )
        }
      )
    } else {
      throw new Error('Invalid number of binders in Pi type');
    }
  }

  public static synthZero(context: Context, r: Renaming): Perhaps<C.The> {
    return new go(
      new C.The(
        new C.Nat(),
        new C.Zero()
      )
    );
  }


  public static synthAdd1(context: Context, r: Renaming, base: S.Source): Perhaps<C.The> {
    const nout = new PerhapsM<C.Core>('nout');
    return goOn(
      [[nout, () => base.check(context, r, new V.Nat())]],
      () => new go<C.The>(
        new C.The(
          new C.Nat(),
          new C.Add1(nout.value)
        )
      )
    );
  }

  public static synthWhichNat(context: Context, r: Renaming, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.Core>('tgtout');
    const bout = new PerhapsM<C.The>('bout');
    const sout = new PerhapsM<C.Core>('sout');
    const n_minus_1 = fresh(context, 'n_minus_1');
    return goOn(
      [
        [tgtout, () => target.check(context, r, new V.Nat())],
        [bout, () => base.synth(context, r)],
        [sout, () => step.check(
          context,
          r,
          new V.Pi(
            n_minus_1,
            new V.Nat(),
            new FirstOrderClosure(
              contextToEnvironment(context),
              n_minus_1,
              bout.value.type
            )
          ))
        ],
      ],
      () => new go<C.The>(
        new C.The(
          bout.value.type,
          new C.WhichNat(
            tgtout.value,
            new C.The(
              bout.value.type,
              bout.value.expr),
            sout.value
          )
        )
      )
    );
  }



  public static synthIterNat(context: Context, r: Renaming, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.Core>('tgtout');
    const bout = new PerhapsM<C.The>('bout');
    const sout = new PerhapsM<C.Core>('sout');
    return goOn(
      [
        [tgtout, () => target.check(context, r, new V.Nat())],
        [bout, () => base.synth(context, r)],
        [sout, () => step.check(
          context,
          r,
          (() => {
            const old = fresh(context, 'old');
            return valInContext(
              context,
              new C.Pi(
                old,
                bout.value.type,
                bout.value.type
              ))
          })()
        )],
      ],
      () => new go<C.The>(
        new C.The(
          bout.value.type,
          new C.IterNat(
            tgtout.value,
            new C.The(
              bout.value.type,
              bout.value.expr
            ),
            sout.value
          )
        )
      )
    );
  }


  public static synthRecNat(context: Context, r: Renaming, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.Core>('tgtout');
    const bout = new PerhapsM<C.The>('bout');
    const sout = new PerhapsM<C.Core>('sout');
    return goOn(
      [
        [tgtout, () => target.check(context, r, new V.Nat())],
        [bout, () => base.synth(context, r)],
        [sout, () => step.check(
          context,
          r,
          (() => {
            const n_minus_1 = fresh(context, 'n_minus_1');
            const old = fresh(context, 'old');
            return valInContext(
              context,
              new C.Pi(
                n_minus_1,
                new C.Nat(),
                new C.Pi(
                  old,
                  bout.value.type,
                  bout.value.type
                )
              )
            )
          })()
        )],
      ],
      () => new go<C.The>(
        new C.The(
          bout.value.type,
          new C.RecNat(
            tgtout.value,
            new C.The(
              bout.value.type,
              bout.value.expr
            ),
            sout.value
          )
        )
      )
    );
  }


  public static synthIndNat(context: Context, r: Renaming, target: S.Source, motive: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.Core>('tgtout');
    const motout = new PerhapsM<C.Core>('motout');
    const motval = new PerhapsM<V.Value>('motval');
    const bout = new PerhapsM<C.Core>('bout');
    const sout = new PerhapsM<C.Core>('sout');
    return goOn(
      [
        [tgtout, () => target.check(context, r, new V.Nat())],
        [motout, () => motive.check(context, r,
          new V.Pi(
            'n',
            new V.Nat(),
            new HigherOrderClosure((_) => new V.Universe())
          )
        )],
        [motval, () => new go(
          valInContext(context, motout.value)
        )],
        [bout, () => base.check(
          context,
          r,
          doApp(motval.value, new V.Zero())
        )],
        [sout, () => step.check(
          context,
          r,
          new V.Pi(
            'n-1',
            new V.Nat(),
            new HigherOrderClosure(
              (n_minus_1) =>
                new V.Pi(
                  'x',
                  doApp(motval.value, n_minus_1),
                  new HigherOrderClosure(
                    (_) => doApp(motval.value, new V.Add1(n_minus_1))
                  )
                )
            )
          )
        )],
      ],
      () => new go<C.The>(
        new C.The(
          new C.Application(
            motout.value,
            tgtout.value
          ),
          new C.IndNat(
            tgtout.value,
            motout.value,
            bout.value,
            sout.value
          )
        )
      )
    );
  }

  public static synthAtom(context: Context, r: Renaming): Perhaps<C.The> {
    return new go(
      new C.The(
        new C.Universe(),
        new C.Atom()
      )
    )
  }


  public static synthPair(context: Context, r: Renaming, first: S.Source, second: S.Source): Perhaps<C.The> {
    const a = fresh(context, 'a');
    const Aout = new PerhapsM<C.Core>('Aout');
    const Dout = new PerhapsM<C.Core>('Dout');
    return goOn(
      [
        [Aout, () => first.check(context, r, new V.Universe())],
        [Dout, () =>
          second.check(
            bindFree(context, a, valInContext(context, Aout.value)),
            r,
            new V.Universe()
          )],
      ],
      () => new go<C.The>(
        new C.The(
          new C.Universe(),
          new C.Sigma(
            a,
            Aout.value,
            Dout.value
          )
        )
      )
    );
  }


  public static synthSigma(context: Context, r: Renaming, location: Location, binders: TypedBinder[], body: S.Source): Perhaps<C.The> {
    if (binders.length === 1) {
      const [bd, type] = [binders[0].binder, binders[0].type];
      const xhat = fresh(context, bd.varName);
      const xloc = bd.location;
      const Aout = new PerhapsM<C.Core>('Aout');
      const Dout = new PerhapsM<C.Core>('Dout');
      return goOn(
        [
          [Aout, () => type.check(context, r, new V.Universe())],
          [Dout, () => body.check(
            bindFree(context, xhat, valInContext(context, Aout.value)),
            extendRenaming(r, bd.varName, xhat),
            new V.Universe()
          )],
        ],
        () => {
          PieInfoHook(xloc, ['binding-site', Aout.value!]);
          return new go<C.The>(
            new C.The(
              new C.Universe(),
              new C.Sigma(
                xhat,
                Aout.value,
                Dout.value
              )
            )
          )
        }
      )
    } else if (binders.length > 1) {
      const [fst, ...rest] = binders;
      const [binder, type] = [fst.binder, fst.type];
      const xloc = binder.location;
      const x = binder.varName;
      const xhat = fresh(context, x);
      const Aout = new PerhapsM<C.Core>('Aout');
      const Dout = new PerhapsM<C.Core>('Dout');
      return goOn(
        [
          [Aout, () => type.check(context, r, new V.Universe())],
          [Dout, () =>
            new S.Sigma(
              notForInfo(location),
              rest,
              body
            ).check(
              bindFree(context, xhat, valInContext(context, Aout.value)),
              extendRenaming(r, x, xhat),
              new V.Universe()
            )
          ],
        ],
        () => {
          PieInfoHook(xloc, ['binding-site', Aout.value]);
          return new go<C.The>(
            new C.The(
              new C.Universe(),
              new C.Sigma(
                xhat,
                Aout.value,
                Dout.value
              )
            )
          )
        }
      )
    } else {
      throw new Error('Invalid number of binders in Sigma type');
    }
  }

  public static synthCar(context: Context, r: Renaming, location: Location, pair: S.Source): Perhaps<C.The> {
    const pout = new PerhapsM<C.The>('p_rst');
    return goOn(
      [[pout, () => pair.synth(context, r)]],
      () => {
        const val = valInContext(context, pout.value.type);
        if (val instanceof V.Sigma) {
          return new go(
            new C.The(
              val.carType.readBackType(context),
              new C.Car(
                pout.value.expr,
              )
            )
          )
        } else {
          return new stop(
            location,
            new Message([`car requires a Pair type, but was used as a: ${val}.`])
          );
        }
      }
    )
  }

  public static synthCdr(context: Context, r: Renaming, location: Location, pair: S.Source): Perhaps<C.The> {
    const pout = new PerhapsM<C.The>('pout');
    return goOn(
      [[pout, () => pair.synth(context, r)]],
      () => {
        const val = valInContext(context, pout.value.type);
        if (val instanceof V.Sigma) {
          const [x, A, clos] = [val.carName, val.carType, val.cdrType];
          return new go(
            new C.The(
              clos.valOfClosure(
                doCar(valInContext(context, pout.value.expr))
              ).readBackType(context),
              new C.Cdr(
                pout.value.expr,
              )
            )
          );
        } else {
          return new stop(
            location,
            new Message([`cdr requires a Pair type, but was used as a: ${val}.`])
          );
        }
      }
    )
  }

  public static synthQuote(context: Context, r: Renaming, location: Location, atom: string): Perhaps<C.The> {
    if (atomOk(atom)) {
      return new go(
        new C.The(
          new C.Atom(),
          new C.Quote(atom)
        )
      );
    } else {
      return new stop(
        location,
        new Message([`Invalid atom: ${atom}. Atoms consist of letters and hyphens.`])
      );
    }
  }

  public static synthTrivial(context: Context, r: Renaming): Perhaps<C.The> {
    return new go(
      new C.The(
        new C.Universe(),
        new C.Trivial()
      )
    );
  }

  public static synthSole(context: Context, r: Renaming): Perhaps<C.The> {
    return new go(
      new C.The(
        new C.Trivial(),
        new C.Sole()
      )
    )
  }

  public static synthIndList(context: Context, r: Renaming,
    location: Location, target: S.Source, motive: S.Source, base: S.Source, step: S.Source,): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.The>('tgtout');
    const motout = new PerhapsM<C.Core>('motout');
    const motval = new PerhapsM<V.Value>('motval');
    const bout = new PerhapsM<C.Core>('bout');
    const sout = new PerhapsM<C.Core>('sout');
    return goOn(
      [
        [tgtout, () => target.synth(context, r)],
      ],
      (() => {
        const [tgt_t, tgt_e] = [tgtout.value.type, tgtout.value.expr];
        const type = valInContext(context, tgt_t);
        if (type instanceof V.List) {
          const E = type.entryType;
          return goOn(
            [
              [
                motout,
                () => motive.check(
                  context,
                  r,
                  new V.Pi(
                    'xs',
                    new V.List(E),
                    new FirstOrderClosure(
                      contextToEnvironment(context),
                      'xs',
                      new C.Universe()
                    )
                  )
                )
              ],
              [motval, () => new go(valInContext(context, motout.value))],
              [bout, () => base.check(
                context,
                r,
                doApp(motval.value, new V.Nil())
              )],
              [sout, () => step.check(
                context,
                r,
                new V.Pi(
                  'e',
                  E,
                  new HigherOrderClosure(
                    (e) => new V.Pi(
                      'es',
                      new V.List(E),
                      new HigherOrderClosure(
                        (es) => new V.Pi(
                          'ih',
                          doApp(motval.value, es),
                          new HigherOrderClosure(
                            (_) => doApp(motval.value, new V.ListCons(e, es))
                          )
                        )
                      )
                    )
                  )
                )
              )],
            ],
            () => new go<C.The>(
              new C.The(
                new C.Application(
                  motout.value,
                  tgt_e
                ),
                new C.IndList(
                  tgt_e,
                  motout.value,
                  bout.value,
                  sout.value
                )
              )
            )
          );
        } else {
          return new stop(
            location,
            new Message([`Not a List: ${type.readBackType(context)}.`])
          );
        }
      })
    )
  }


  public static synthRecList(context: Context, r: Renaming,
    location: Location, target: S.Source, base: S.Source, step: S.Source,): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.The>('tgtout');
    return goOn(
      [[tgtout, () => target.synth(context, r)]],
      () => {
        const [tgt_t, tgt_e] = [tgtout.value.type, tgtout.value.expr];
        const type = valInContext(context, tgt_t);
        if (type instanceof V.List) {
          const E = type.entryType;
          const bout = new PerhapsM<C.The>('bout');
          const btval = new PerhapsM<V.Value>('btval');
          const sout = new PerhapsM<C.Core>('sout');
          return goOn(
            [
              [bout, () => base.synth(context, r)],
              [btval, () => new go(valInContext(context, bout.value.type))],
              [sout, () =>
                step.check(
                  context,
                  r,
                  new V.Pi(
                    'e',
                    E,
                    new HigherOrderClosure(
                      (_) => new V.Pi(
                        'es',
                        new V.List(E),
                        new HigherOrderClosure(
                          (_) => new V.Pi(
                            'ih',
                            btval.value,
                            new HigherOrderClosure(
                              (_) => btval.value
                            )
                          )
                        )
                      )
                    )
                  )
                )
              ],
            ],
            () => new go<C.The>(
              new C.The(
                bout.value.type,
                new C.RecList(
                  tgt_e,
                  new C.The(
                    bout.value.type,
                    bout.value.expr
                  ),
                  sout.value
                )
              )
            )
          );
        } else {
          return new stop(
            location,
            new Message([`Not a List: ${type.readBackType(context)}.`])
          );
        }
      }
    )
  }


  public static synthList(context: Context, r: Renaming, e: S.List): Perhaps<C.The> {
    const Eout = new PerhapsM<C.Core>('Eout');
    return goOn(
      [[Eout, () => e.entryType.check(context, r, new V.Universe())]],
      () => new go<C.The>(
        new C.The(
          new C.Universe(),
          new C.List(Eout.value)
        )
      )
    );
  }


  public static synthListCons(context: Context, r: Renaming, x: S.Source, xs: S.Source): Perhaps<C.The> {
    const fstout = new PerhapsM<C.The>('eout');
    const restout = new PerhapsM<C.Core>('esout');
    return goOn(
      [
        [fstout, () => x.synth(context, r)],
        [restout, () =>
          xs.check(
            context,
            r,
            valInContext(context, new C.List(fstout.value.type))
          )
        ],
      ],
      () => new go<C.The>(
        new C.The(
          new C.List(fstout.value.type),
          new C.ListCons(
            fstout.value.expr,
            restout.value
          )
        )
      )
    );
  }

  public static synthAbsurd(context: Context, r: Renaming, e: S.Absurd): Perhaps<C.The> {
    return new go(
      new C.The(
        new C.Universe(),
        new C.Absurd()
      )
    );
  }



  public static synthIndAbsurd(context: Context, r: Renaming, e: S.IndAbsurd): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.Core>('tgtout');
    const motout = new PerhapsM<C.Core>('motout');
    return goOn(
      [
        [tgtout, () => e.target.check(context, r, new V.Absurd())],
        [motout, () => e.motive.check(context, r, new V.Universe())],
      ],
      () => new go<C.The>(
        new C.The(
          motout.value,
          new C.IndAbsurd(
            tgtout.value,
            motout.value
          )
        )
      )
    );
  }



  public static synthEqual(context: Context, r: Renaming, type: S.Source, left: S.Source, right: S.Source): Perhaps<C.The> {
    const Aout = new PerhapsM<C.Core>('Aout');
    const Av = new PerhapsM<V.Value>('Av');
    const from_out = new PerhapsM<C.Core>('from_out');
    const to_out = new PerhapsM<C.Core>('to_out');
    return goOn(
      [
        [Aout, () => type.check(context, r, new V.Universe())],
        [Av, () => new go(valInContext(context, Aout.value))],
        [from_out, () => left.check(context, r, Av.value)],
        [to_out, () => right.check(context, r, Av.value)],
      ],
      () => new go<C.The>(
        new C.The(
          new C.Universe(),
          new C.Equal(
            Aout.value,
            from_out.value,
            to_out.value
          )
        )
      )
    );
  }


  public static synthReplace(context: Context, r: Renaming, location: Location, target: S.Source, motive: S.Source, base: S.Source): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.The>('tgt_rst');
    const motout = new PerhapsM<C.Core>('motout');
    const bout = new PerhapsM<C.Core>('bout');
    return goOn(
      [[tgtout, () => target.synth(context, r)]],
      () => {
        const result = valInContext(context, tgtout.value.type);
        if (result instanceof V.Equal) {
          const [Av, fromv, tov] = [result.type, result.from, result.to];
          return goOn(
            [
              [motout, () =>
                motive.check(
                  context,
                  r,
                  new V.Pi(
                    'x',
                    Av,
                    new HigherOrderClosure(
                      (_) => new V.Universe()
                    )
                  )
                )
              ],
              [bout, () => base.check(
                context,
                r,
                doApp(valInContext(context, motout.value), fromv)
              )],
            ],
            () => new go(
              new C.The(
                (doApp(valInContext(context, motout.value), tov)).readBackType(context),
                new C.Replace(
                  tgtout.value.expr,
                  motout.value,
                  bout.value
                )
              )
            )
          );
        } else {
          return new stop(
            location,
            new Message([`Expected an expression with = type, but the type was: ${tgtout.value.type}.`])
          );
        }
      }
    );
  }

  public static synthTrans(context: Context, r: Renaming, location: Location, left: S.Source, right: S.Source): Perhaps<C.The> {

    const lout = new PerhapsM<C.The>('p1_rst');
    const rout = new PerhapsM<C.The>('p2_rst');
    return goOn(
      [
        [lout, () => left.synth(context, r)],
        [rout, () => right.synth(context, r)],
      ],
      () => {
        const result1 = valInContext(context, lout.value.type);
        const result2 = valInContext(context, rout.value.type);
        if (result1 instanceof V.Equal && result2 instanceof V.Equal) {
          const [Av, fromv, midv] = [result1.type, result1.from, result1.to];
          const [Bv, midv2, tov] = [result2.type, result2.from, result2.to];

          return goOn(
            [
              [new PerhapsM("_"), () => sameType(context, location, Av, Bv)],
              [new PerhapsM("_"), () => convert(context, location, Av, midv, midv2)],
            ],
            () => new go<C.The>(
              new C.The(
                new V.Equal(Av, fromv, tov).readBackType(context),
                new C.Trans(
                  lout.value.expr,
                  rout.value.expr
                )
              )
            )
          );
        } else {
          return new stop(
            location,
            new Message([`Expected =, got ${result1} and ${result2}.`])
          );
        }
      }
    )
  }

  public static synthCong(context: Context, r: Renaming, location: Location, base: S.Source, fun: S.Source): Perhaps<C.The> {

    const bout = new PerhapsM<C.The>('bout');
    const fout = new PerhapsM<C.The>('f_rst');
    return goOn(
      [
        [bout, () => base.synth(context, r)],
        [fout, () => fun.synth(context, r)],
      ],
      () => {
        const result1 = valInContext(context, bout.value.type);
        const result2 = valInContext(context, fout.value.type);
        if (result1 instanceof V.Equal) {
          const [Av, fromv, tov] = [result1.type, result1.from, result1.to];
          if (result2 instanceof V.Pi) {
            const [x, Bv, c] = [result2.argName, result2.argType, result2.resultType];
            const ph = new PerhapsM<any>('ph');
            const Cv = new PerhapsM<V.Value>('Cv');
            const fv = new PerhapsM<V.Value>('fv');
            return goOn(
              [
                [ph, () => sameType(context, location, Av, Bv)],
                [Cv, () => new go(c.valOfClosure(fromv))],
                [fv, () => new go(valInContext(context, fout.value.expr))],
              ],
              () => new go(
                new C.The(
                  new C.Equal(
                    Cv.value.readBackType(context),
                    readBack(context, Cv.value, doApp(fv.value, fromv)),
                    readBack(context, Cv.value, doApp(fv.value, tov))
                  ),
                  new C.Cong(
                    bout.value.expr,
                    Cv.value.readBackType(context),
                    fout.value.expr
                  )
                )
              )
            );
          } else {
            return new stop(
              location,
              new Message([`Expected a function type, got ${result2.readBackType(context)}.`])
            );
          }
        } else {
          return new stop(
            location,
            new Message([`Expected an = type, got ${result1.readBackType(context)}.`])
          );
        }
      }
    )
  }

  public static synthSymm(context: Context, r: Renaming, location: Location, eq: S.Source): Perhaps<C.The> {
    const eout = new PerhapsM<C.The>('eout');
    return goOn(
      [[eout, () => eq.synth(context, r)]],
      () => {
        const result = valInContext(context, eout.value.type);
        if (result instanceof V.Equal) {
          const [Av, fromv, tov] = [result.type, result.from, result.to];
          return new go(
            new C.The(
              (new V.Equal(
                Av,
                tov,
                fromv
              )).readBackType(context),
              new C.Symm(
                eout.value.expr
              )
            )
          );
        } else {
          return new stop(
            location,
            new Message([`Expected an = type, got ${result.readBackType(context)}.`])
          );
        }
      }
    );
  }


  public static synthIndEqual(context: Context, r: Renaming, location: Location, target: S.Source, motive: S.Source, base: S.Source): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.The>('tgtout');
    const motout = new PerhapsM<C.Core>('motout');
    const motv = new PerhapsM<V.Value>('motv');
    const baseout = new PerhapsM<C.Core>('baseout');
    return goOn(
      [[tgtout, () => target.synth(context, r)]],
      () => {
        const result = valInContext(context, tgtout.value.type);
        if (result instanceof V.Equal) {
          const [Av, fromv, tov] = [result.type, result.from, result.to];
          return goOn(
            [
              [motout, () =>
                motive.check(
                  context,
                  r,
                  new V.Pi(
                    'to',
                    Av,
                    new HigherOrderClosure(
                      (to) => new V.Pi(
                        'p',
                        new V.Equal(Av, fromv, to),
                        new HigherOrderClosure(
                          (_) => new V.Universe()
                        )
                      )
                    )
                  )
                )
              ],
              [motv, () => new go(valInContext(context, motout.value))],
              [baseout, () =>
                base.check(
                  context,
                  r,
                  doApp(doApp(motv.value, fromv), new V.Same(fromv))
                )
              ],
            ],
            () => new go<C.The>(
              new C.The(
                doApp(
                  doApp(motv.value, tov),
                  valInContext(context, tgtout.value.expr)
                ).readBackType(context),
                new C.IndEqual(
                  tgtout.value.expr,
                  motout.value,
                  baseout.value
                )
              )
            )
          );
        } else {
          return new stop(
            location,
            new Message([`Expected evidence of equality, got ${result.readBackType(context)}.`])
          );
        }
      }
    );
  }


  public static synthVec(context: Context, r: Renaming, type: S.Source, len: S.Source): Perhaps<C.The> {
    const tout = new PerhapsM<C.Core>('tout');
    const lenout = new PerhapsM<C.Core>('lenout');
    return goOn(
      [
        [tout, () => type.check(context, r, new V.Universe())],
        [lenout, () => len.check(context, r, new V.Nat())],
      ],
      () => new go<C.The>(
        new C.The(
          new C.Universe(),
          new C.Vec(tout.value, lenout.value)
        )
      )
    );
  }


  public static synthHead(context: Context, r: Renaming, location: Location, vec: S.Source): Perhaps<C.The> {
    const vout = new PerhapsM<C.The>('vout');
    return goOn(
      [[vout, () => vec.synth(context, r)]],
      () => {
        const result = valInContext(context, vout.value.type).now();
        if (result instanceof V.Vec) {
          const [T, len] = [result.entryType, result.length];
          const lenNow = len.now();
          if (lenNow instanceof V.Add1) {
            return new go(
              new C.The(
                T.readBackType(context),
                new C.Head(
                  vout.value.expr
                )
              )
            );
          } else {
            return new stop(
              location,
              new Message([`Expected a Vec with add1 at the top of the length, got ${readBack(context, new V.Nat(), len)}.`])
            );
          }
        } else {
          return new stop(
            location,
            new Message([`Expected a Vec, got ${result.readBackType(context)}.`])
          );
        }
      }
    );
  }

  public static synthTail(context: Context, r: Renaming, location: Location, vec: S.Source): Perhaps<C.The> {
    const vout = new PerhapsM<C.The>('vout');
    return goOn(
      [[vout, () => vec.synth(context, r)]],
      () => {
        const result = valInContext(context, vout.value.type).now();
        if (result instanceof V.Vec) {
          const [T, len] = [result.entryType, result.length];
          const lenNow = len.now();
          if (lenNow instanceof V.Add1) {
            const len_minus_1 = lenNow.smaller;
            return new go(
              new C.The(
                new C.Vec(
                  T.readBackType(context),
                  readBack(context, new V.Nat(), len_minus_1)),
                new C.Tail(
                  vout.value.expr
                )
              )
            );
          } else {
            return new stop(
              location,
              new Message([`Expected a Vec with add1 at the top of the length, got ${readBack(context, new V.Nat(), len)}.`])
            );
          }
        } else {
          return new stop(
            location,
            new Message([`Expected a Vec, got ${result.readBackType(context)}.`])
          );
        }
      }
    );
  }

  public static synthIndVec(context: Context, r: Renaming, location: Location,
    length: S.Source, target: S.Source, motive: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {
    const lenout = new PerhapsM<C.Core>('lenout');
    const lenv = new PerhapsM<V.Value>('lenv');
    const vecout = new PerhapsM<C.The>('vecout');
    const motout = new PerhapsM<C.Core>('motout');
    const motval = new PerhapsM<V.Value>('motval');
    const bout = new PerhapsM<C.Core>('bout');
    const sout = new PerhapsM<C.Core>('sout');
    return goOn(
      [
        [lenout, () => length.check(context, r, new V.Nat())],
        [lenv, () => new go(valInContext(context, lenout.value))],
        [vecout, () => target.synth(context, r)],
      ],
      () => {
        const result = valInContext(context, vecout.value.type);
        if (result instanceof V.Vec) {
          const [E, len2v] = [result.entryType, result.length];
          return goOn(
            [
              [new PerhapsM<any>('_'), () => convert(context, location, new V.Nat(), lenv.value, len2v)],
              [motout, () => motive.check(
                context,
                r,
                new V.Pi(
                  'k',
                  new V.Nat(),
                  new HigherOrderClosure(
                    (k) => new V.Pi(
                      'es',
                      new V.Vec(E, k),
                      new HigherOrderClosure(
                        (_) => new V.Universe()
                      )
                    )
                  )
                )
              )],
              [motval, () => new go(valInContext(context, motout.value))],
              [bout, () => base.check(
                context,
                r,
                doApp(doApp(motval.value, new V.Zero()), new V.VecNil())
              )],
              [sout, () => step.check(
                context,
                r,
                indVecStepType(E, motval.value)
              )],
            ],
            () => new go<C.The>(
              new C.The(
                new C.Application(
                  new C.Application(
                    motout.value,
                    lenout.value
                  ),
                  vecout.value.expr
                ),
                new C.IndVec(
                  lenout.value,
                  vecout.value.expr,
                  motout.value,
                  bout.value,
                  sout.value
                )
              )
            )
          );
        } else {
          return new stop(
            location,
            new Message([`Expected a Vec, got ${result.readBackType(context)}.`])
          );
        }
      }
    );
  }

  public static synthEither(context: Context, r: Renaming, left: S.Source, right: S.Source): Perhaps<C.The> {
    const Lout = new PerhapsM<C.Core>('Lout');
    const Rout = new PerhapsM<C.Core>('Rout');
    return goOn(
      [
        [Lout, () => left.check(context, r, new V.Universe())],
        [Rout, () => right.check(context, r, new V.Universe())],
      ],
      () => new go<C.The>(
        new C.The(
          new C.Universe(),
          new C.Either(Lout.value, Rout.value)
        )
      )
    );
  }


  public static synthIndEither(context: Context, r: Renaming, location: Location, target: S.Source,
    motive: S.Source, baseLeft: S.Source, baseRight: S.Source,): Perhaps<C.The> {
    const tgtout = new PerhapsM<C.The>('tgtout');
    const motout = new PerhapsM<C.Core>('motout');
    const motval = new PerhapsM<V.Value>('motval');
    const lout = new PerhapsM<C.Core>('lout');
    const rout = new PerhapsM<C.Core>('rout');
    return goOn(
      [[tgtout, () => target.synth(context, r)]],
      () => {
        const result = valInContext(context, tgtout.value.type);
        if (result instanceof V.Either) {
          const [Lv, Rv] = [result.leftType, result.rightType];
          return goOn(
            [
              [motout, () =>
                motive.check(
                  context,
                  r,
                  new V.Pi(
                    'x',
                    new V.Either(Lv, Rv),
                    new HigherOrderClosure(
                      (_) => new V.Universe()
                    )
                  )
                )
              ],
              [motval, () => new go(valInContext(context, motout.value))],
              [lout, () => baseLeft.check(
                context,
                r,
                new V.Pi(
                  'x',
                  Lv,
                  new HigherOrderClosure(
                    (x) => doApp(motval.value, new V.Left(x))
                  )
                )
              )],
              [rout, () => baseRight.check(
                context,
                r,
                new V.Pi(
                  'x',
                  Rv,
                  new HigherOrderClosure(
                    (x) => doApp(motval.value, new V.Right(x))
                  )
                )
              )],
            ],
            () => new go<C.The>(
              new C.The(
                new C.Application(
                  motout.value,
                  tgtout.value.expr
                ),
                new C.IndEither(
                  tgtout.value.expr,
                  motout.value,
                  lout.value,
                  rout.value
                )
              )
            )
          );
        } else {
          return new stop(
            location,
            new Message([`Expected an Either, but got a ${result.readBackType(context)}.`])
          );
        }
      }
    );
  }

  public static synthThe(context: Context, r: Renaming, type: S.Source, value: S.Source): Perhaps<C.The> {
    const tout = new PerhapsM<C.Core>('t_out');
    const eout = new PerhapsM<C.Core>('e_out');
    return goOn(
      [
        [tout, () => type.isType(context, r)],
        [eout, () => value.check(context, r, valInContext(context, tout.value))],
      ],
      () => new go<C.The>(
        new C.The(
          tout.value,
          eout.value
        )
      )
    );
  }

  public static synthApplication(context: Context, r: Renaming, location: Location, fun: S.Source, arg: S.Source, args: S.Source[]): Perhaps<C.The> {
    // Check if this is actually a constructor application (parsed as Application)
    if (fun instanceof S.Name) {
      const binder = context.get(fun.name);
      if (binder instanceof ConstructorTypeBinder) {
        // This is a constructor application - convert to ConstructorApplication and handle it
        const constructorApp = new S.ConstructorApplication(
          location,
          fun.name,
          [arg, ...args]
        );
        // Constructors need to be checked, not synthesized, so we can't synthesize a type directly
        // Return an error suggesting the user provide type annotation
        return new stop(
          location,
          new Message([`Constructor ${fun.name} requires a type annotation. Use (the Type (${fun.name} ...))`])
        );
      }
    }

    if (args.length === 0) {
      const fout = new PerhapsM<C.The>('fout');
      return goOn(
        [[fout, () => fun.synth(context, r)]],
        () => {
          const result = valInContext(context, fout.value.type);
          if (result instanceof V.Pi) {
            const [_, A, c] = [result.argName, result.argType, result.resultType];
            const argout = new PerhapsM<C.Core>('argout');
            return goOn(
              [[argout, () => arg.check(context, r, A)]],
              () =>
                new go(
                  new C.The(
                    c.valOfClosure(valInContext(context, argout.value)).readBackType(context),
                    new C.Application(
                      fout.value.expr,
                      argout.value
                    )
                  )
                )
            );
          } else {
            return new stop(
              location,
              new Message([`Not a function type: ${result.readBackType(context)}.`])
            );
          }
        }
      );
    } else {
      const appout = new PerhapsM<C.The>('appout');
      return goOn(
        [[appout, () => (
          new S.Application(
            notForInfo(location),
            fun,
            arg,
            args.slice(0, args.length - 1)
          )
        ).synth(context, r)]],
        () => {
          const result = valInContext(context, appout.value.type);
          if (result instanceof V.Pi) {
            const [x, A, c] = [result.argName, result.argType, result.resultType];
            const argout = new PerhapsM<C.Core>('fout');
            return goOn(
              [[argout, () => args[args.length - 1].check(context, r, A)]],
              () => new go(
                new C.The(
                  c.valOfClosure(valInContext(context, argout.value)).readBackType(context),
                  new C.Application(
                    appout.value.expr,
                    argout.value
                  )
                )
              )
            );
          } else {
            return new stop(
              location,
              new Message([`Not a function type: ${result.readBackType(context)}.`])
            );
          }
        }
      );

    }

  }
  /*
  [x
        (cond [(and (symbol? x) (var-name? x))
               (let ((real-x (rename r x)))
                (go-on ((x-tv (var-type Γ (src-loc e) real-x)))
                  (begin (match (assv real-x Γ)
                           [(cons _ (def _ _))
                            (send-pie-info (src-loc e) 'definition)]
                           [_ (void)])
                         (go `(the ,(read-back-type Γ x-tv) ,real-x)))))]
              [(number? x)
               (cond [(zero? x)
                      (go `(the Nat zero))]
                     [(positive? x)
                      (go-on ((n-1-out (check Γ
                                              r
                                              (@ (src-loc e) (sub1 x))
                                              'NAT)))
                        (go `(the Nat (add1 ,n-1-out))))])]
              [else
               (stop (src-loc e)
                     `("Can't determine a type"))])]
  */

  public static synthName(context: Context, r: Renaming, location: Location, name: string): Perhaps<C.The> {
    const real_x = rename(r, name);
    const x_tv = new PerhapsM<V.Value>('x_tv');
    return goOn(
      [[x_tv, () => varType(context, location, real_x)]],
      () => {
        const result = context.get(real_x);
        if (result instanceof Define) {
          PieInfoHook(location, 'definition');
        }
        // If it's an inductive datatype, return the type constructor, not a variable reference
        if (result instanceof InductiveDatatypeBinder) {
          const inductiveType = result.type;
          return new go(
            new C.The(
              new C.Universe(),
              new C.InductiveTypeConstructor(
                inductiveType.name,
                inductiveType.parameterTypes.map(p => p.readBackType(context)),
                inductiveType.indexTypes.map(i => i.readBackType(context))
              )
            )
          );
        }
        return new go(
          new C.The(
            x_tv.value.readBackType(context),
            new C.VarName(real_x)
          )
        )
      }
    );
  }

  public static synthNumber(context: Context, r: Renaming, location: Location, value: number): Perhaps<C.The> {
    if (value === 0) {
      return new go(
        new C.The(
          new C.Nat(),
          new C.Zero()
        )
      );
    } else if (value > 0) {
      const n_minus_1_out = new PerhapsM<C.Core>('n_1_out');
      return goOn(
        [[n_minus_1_out, () => (new S.Number(location, value - 1)).check(context, r, new V.Nat())]],
        () => new go(
          new C.The(
            new C.Nat(),
            new C.Add1(n_minus_1_out.value)
          )
        )
      );
    } else {
      return new stop(
        location,
        new Message([`Expected a positive number, got ${value}.`])
      );
    }
  }

  /**
   * Synthesize eliminator application for user-defined inductive types
   */
  public static synthGeneralEliminator(ctx: Context, r: Renaming, elimApp: S.EliminatorApplication): Perhaps<C.The> {
    // PHASE 1: Look up inductive datatype in context
    const inductiveTypeResult = getInductiveType(ctx, elimApp.location, elimApp.typeName);
    if (inductiveTypeResult instanceof stop) return inductiveTypeResult;

    const inductiveBinder = (inductiveTypeResult as go<InductiveDatatypeBinder>).result;
    const inductiveTypeValue = inductiveBinder.type; // V.InductiveType

    // PHASE 2: Synthesize & Check Target
    const targetSynth = elimApp.target.synth(ctx, r);
    if (targetSynth instanceof stop) return targetSynth;

    const targetThe = (targetSynth as go<C.The>).result;
    const targetTypeValue = valInContext(ctx, targetThe.type);

    // Verify target type matches the inductive type
    if (!(targetTypeValue instanceof V.InductiveTypeConstructor) ||
      targetTypeValue.name !== elimApp.typeName) {
      return new stop(elimApp.location,
        new Message([`Expected type ${elimApp.typeName}, got ${targetTypeValue.readBackType(ctx)}`]));
    }

    // PHASE 3: Generate & Check Motive Type
    // Generate expected motive type: (Π [target : T] U)
    let indexTypes = inductiveTypeValue.indexTypes
    const buildMotive = (level: number, capturedIndices: V.Value[]): V.Value => {
      if (level >= indexTypes.length) {
        // Base case: build (Π [target : InductiveType(name, params, capturedIndices)] U)
        return new V.Pi(
          'target',
          new V.InductiveTypeConstructor(targetTypeValue.name, targetTypeValue.parameters, capturedIndices),
          new HigherOrderClosure(_ => new V.Universe())
        );
      }

      // Recursive case: build (Π [index : τ] ...)
      const indexType = indexTypes[level];
      return new V.Pi(
        fresh(ctx, 'idx'),
        indexType,
        new HigherOrderClosure(indexVal =>
          buildMotive(level + 1, [...capturedIndices, indexVal])
        )
      );
    };

    const expectedMotiveType = buildMotive(0, [])

    const motiveCheck = elimApp.motive.check(ctx, r, expectedMotiveType);
    if (motiveCheck instanceof stop) return motiveCheck;

    const motiveCore = (motiveCheck as go<C.Core>).result;
    const motiveValue = valInContext(ctx, motiveCore);
    const motiveTypeCore = expectedMotiveType.readBackType(ctx);  // Store motive type for Neutral handling

    // PHASE 4: Get constructor types and check methods
    const constructorTypes = this.getConstructorTypesForDatatype(ctx, elimApp.typeName);

    if (elimApp.methods.length !== constructorTypes.length) {
      return new stop(elimApp.location,
        new Message([`Expected ${constructorTypes.length} methods, got ${elimApp.methods.length}`]));
    }

    // Extend context with type parameters so we can evaluate constructor argument types
    let extendedCtx = ctx;
    if (constructorTypes.length > 0) {
      const firstCtor = constructorTypes[0].core;
      for (let i = 0; i < firstCtor.resultType.parameters.length && i < targetTypeValue.parameters.length; i++) {
        const paramCore = firstCtor.resultType.parameters[i];
        if (paramCore instanceof C.VarName) {
          extendedCtx = bindFree(extendedCtx, paramCore.name, targetTypeValue.parameters[i]);
        }
      }
    }

    const checkedMethods: C.Core[] = [];
    const methodTypeCores: C.Core[] = [];  // Store method types as Core
    for (let i = 0; i < elimApp.methods.length; i++) {
      const expectedMethodType = this.generateMethodTypeForConstructor(
        extendedCtx,
        constructorTypes[i].core,
        readBack(ctx, expectedMotiveType, motiveValue),
        targetTypeValue.parameters
      );

      // Store the method type as Core for later use in evaluation
      methodTypeCores.push(expectedMethodType);

      const methodCheck = elimApp.methods[i].check(ctx, r, valInContext(extendedCtx, expectedMethodType));
      if (methodCheck instanceof stop) return methodCheck;

      checkedMethods.push((methodCheck as go<C.Core>).result);
    }

    // PHASE 5: Compute Result Type & Build Core
    // For indexed types, apply motive to indices first, then target
    let resultType: V.Value = motiveValue;

    // Apply to each index value from the target's type
    for (const indexValue of targetTypeValue.indices) {
      resultType = doApp(resultType, indexValue);
    }

    // Finally apply to the target value itself
    resultType = doApp(resultType, valInContext(ctx, targetThe.expr));

    const eliminatorCore = new C.Eliminator(
      elimApp.typeName,
      targetThe.expr,
      motiveCore,
      checkedMethods,
      methodTypeCores,  // Pass method types for proper Neutral handling
      motiveTypeCore  // Pass motive type for proper Neutral handling with indexed types
    );

    return new go(new C.The(
      resultType.readBackType(ctx),
      eliminatorCore
    ));
  }

  /**
   * Get constructor types for a datatype from context
   */
  private static getConstructorTypesForDatatype(ctx: Context, typeName: string): { core: C.ConstructorType, resultTypeValue: V.InductiveTypeConstructor }[] {
    const constructorTypes: { core: C.ConstructorType, resultTypeValue: V.InductiveTypeConstructor }[] = [];

    for (const [name, binder] of ctx) {
      if (binder instanceof ConstructorTypeBinder) {
        const ctor = binder.constructorType;
        if (ctor.type === typeName) {
          constructorTypes.push({ core: binder.constructorType, resultTypeValue: binder.type });
        }
      }
    }

    return constructorTypes.sort((a, b) => a.core.index - b.core.index);
  }

  /**
   * Generate method type for a constructor
   * Form: (Π [args...] (→ [IHs...] (P ctor)))
   */
  private static generateMethodTypeForConstructor(
    ctx: Context,
    ctorType: C.ConstructorType,
    motive_core: C.Core,
    typeParams: V.Value[]
  ): C.Core {
    let cur_ret = motive_core
    for (const index of ctorType.resultType.indices) {
      cur_ret = new C.Application(cur_ret, index)
    }
    const ctor = new C.Constructor(ctorType.name, ctorType.index,
      ctorType.type, ctorType.argNames.map(name => new C.VarName(name)),
      ctorType.rec_argNames.map(name => new C.VarName(name))
    )
    cur_ret = new C.Application(cur_ret, ctor)

    // Build Pis in reverse order: IH args, then recursive args, then regular args
    // Iterate backwards so the first argument is on the outside
    for (let i = ctorType.rec_argTypes.length - 1; i >= 0; i--) {
      const recArgTypeCore = ctorType.rec_argTypes[i];

      if (recArgTypeCore instanceof C.InductiveTypeConstructor) {
        let ihType = motive_core
        for (const indexCore of recArgTypeCore.indices) {
          const indexValue = indexCore
          ihType = new C.Application(ihType, indexValue);
        }
        const recArgName = ctorType.rec_argNames[i];
        const recArgVar = new C.VarName(recArgName)
        ihType = new C.Application(ihType, recArgVar);

        // Fresh name for IH
        const ihName = fresh(ctx, 'ih');
        cur_ret = new C.Pi(ihName, ihType, cur_ret)
      } else {
        throw new Error('not recursive arg')
      }
    }

    for (let i = ctorType.rec_argTypes.length - 1; i >= 0; i--) {
      const rec_argTypeCore = ctorType.rec_argTypes[i]
      const rec_argName = ctorType.rec_argNames[i]
      cur_ret = new C.Pi(rec_argName, rec_argTypeCore, cur_ret)
    }

    for (let i = ctorType.argTypes.length - 1; i >= 0; i--) {
      const argTypeCore = ctorType.argTypes[i]
      const argName = ctorType.argNames[i]
      cur_ret = new C.Pi(argName, argTypeCore, cur_ret)
    }
    return cur_ret
  }
}

function extractIndicesFromValue(val: V.Value): V.Value[] {
  if (val instanceof V.InductiveTypeConstructor) {
    return val.indices;
  }
  return [];
}
</file>

<file path="src/pie_interpreter/types/value.ts">
import * as C from "./core";
import * as N from "./neutral";

import { bindFree, Context, InductiveDatatypeBinder } from "../utils/context";
import { Environment } from "../utils/environment";
import { Closure } from "./utils";
import { fresh } from "./utils";
import { readBack } from "../evaluator/utils";

/*
    ## Values ##
    
    In order to type check Pie, it is necessary to find the normal
    forms of expressions and compare them with each other. The normal
    form of an expression is determined by its type - types that have
    η-rules (such as Π, Σ, Trivial, and Absurd) impose requirements on
    the normal form. For instance, every normal function has λ at the
    top, and every normal pair has cons at the top.

    Finding normal forms has two steps: first, programs are evaluated,
    much as they are with the Scheme interpreter at the end of The
    Little Schemer. Then, these values are "read back" into the syntax
    of their normal forms. This happens in normalize.rkt. This file
    defines the values that expressions can have. Structures or symbols
    that represent values are written with prefix V_.

    Laziness is implemented by allowing values to be a closure that
    does not bind a variable. It is described in normalize.rkt (search
    for "Call-by-need").
*/

export abstract class Value {

  /*
  now demands the _actual_ value represented by a DELAY. If the value
  is a DELAY-CLOS, then it is computed using undelay. If it is
  anything else, then it has already been computed, so it is
  returned.
  
  now should be used any time that a value is inspected to see what
  form it has, because those situations require that the delayed
  evaluation steps be carried out.
  */
  public now(): Value {
    return this;
  }

  public abstract readBackType(context: Context): C.Core;

  public abstract prettyPrint(): string;

}

export class DelayClosure {
  env: Environment;
  expr: C.Core;

  constructor(env: Environment, expr: C.Core) {
    this.env = env;
    this.expr = expr;
  }
  /*
    undelay is used to find the value that is contained in a
    DELAY-CLOS closure by invoking the evaluator.
  */
  public undelay(): Value {
    return this.expr.valOf(this.env).now();
  }

  public toString(): string {
    return `DelayClosure(${this.env}, ${this.expr})`;
  }

}

export class Box<Type> {
  content: Type;

  constructor(value: Type) {
    this.content = value;
  }

  public get() {
    return this.content;
  }
  public set(value: Type) {
    this.content = value;
  }
}


export class Delay extends Value {

  constructor(public val: Box<DelayClosure | Value>) { super() }

  public now(): Value {
    const boxContent = this.val.get();
    if (boxContent instanceof DelayClosure) {
      const theValue = boxContent.undelay();
      this.val.set(theValue);
      return theValue;
    } else { // content is a Value (content instanceof Value).
      return boxContent as Value;
    }
  }

  public readBackType(context: Context): C.Core {
    return this.now().readBackType(context);
  }

  public prettyPrint(): string {
    return this.now().prettyPrint();
  }

  public toString(): string {
    return `Delay(${this.val})`;
  }

}

export class Quote extends Value {
  constructor(public name: string) { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Quote.");
  }

  public prettyPrint(): string {
    return `'${this.name}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Nat extends Value {
  constructor() { super() }

  public readBackType(_: Context): C.Core {
    return new C.Nat();
  }

  public prettyPrint(): string {
    return 'Nat';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Zero extends Value {
  constructor() { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Zero.");
  }

  public prettyPrint(): string {
    return 'zero';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Add1 extends Value {

  constructor(public smaller: Value) { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Add1.");
  }

  public prettyPrint(): string {
    return `(add1 ${this.smaller.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Pi extends Value {

  constructor(
    public argName: string,
    public argType: Value,
    public resultType: Closure
  ) { super() }

  public readBackType(context: Context): C.Core {
    const Aexpr = this.argType.readBackType(context);
    const freshedName =  fresh(context, this.argName);
    const excludeNameCtx = bindFree(context, freshedName, this.argType);
    return new C.Pi(
      freshedName,
      Aexpr,
      this.resultType
        .valOfClosure(
          new Neutral(this.argType, new N.Variable(freshedName))
        )
        .readBackType(excludeNameCtx)
    );
  }

  public prettyPrint(): string {
    return `(Π ${this.argName} ${this.argType.prettyPrint()} ${this.resultType.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Lambda extends Value {

  constructor(
    public argName: string,
    public body: Closure
  ) { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Lambda.");
  }

  public prettyPrint(): string {
    return `(lambda ${this.argName} ${this.body.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Sigma extends Value {
  constructor(
    public carName: string,
    public carType: Value,
    public cdrType: Closure
  ) { super() }
  
  public readBackType(context: Context): C.Core {
    const Aexpr = this.carType.readBackType(context);
    const freshedName = fresh(context, this.carName);
    const excludeNameCtx = bindFree(context, freshedName, this.carType);
    return new C.Sigma(
      freshedName,
      Aexpr,
      this.cdrType
        .valOfClosure(
          new Neutral(this.carType, new N.Variable(freshedName))
        )
        .readBackType(excludeNameCtx)
    );
  }

  public prettyPrint(): string {
    return `(Σ ${this.carName} ${this.carType.prettyPrint()} ${this.cdrType.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Cons extends Value {

  constructor(
    public car: Value,
    public cdr: Value
  ) { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Cons.");
  }

  public prettyPrint(): string {
    return `(cons ${this.car.prettyPrint()} ${this.cdr.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class List extends Value {

  constructor(public entryType: Value) { super() }

  public readBackType(context: Context): C.Core {
    return new C.List(this.entryType.readBackType(context));
  }

  public prettyPrint(): string {
    return `(List ${this.entryType.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Nil extends Value {
  constructor() { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Nil.");
  }

  public prettyPrint(): string {
    return 'nil';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class ListCons extends Value {

  constructor(
    public head: Value,
    public tail: Value
  ) { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for ListCons.");
  }

  public prettyPrint(): string {
    return `(:: ${this.head.prettyPrint()} ${this.tail.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}


export class Equal extends Value {

  constructor(
    public type: Value,
    public from: Value,
    public to: Value
  ) { super() }

  public readBackType(context: Context): C.Core {
    return new C.Equal(
      this.type.readBackType(context),
      readBack(context, this.type, this.from),
      readBack(context, this.type, this.to)
    );
  }

  public prettyPrint(): string {
    return `(= ${this.type.prettyPrint()} ${this.from.prettyPrint()} ${this.to.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Same extends Value {

  constructor(public value: Value) { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Same.");
  }

  public prettyPrint(): string {
    return `(same ${this.value.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Vec extends Value {

  constructor(
    public entryType: Value,
    public length: Value
  ) { super() }

  public readBackType(context: Context): C.Core {
    return new C.Vec(
      this.entryType.readBackType(context),
      readBack(context, new Nat(), this.length)
    );
  }

  public prettyPrint(): string {
    return `(Vec ${this.entryType.prettyPrint()} ${this.length.prettyPrint()})`;
  }

}

export class VecNil extends Value {

  constructor() { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for VecNil.");
  }

  public prettyPrint(): string {
    return 'vecnil';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class VecCons extends Value {

  constructor(
    public head: Value,
    public tail: Value
  ) { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for VecCons.");
  }

  public prettyPrint(): string {
    return `(vec:: ${this.head.prettyPrint()} ${this.tail.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Either extends Value {

  constructor(
    public leftType: Value,
    public rightType: Value
  ) { super() }

  public readBackType(context: Context): C.Core {
    return new C.Either(
      this.leftType.readBackType(context),
      this.rightType.readBackType(context)
    );
  }

  public prettyPrint(): string {
    return `(Either ${this.leftType.prettyPrint()} ${this.rightType.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Left extends Value {

  constructor(public value: Value) { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Left.");
  }

  public prettyPrint(): string {
    return `(left ${this.value.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Right extends Value {
  constructor(public value: Value) { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Right.");
  }

  public prettyPrint(): string {
    return `(right ${this.value.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Neutral extends Value {
  constructor(
    public type: Value,
    public neutral: N.Neutral
  ) { super() }

  public readBackType(context: Context): C.Core {
    return this.neutral.readBackNeutral(context);
  }

  public prettyPrint(): string {
    return `(Neutral ${this.type.prettyPrint()} ${this.neutral.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Universe extends Value {

  constructor() { super() }

  public readBackType(_: Context): C.Core {
    return new C.Universe();
  }

  public prettyPrint(): string {
    return 'U';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}



export class Atom extends Value {

  constructor() { super() }

  public readBackType(_: Context): C.Core {
    return new C.Atom();
  }

  public prettyPrint(): string {
    return 'Atom';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Trivial extends Value {
  constructor() { super() }

  public readBackType(_: Context): C.Core {
    return new C.Trivial();
  }

  public prettyPrint(): string {
    return 'Trivial';
  }

  public toString(): string {
    return this.prettyPrint();
  }
}

export class Sole extends Value {
  constructor() { super() }

  public readBackType(_: Context): C.Core {
    throw new Error("No readBackType for Sole.");
  }

  public prettyPrint(): string {
    return 'sole';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}


export class Absurd extends Value {

  constructor() { super() }

  public readBackType(_: Context): C.Core {
    return new C.Absurd();
  }

  public prettyPrint(): string {
    return 'Absurd';
  }

  public toString(): string {
    return this.prettyPrint();
  }
  
}

export class InductiveTypeConstructor extends Value {
  constructor(
    public name: string,
    public parameters: Value[],
    public indices: Value[],
  ) { super() }

  public readBackType(context: Context): C.Core {
    // Look up the inductive type definition to get index types
    const inductiveBinder = context.get(this.name);
    let indexTypes: Value[] = [];

    if (inductiveBinder && inductiveBinder instanceof InductiveDatatypeBinder) {
      const inductiveType = inductiveBinder.type;
      if (inductiveType instanceof InductiveType) {
        indexTypes = inductiveType.indexTypes;
      }
    }

    return new C.InductiveTypeConstructor(
      this.name,
      this.parameters.map(p => p.readBackType(context)),
      this.indices.map((i, idx) => {
        // Indices are VALUES (like Zero, Add1), not types
        // We need to use readBack with the appropriate type
        const indexType = indexTypes[idx]?.now(); // Get the type for this index (e.g., Nat)

        // Check if this is a Delay that hasn't been forced yet
        if (i instanceof Delay) {
          const boxContent = i.val.get();
          if (boxContent instanceof DelayClosure) {
            // It's a closure - try to force it
            try {
              const iNow = i.now();
              if (indexType) {
                // Use readBack with the index type
                return readBack(context, indexType, iNow);
              } else if (iNow instanceof Neutral) {
                return iNow.neutral.readBackNeutral(context);
              } else {
                // Fallback: return the Core expression if we can't read back
                return boxContent.expr;
              }
            } catch (e) {
              // If evaluation fails due to free variables, return the Core expression as-is
              return boxContent.expr;
            }
          } else {
            // Already evaluated
            const val = boxContent as Value;
            if (indexType) {
              return readBack(context, indexType, val);
            } else if (val instanceof Neutral) {
              return val.neutral.readBackNeutral(context);
            } else {
              // Can't read back without type - this shouldn't happen
              throw new Error(`Cannot read back index without type: ${val.prettyPrint()}`);
            }
          }
        } else {
          // Not a Delay - force it and read back
          const iNow = i.now();
          if (indexType) {
            return readBack(context, indexType, iNow);
          } else if (iNow instanceof Neutral) {
            return iNow.neutral.readBackNeutral(context);
          } else {
            // Can't read back without type - this shouldn't happen
            throw new Error(`Cannot read back index without type: ${iNow.prettyPrint()}`);
          }
        }
      }),
    )
  }

  public prettyPrint(): string {
    return `InductiveType ${this.name}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }
}

export class InductiveType extends Value {
  constructor(
    public name: string,
    public parameterTypes: Value[],
    public indexTypes: Value[],
  ) { super() }

  public readBackType(context: Context): C.Core {
    return new C.InductiveType(
      this.name,
      this.parameterTypes.map(p => p.readBackType(context)),
      this.indexTypes.map(i => i.readBackType(context)),
    )
  }

  public prettyPrint(): string {
    return `InductiveType ${this.name}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }
}

export class Constructor extends Value {

  constructor(
    public name: string,
    public type: string,
    public args: Value[],
    public index: number,
    public recursive_args: Value[],
  ) { super() }

  public readBackType(context: Context): C.Core {
    throw new Error("No readBackType for Constructor.");
  }

  public prettyPrint(): string {
    const args = this.args.map(a => a.prettyPrint()).join(' ');
    return `(${this.name}${args.length > 0 ? ' ' + args : ''})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }
}

export class ConstructorType extends Value {
  constructor(
    public name: string,
    public index: number,
    public type: string,
    public argTypes: Value[],
    public rec_argTypes: Value[],
    public resultType: Value,
    public argNames: string[],
    public rec_argNames: string[]

  ) {super()}
  public readBackType(context: Context): C.Core {
    throw Error('Method not implemented')
  }
  public prettyPrint(): string {
    return `ConstructorType (${this.argTypes.map(a => a.prettyPrint()).join(' ')})`;
  }

}

export class EliminatorType extends Value {
  constructor(
    public typeName: string,
    public targetType: Value,
    public motiveType: Value,
    public methodTypes: Value[]
  ) { super(); }

  public readBackType(context: Context): C.Core {
    return new C.EliminatorType(
      this.typeName,
      this.targetType.readBackType(context),
      this.motiveType.readBackType(context),
      this.methodTypes.map(m => m.readBackType(context))
    );
  }

  public prettyPrint(): string {
    return `EliminatorType ${this.typeName} ${this.targetType.prettyPrint()} ${this.motiveType.prettyPrint()} ${this.methodTypes.map(m => m.prettyPrint()).join(' ')}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }
}
</file>

<file path="src/pie_interpreter/typechecker/definedatatype.ts">
import * as S from '../types/source';
import * as C from '../types/core';
import * as V from '../types/value';
import { go, Perhaps, stop, fresh, TypedBinder, Message } from '../types/utils';
import { 
  Context, 
  extendContext, 
  InductiveDatatypeBinder, 
  ConstructorTypeBinder, 
  valInContext, 
  bindFree 
} from '../utils/context';
import { Location, Syntax } from '../utils/locations';
import { extendRenaming, Renaming } from './utils';
import { Position } from '../../scheme_parser/transpiler/types/location';

function isRecursiveArgumentType(argType: S.Source, datatypeName: string): boolean {
  if (argType instanceof S.Name && argType.name === datatypeName) {
    return true;
  }

  if (argType instanceof S.GeneralTypeConstructor &&
    argType.name === datatypeName) {
    return true;
  }

  return false;
}

export class DefineDatatypeSource {
  constructor(
    public location: Location,
    public name: string,
    public parameters: TypedBinder[],
    public indices: TypedBinder[],
    public constructors: GeneralConstructor[],
    public eliminatorName?: string
  ) { }

  normalizeConstructor(ctx: Context, rename: Renaming) {
    const validTypeTemp = (new S.GeneralType
      (this.location,
        this.name,
        this.parameters,
        this.indices
      ).isType(ctx, rename)
    )
    if (validTypeTemp instanceof stop) {
      throw new Error(validTypeTemp.message.toString())
    }
    const validType = (validTypeTemp as go<C.Core>).result

    // Extend context with parameters so constructors can reference them
    let extendedCtx = ctx;
    let extendedRename = rename;
    for (const param of this.parameters) {
      const paramName = param.binder.varName;
      const paramTypeResult = param.type.isType(extendedCtx, extendedRename);
      if (paramTypeResult instanceof stop) {
        throw new Error(paramTypeResult.message.toString());
      }
      const paramTypeCore = (paramTypeResult as go<C.Core>).result;
      const paramNameHat = fresh(extendedCtx, paramName);
      extendedCtx = bindFree(extendedCtx, paramNameHat, valInContext(extendedCtx, paramTypeCore));
      extendedRename = extendRenaming(extendedRename, paramName, paramNameHat);
    }

    // Evaluate the type in the extended context so parameters are bound
    const validValueType = valInContext(extendedCtx, validType);

    // Add the inductive type itself to the context so recursive constructors can reference it
    extendedCtx = extendContext(extendedCtx, this.name,
      new InductiveDatatypeBinder(this.name, validValueType as V.InductiveType))

    const normalized_constructor: C.ConstructorType[] = []
    for (let i = 0; i < this.constructors.length; i++) {
      normalized_constructor.push(
        this.constructors[i].checkValid(
          extendedCtx,
          extendedRename,
          validValueType as any,
          i
        )
      )
    }

    // Build return context: start from original, add datatype and constructors
    // Do NOT include parameter bindings in return context - they're only for internal checking
    let ret_ctx = ctx;
    let ret_rename = rename;

    ret_ctx = extendContext(ret_ctx, this.name,
      new InductiveDatatypeBinder(this.name, validValueType as V.InductiveType))
    normalized_constructor.forEach(element => {
      const fresh_name = fresh(ret_ctx, element.name)
      const resultTypeValue = valInContext(extendedCtx, element.resultType) as V.InductiveTypeConstructor

      ret_ctx = extendContext(ret_ctx, fresh_name, new ConstructorTypeBinder(fresh_name, element, resultTypeValue))
      ret_rename = extendRenaming(ret_rename, element.name, fresh_name)
    })
    return [ret_ctx, ret_rename] as [Context, Renaming]
  }
}

export class GeneralConstructor {
  constructor(
    public location: Location,
    public name: string,
    public args: TypedBinder[],
    public returnType: S.GeneralTypeConstructor
  ) { }

  checkValid(ctx: Context, rename: Renaming, target: V.Value, index: number) {
    let cur_ctx = ctx
    let cur_rename = rename
    const normalized_args: C.Core[] = []
    const normalized_rec_args: C.Core[] = []
    const argNames: string[] = []
    const rec_argNames: string[] = []

    for (let i = 0; i < this.args.length; i++) {
      const argName = this.args[i].binder.varName
      const xhat = fresh(cur_ctx, argName)

      // Get the Core representation of the type annotation
      const resultTemp = this.args[i].type.isType(cur_ctx, cur_rename)
      if (resultTemp instanceof stop) {
        throw new Error(resultTemp.message.toString())
      }
      const result = (resultTemp as go<C.Core>).result

      // Assume user puts non-recursive args before recursive args
      if (isRecursiveArgumentType(this.args[i].type, this.returnType.name)) {
        normalized_rec_args.push(result)
        rec_argNames.push(xhat)
      } else {
        normalized_args.push(result)
        argNames.push(xhat)
      }

      cur_ctx = bindFree(cur_ctx, xhat, valInContext(cur_ctx, result))
      cur_rename = extendRenaming(cur_rename, argName, xhat)
    }

    const returnTemp = this.returnType.check(cur_ctx, cur_rename, target)
    if (returnTemp instanceof stop) {
      throw new Error(returnTemp.message.toString())
    }
    const returnResult = (returnTemp as go<C.Core>).result
    return new C.ConstructorType(
      this.name,
      index,
      this.returnType.name,
      normalized_args,
      normalized_rec_args,
      returnResult as C.InductiveTypeConstructor,
      argNames,
      rec_argNames
    )
  }
}

// Helper function to create constructor spec
export function makeConstructorSpec(name: string, args: TypedBinder[]): GeneralConstructor {
  return new GeneralConstructor(
    args.length > 0 ? args[0].binder.location : new Location(new Syntax(new Position(0, 0), new Position(0, 0), 'generated'), false),
    name,
    args,
    new S.GeneralTypeConstructor(
      args.length > 0 ? args[0].binder.location : new Location(new Syntax(new Position(0, 0), new Position(0, 0), 'generated'), false),
      '',  // Will be set by caller
      [],
      []
    )
  );
}

// Main function to handle datatype definition and add to context
export function handleDefineDatatype(ctx: Context, rename: Renaming, target: DefineDatatypeSource): Perhaps<Context> {
  if (ctx.has(target.name)) {
    return new stop(target.location, new Message([`Name already in use: ${target.name}`]));
  }

  const [new_ctx, new_rename] = target.normalizeConstructor(ctx, rename);
  return new go<Context>(new_ctx);
}
</file>

<file path="src/pie_interpreter/types/core.ts">
import * as V from "./value";
import * as N from './neutral';

import * as Evaluator from '../evaluator/evaluator';
import { Environment, getValueFromEnvironment } from '../utils/environment';
import { SourceLocation } from '../utils/locations';
import { FirstOrderClosure, isVarName } from './utils';



/*
  ### Core Types ###

    Core Pie expressions are the result of type checking (elaborating)
    an expression written in Pie. They do not have source positions,
    because they by definition are not written by a user of the
    implementation.

*/

export abstract class Core {

  public abstract valOf(env: Environment): V.Value;

  public abstract prettyPrint(): string;

  /*
    Original "later" function. It is used to delay the evaluation.
  */
  public toLazy(env: Environment): V.Value {
    return new V.Delay(new V.Box(new V.DelayClosure(env, this)));
  }

}

export class The extends Core {

  constructor(
    public type: Core,
    public expr: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return this.expr.valOf(env);
  }

  public prettyPrint(): string {
    return `(the ${this.type.prettyPrint()} ${this.expr.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }
}

export class Universe extends Core {

  public valOf(_: Environment): V.Value {
    return new V.Universe();
  }

  public prettyPrint(): string {
    return 'U';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Nat extends Core {

  public valOf(_: Environment): V.Value {
    return new V.Nat();
  }

  public prettyPrint(): string {
    return 'Nat';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Zero extends Core {

  public valOf(_: Environment): V.Value {
    return new V.Zero();
  }

  public prettyPrint(): string {
    return '0';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}


export class Add1 extends Core {

  constructor(
    public n: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.Add1(this.n.toLazy(env));
  }

  public prettyPrint(): string {
    const n = Number(this.n.prettyPrint());

    if (!isNaN(n)) {
      return `${n + 1}`;
    }
    return `(add1 ${this.n.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class WhichNat extends Core {

  constructor(
    public target: Core,
    public base: The,
    public step: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doWhichNat(
      this.target.toLazy(env),
      this.base.type.toLazy(env),
      this.base.expr.toLazy(env),
      this.step.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(which-Nat ${this.target.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IterNat extends Core {

  constructor(
    public target: Core,
    public base: The,
    public step: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doIterNat(
      this.target.toLazy(env),
      this.base.type.toLazy(env),
      this.base.expr.toLazy(env),
      this.step.toLazy(env)
    );
  }

  public prettyPrint(): string {
    return `(iter-Nat ${this.target.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class RecNat extends Core {

  constructor(
    public target: Core,
    public base: The,
    public step: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doRecNat(
      this.target.toLazy(env),
      this.base.type.toLazy(env),
      this.base.expr.toLazy(env),
      this.step.toLazy(env)
    );
  }

  public prettyPrint(): string {
    return `(rec-Nat ${this.target.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndNat extends Core {

  constructor(
    public target: Core,
    public motive: Core,
    public base: Core,
    public step: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doIndNat(
      this.target.toLazy(env),
      this.motive.toLazy(env),
      this.base.toLazy(env),
      this.step.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(ind-Nat ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Pi extends Core {

  constructor(
    public name: string,
    public type: Core,
    public body: Core
  ) { super() }


  public valOf(env: Environment): V.Value {
    const typeVal = this.type.toLazy(env);
    return new V.Pi(this.name, typeVal,
      new FirstOrderClosure(env, this.name, this.body)
    );
  }

  public prettyPrint(): string {
    return `(Π (${this.name} ${this.type.prettyPrint()}) 
          ${this.body.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Lambda extends Core {

  constructor(
    public param: string,
    public body: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.Lambda(this.param,
      new FirstOrderClosure(env, this.param, this.body));
  }

  public prettyPrint(): string {
    return `(λ (${this.param}) ${this.body.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Atom extends Core {

  public valOf(_: Environment): V.Value {
    return new V.Atom();
  }

  public prettyPrint(): string {
    return 'Atom';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Quote extends Core {
  constructor(
    public sym: string
  ) { super() }

  public valOf(_: Environment): V.Value {
    return new V.Quote(this.sym);
  }

  public prettyPrint(): string {
    return `'${this.sym}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Sigma extends Core {

  constructor(
    public name: string,
    public type: Core,
    public body: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    const typeVal = this.type.toLazy(env);
    return new V.Sigma(this.name, typeVal,
      new FirstOrderClosure(env, this.name, this.body));
  }

  public prettyPrint(): string {
    return `(Σ (${this.name} ${this.type.prettyPrint()}) 
              ${this.body.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Cons extends Core {

  constructor(
    public first: Core,
    public second: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    const first = this.first.toLazy(env);
    const second = this.second.toLazy(env);
    return new V.Cons(first, second);
  }

  public prettyPrint(): string {
    return `(cons ${this.first.prettyPrint()} ${this.second.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Car extends Core {

  constructor(
    public pair: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doCar(this.pair.toLazy(env));
  }

  public prettyPrint(): string {
    return `(car ${this.pair.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Cdr extends Core {
  constructor(
    public pair: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doCdr(this.pair.toLazy(env));
  }

  public prettyPrint(): string {
    return `(cdr ${this.pair.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class ListCons extends Core {

  constructor(
    public head: Core,
    public tail: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    const head = this.head.toLazy(env);
    const tail = this.tail.toLazy(env);
    return new V.ListCons(head, tail);
  }

  public prettyPrint(): string {
    return `(:: ${this.head.prettyPrint()} ${this.tail.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Nil extends Core {

  public valOf(_: Environment): V.Value {
    return new V.Nil();
  }

  public prettyPrint(): string {
    return 'nil';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class List extends Core {

  constructor(
    public elemType: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.List(this.elemType.toLazy(env));
  }

  public prettyPrint(): string {
    return `(List ${this.elemType.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class RecList extends Core {

  constructor(
    public target: Core,
    public base: The,
    public step: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doRecList(
      this.target.toLazy(env),
      this.base.type.toLazy(env),
      this.base.expr.toLazy(env),
      this.step.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(rec-List ${this.target.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndList extends Core {

  constructor(
    public target: Core,
    public motive: Core,
    public base: Core,
    public step: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doIndList(
      this.target.toLazy(env),
      this.motive.toLazy(env),
      this.base.toLazy(env),
      this.step.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(ind-List ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Trivial extends Core {

  public valOf(_env: Environment): V.Value {
    return new V.Trivial();
  }

  public prettyPrint(): string {
    return 'Trivial';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Sole extends Core {

  public valOf(_: Environment): V.Value {
    return new V.Sole();
  }

  public prettyPrint(): string {
    return 'sole';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Absurd extends Core {

  public valOf(_: Environment): V.Value {
    return new V.Absurd();
  }

  public prettyPrint(): string {
    return 'Absurd';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndAbsurd extends Core {

  constructor(
    public target: Core,
    public motive: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doIndAbsurd(
      this.target.toLazy(env),
      this.motive.toLazy(env)
    );
  }

  public prettyPrint(): string {
    return `(ind-Absurd 
              ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Equal extends Core {

  constructor(
    public type: Core,
    public left: Core,
    public right: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.Equal(
      this.type.toLazy(env),
      this.left.toLazy(env),
      this.right.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(= ${this.type.prettyPrint()} 
              ${this.left.prettyPrint()} 
              ${this.right.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Same extends Core {

  constructor(
    public type: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.Same(this.type.toLazy(env));
  }

  public prettyPrint(): string {
    return `(same ${this.type.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Replace extends Core {

  constructor(
    public target: Core,
    public motive: Core,
    public base: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doReplace(
      this.target.toLazy(env),
      this.motive.toLazy(env),
      this.base.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(replace ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.base.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Trans extends Core {

  constructor(
    public left: Core,
    public right: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doTrans(
      this.left.toLazy(env),
      this.right.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(trans ${this.left.prettyPrint()} ${this.right.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Cong extends Core {

  constructor(
    public target: Core,
    public base: Core,
    public fun: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doCong(
      this.target.toLazy(env),
      this.base.toLazy(env),
      this.fun.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(cong ${this.target.prettyPrint()} ${this.fun.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Symm extends Core {
  constructor(
    public equality: Core
  ) { super() }
  public valOf(env: Environment): V.Value {
    return Evaluator.doSymm(
      this.equality.toLazy(env)
    );
  }

  public prettyPrint(): string {
    return `(symm ${this.equality.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndEqual extends Core {

  constructor(
    public target: Core,
    public motive: Core,
    public base: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doIndEqual(
      this.target.toLazy(env),
      this.motive.toLazy(env),
      this.base.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(ind-= ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.base.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Vec extends Core {
  constructor(
    public type: Core,
    public length: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.Vec(
      this.type.toLazy(env),
      this.length.toLazy(env)
    );
  }

  public prettyPrint(): string {
    return `(Vec ${this.type.prettyPrint()} ${this.length.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class VecCons extends Core {

  constructor(
    public head: Core,
    public tail: Core
  ) { super() }


  public valOf(env: Environment): V.Value {
    return new V.VecCons(
      this.head.toLazy(env),
      this.tail.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(vec:: ${this.head.prettyPrint()} ${this.tail.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class VecNil extends Core {

  public valOf(_: Environment): V.Value {
    return new V.VecNil();
  }

  public prettyPrint(): string {
    return 'vecnil';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Head extends Core {

  constructor(
    public vec: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doHead(this.vec.toLazy(env));
  }

  public prettyPrint(): string {
    return `(head ${this.vec.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Tail extends Core {

  constructor(
    public vec: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doTail(this.vec.toLazy(env));
  }

  public prettyPrint(): string {
    return `(tail ${this.vec.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndVec extends Core {

  constructor(
    public length: Core,
    public target: Core,
    public motive: Core,
    public base: Core,
    public step: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doIndVec(
      this.length.toLazy(env),
      this.target.toLazy(env),
      this.motive.toLazy(env),
      this.base.toLazy(env),
      this.step.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `ind-Vec ${this.length.prettyPrint()}
              ${this.target.prettyPrint()}
              ${this.motive.prettyPrint()}
              ${this.base.prettyPrint()}
              ${this.step.prettyPrint()}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Either extends Core {

  constructor(
    public left: Core,
    public right: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.Either(this.left.toLazy(env), this.right.toLazy(env));
  }

  public prettyPrint(): string {
    return `(Either ${this.left.prettyPrint()} ${this.right.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Left extends Core {

  constructor(
    public value: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.Left(this.value.toLazy(env));
  }

  public prettyPrint(): string {
    return `(left ${this.value.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Right extends Core {

  constructor(
    public value: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.Right(this.value.toLazy(env));
  }

  public prettyPrint(): string {
    return `(right ${this.value.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndEither extends Core {

  constructor(
    public target: Core,
    public motive: Core,
    public baseLeft: Core,
    public baseRight: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doIndEither(
      this.target.toLazy(env),
      this.motive.toLazy(env),
      this.baseLeft.toLazy(env),
      this.baseRight.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(ind-Either ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.baseLeft.prettyPrint()} 
              ${this.baseRight.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class TODO extends Core {
  constructor(
    public loc: SourceLocation,
    public type: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return new V.Neutral(
      this.type.toLazy(env),
      new N.TODO(this.loc, this.type.toLazy(env),)
    )
  }

  public prettyPrint(): string {
    return `TODO ${this.type.prettyPrint()}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Application extends Core {

  constructor(
    public fun: Core,
    public arg: Core
  ) { super() }

  public valOf(env: Environment): V.Value {
    return Evaluator.doApp(
      this.fun.toLazy(env),
      this.arg.toLazy(env),
    );
  }

  public prettyPrint(): string {
    return `(${this.fun.prettyPrint()} ${this.arg.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class VarName extends Core {

  constructor(
    public name: string
  ) { super() }

  public valOf(env: Environment): V.Value {
    if (isVarName(this.name)) {
      return getValueFromEnvironment(env, this.name);
    } else {
      throw new Error(`${this.name} is not a valid variable name`);
    }
  }

  public prettyPrint(): string {
    return this.name;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class InductiveTypeConstructor extends Core {
  public valOf(env: Environment): V.Value {
    return new V.InductiveTypeConstructor(
      this.typeName,
      this.parameters.map(p => p.toLazy(env)),
      this.indices.map(i => i.toLazy(env)),
    );
  }
  constructor(
    public typeName: string,
    public parameters: Core[],
    public indices: Core[],
  ) { super(); }

  public prettyPrint(): string {
    return `${this.typeName}${this.parameters.length > 0 ? ' ' + this.parameters.map(p => p.prettyPrint()).join(' ') : ''}${this.indices.length > 0 ? ' ' + this.indices.map(i => i.prettyPrint()).join(' ') : ''}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }
}

export class InductiveType extends Core {
  public valOf(env: Environment): V.Value {
    return new V.InductiveType(
      this.typeName,
      this.parameterTypes.map(p => p.toLazy(env)),
      this.indexTypes.map(i => i.toLazy(env)),
    );
  }
  constructor(
    public typeName: string,
    public parameterTypes: Core[],
    public indexTypes: Core[],
  ) { super(); }

  public prettyPrint(): string {
    return `${this.typeName}${this.parameterTypes.length > 0 ? ' ' + this.parameterTypes.map(p => p.prettyPrint()).join(' ') : ''}${this.indexTypes.length > 0 ? ' ' + this.indexTypes.map(i => i.prettyPrint()).join(' ') : ''}`;
  }
}

export class Constructor extends Core {

  constructor(
    public name: string,
    public index: number,
    public type: string,
    public args: Core[],
    public recursive_args: Core[]
  ) { super(); }

  public valOf(env: Environment): V.Constructor {
    return new V.Constructor(
      this.name,
      this.type,
      this.args.map(a => a.toLazy(env)),
      this.index,
      this.recursive_args.map(a => a.toLazy(env))
    )
  }

  public prettyPrint(): string {
    const args = this.args.map(a => a.prettyPrint()).join(' ');
    return `(${this.name}${args.length > 0 ? ' ' + args : ''})`;
  }
}

export class ConstructorType extends Core {

  constructor(
    public name: string,
    public index: number,
    public type: string,
    public argTypes: Core[],
    public rec_argTypes: Core[],
    public resultType: InductiveTypeConstructor,
    public argNames: string[],
    public rec_argNames: string[]
  ) { super(); }

  public valOf(env: Environment): V.Value {
    return new V.ConstructorType(
      this.name,
      this.index,
      this.type,
      this.argTypes.map(a => a.toLazy(env)),
      this.rec_argTypes.map(a => a.toLazy(env)),
      this.resultType.toLazy(env),
      this.argNames,
      this.rec_argNames
    )
  }

  public prettyPrint(): string {
    return `ConstructorType ${this.name} : ${this.argTypes.map(a => a.prettyPrint()).join(' -> ')} -> ${this.resultType.prettyPrint()}`;
  }
}

export class Eliminator extends Core {

  constructor(
    public typeName: string,
    public target: Core,
    public motive: Core,
    public methods: Core[],
    public methodTypes?: Core[],  // Optional: method types for proper Neutral handling
    public motiveType?: Core  // Optional: motive type for proper Neutral handling with indexed types
  ) { super(); }

  public valOf(env: Environment): V.Value {
    return Evaluator.doEliminator(
      this.typeName,
      this.target.toLazy(env),
      this.motive.toLazy(env),
      this.methods.map(m => m.toLazy(env)),
      this.methodTypes ? this.methodTypes.map(t => t.toLazy(env)) : undefined,
      this.motiveType ? this.motiveType.toLazy(env) : undefined
    );
  }
  public prettyPrint(): string {
    const methods = this.methods.map(m => m.prettyPrint()).join(' ');
    return `(ind-${this.typeName} ${this.target.prettyPrint()} ${this.motive.prettyPrint()} ${methods})`;
  }
}

export class EliminatorType extends Core {

  constructor(
    public typeName: string,
    public targetType: Core,
    public motiveType: Core,
    public methodTypes: Core[]
  ) { super(); }

  public valOf(env: Environment): V.Value {
    return new V.EliminatorType(
      this.typeName,
      this.targetType.toLazy(env),
      this.motiveType.toLazy(env),
      this.methodTypes.map(m => m.toLazy(env))
    );
  }

  public prettyPrint(): string {
    return `EliminatorType ${this.typeName} ${this.targetType.prettyPrint()} ${this.motiveType.prettyPrint()} ${this.methodTypes.map(m => m.prettyPrint()).join(' ')}`;
  }
}
</file>

<file path="src/pie_interpreter/utils/context.ts">
import * as C from '../types/core';
import { InductiveType, Neutral, Universe, Value, InductiveTypeConstructor } from '../types/value';

import { Location } from './locations';
import { go, stop, Perhaps, goOn, PerhapsM, Message } from '../types/utils';
import { Environment } from './environment';
import { readBack } from '../evaluator/utils';
import { Source} from '../types/source';
import { Variable } from '../types/neutral';
import { ProofManager } from '../tactics/proofmanager';
import { Tactic } from '../tactics/tactics';
import { ProofTreeData } from '../tactics/proofstate';

/*
    ## Contexts ##
    A context maps free variable names to binders.
*/
export type Context = Map<string, Binder>


export function extendContext(ctx: Context, name: string, binder: Binder): Context {
  return new Map([...ctx, [name, binder]]);
}

/*
  Find the value of an expression in the environment that
  corresponds to a context.
*/
export function valInContext(ctx: Context, expr: C.Core): Value {
  return expr.valOf(contextToEnvironment(ctx));
}

export function readBackContext(ctx: Context): SerializableContext {
  const result = new Map();
  for (const [x, binder] of ctx) {
    if (binder instanceof Free) {
      result.set(x, ['free', binder.type.readBackType(ctx)]);
    } else if (binder instanceof Define) {
      result.set(x,
        ['def',
          binder.type.readBackType(ctx),
          readBack(ctx, binder.type, binder.value)
        ]
      );
    } else if (binder instanceof Claim) {
      result.set(x,
        ['claim', binder.type.readBackType(ctx)]);
    }
  }
  return result;
}

export function nameNotUsed(ctx: Context, where: Location, name: string) {
  if (ctx.has(name)) {
    return new stop(
      where,
      new Message([`The name "${name}" is already in use in the context.`])
    );
  } else return new go<boolean>(true);
}

export function getClaim(ctx: Context, where: Location, name: string): Perhaps<Value> {
  for (const [x, binder] of ctx) {
    if (x === name) {
      if (binder instanceof Define) {
        return new stop(where, new Message([`The name "${name}" is already defined.`]))
      } else if (binder instanceof Claim) {
        return new go<Value>(binder.type);
      }
    }
  }
  return new stop(where, new Message([`No claim: ${name}`]));
}

export function addClaimToContext(ctx: Context, fun: string, funLoc: Location, type: Source): Perhaps<Context> {
  const typeOut = new PerhapsM<C.Core>("typeOut")
  return goOn(
    [
      [new PerhapsM("_"), () => nameNotUsed(ctx, funLoc, fun)],
      [typeOut, () => type.isType(ctx, new Map())]
    ],
    () => new go(
      extendContext(
        ctx,
        fun,
        new Claim(valInContext(ctx, typeOut.value))
      )
    )
  )
}

export function removeClaimFromContext(ctx: Context, name: string): Context {
  ctx.delete(name);
  return ctx;
}

export function addDefineToContext(ctx: Context, fun: string, funLoc: Location, expr: Source): Perhaps<Context> {
  const typeOut = new PerhapsM<Value>("typeOut");
  const exprOut = new PerhapsM<C.Core>("exprOut");
  return goOn(
    [
      [typeOut, () => getClaim(ctx, funLoc, fun)],
      [exprOut,
        () => expr.check(
          ctx,
          new Map(),
          typeOut.value)
      ]
    ],
    () => new go(
      bindVal(
        removeClaimFromContext(ctx, fun),
        fun,
        typeOut.value,
        valInContext(ctx, exprOut.value)
      )
    )
  )
}

export interface TacticalResult {
  context: Context;
  message: string;
  proofTree?: ProofTreeData;
  isIncomplete?: boolean;
}

export function addDefineTacticallyToContext(
  ctx: Context,
  name: string,
  location: Location,
  tactics: Tactic[]
): Perhaps<TacticalResult> {
  const proofManager = new ProofManager();
  let message = '';

  // Start the proof
  const startResult = proofManager.startProof(name, ctx, location);
  if (startResult instanceof stop) {
    return startResult;
  }
  message += (startResult as go<string>).result + '\n';

  // Apply each tactic
  for (const tactic of tactics) {
    const tacticResult = proofManager.applyTactic(tactic);
    if (tacticResult instanceof stop) {
      return tacticResult;
    }
    message += (tacticResult as go<string>).result;
  }

  // Check if proof is complete
  if (!proofManager.currentState || !proofManager.currentState.isComplete()) {
    const currentGoal = proofManager.currentState?.getCurrentGoal();
    let goalInfo = '';
    if (currentGoal instanceof go) {
      const goal = currentGoal.result;
      goalInfo = `\n\n${goal.prettyPrintWithContext()}`;
    }
    // Include proof tree even on incomplete proofs for visualization
    const proofTree = proofManager.getProofTreeData() ?? undefined;
    return new go({
      context: ctx,
      message: message + `\n\nProof incomplete. Not all goals have been solved.${goalInfo}`,
      proofTree,
      isIncomplete: true
    });
  }

  // Proof complete - add definition to context
  const claim = ctx.get(name);
  if (!(claim instanceof Claim)) {
    return new stop(location, new Message([`${name} is not a valid claim`]));
  }

  const type = claim.type;

  // TODO: Extract actual proof term from proofManager.currentState
  // The Goal.term field should contain the proof term, but tactics don't set it yet
  // For now, we keep the claim in context rather than adding a faulty placeholder
  // that would fail during readback
  const goalTree = proofManager.currentState?.goalTree;
  const proofTerm = goalTree?.goal.term;

  // Get proof tree data for visualization
  const proofTree = proofManager.getProofTreeData() ?? undefined;

  if (proofTerm) {
    // We have the actual proof term
    const proofValue = valInContext(ctx, proofTerm);
    const newCtx = bindVal(removeClaimFromContext(ctx, name), name, type, proofValue);
    return new go({ context: newCtx, message, proofTree });
  } else {
    // Proof term extraction not implemented yet - keep claim in context
    // This allows the proof to complete without error, but the definition won't be usable
    return new go({ context: ctx, message: message + `\nWarning: Proof term extraction not yet implemented for '${name}'`, proofTree });
  }
}

export function contextToEnvironment(ctx: Context): Environment {
  if (ctx.size === 0) {
    return new Map();
  }
  const bindings = ctx.entries();
  const env = new Map();
  for (const [name, binder] of bindings) {
    if (binder instanceof Define) {
      env.set(name, binder.value);
    } else if (binder instanceof Free) {
      env.set(name, new Neutral(binder.type, new Variable(name)));
    } else if (binder instanceof InductiveDatatypeBinder) {
      env.set(name, binder.type);
    } // else continue;
  }
  return env;
}

export function getInductiveType(ctx: Context, where: Location, name:string): Perhaps<InductiveDatatypeBinder> {
  for (const [n, binder] of ctx) {
    if (binder instanceof InductiveDatatypeBinder && n === name) {
      return new go(binder);
    }
  }
  return new stop(where, new Message([`No inductive type found for ${name} at ${where}`]));
}

export const initCtx: Context = new Map();

// There are three kinds of binders: a free binder represents a free
// variable, that was bound in some larger context by λ, Π, or Σ. A
// def binder represents a name bound by define. A claim binder
// doesn't actually bind a name; however, it reserves the name for
// later definition with define and records the type that will be
// used.

export abstract class Binder {
  abstract type: Value;
}

export class Claim extends Binder {
  constructor(public type: Value) { super() }
}

export class Define extends Binder {
  constructor(public type: Value, public value: Value) { super() }
}

export class Free extends Binder {
  constructor(public type: Value) { super() }
}

export class InductiveDatatypeBinder extends Binder {
  constructor(
    public name: string, 
    public type: InductiveType) {
      super()
    }
}

export class ConstructorTypeBinder extends Binder {
  constructor(
    public name: string,
    public constructorType: C.ConstructorType,
    public type: InductiveTypeConstructor
  ) {
      super()
    }
}

export class EliminatorBinder extends Binder {
  constructor(
    public name: string, 
    public type: Value) {
      super()
    }
}

export function varType(ctx: Context, where: Location, x: string): Perhaps<Value> {
  if (ctx.size === 0) {
    throw new Error(`The context ${JSON.stringify(ctx)} is empty, but we are looking for ${x}`);
  }
  for (const [y, binder] of ctx.entries()) {
    if (binder instanceof Claim) {
      continue;
    } else if (x === y) {
      // Inductive datatypes have type Universe
      if (binder instanceof InductiveDatatypeBinder) {
        return new go(new Universe());
      }
      return new go(binder.type);
    }
  }
  throw new Error(`Unknown variable ${x}`);
}

// Function to bind a free variable in a context
export function bindFree(ctx: Context, varName: string, tv: Value): Context {
  if (ctx.has(varName)) {
    // CHANGE: REMOVE ctx LOOP AFTER FIXING THE BUG
    for (const [x,] of ctx) {
      if (x === varName) {
        //console.log(`binding ${varName} to ${binder}`);
        return extendContext(ctx, varName, new Free(tv));
      }
    }
    throw new Error(`
      ${varName} is already bound in ${JSON.stringify(ctx)}
    `);
  }
  return extendContext(ctx, varName, new Free(tv));
}

// Function to bind a value in a context
export function bindVal(ctx: Context, varName: string, type: Value, value: Value): Context {
  return extendContext(ctx, varName, new Define(type, value));
}


// For informationa bout serializable contexts, see the comments in
// normalize.rkt.
export type SerializableContext =
  Map<string, ['free', C.Core] | ['def', C.Core, C.Core] | ['claim', C.Core]>;

// Predicate to check if something is a serializable context
export function isSerializableContext(ctx: unknown): ctx is SerializableContext {
  return ctx instanceof Map && Array.from(ctx.values()).every(value => {
    return Array.isArray(value) &&
      (
        (value[0] === 'free' && value[1] instanceof C.Core)
        ||
        (value[0] === 'def' && value[1] instanceof C.Core && value[2] instanceof C.Core)
        ||
        (value[0] === 'claim' && value[2] instanceof C.Core)
      );
  });
}
</file>

<file path="src/pie_interpreter/types/source.ts">
import * as C from './core';
import * as V from './value';
import * as N from './neutral';
import * as S from './source';

import { PieInfoHook, Renaming, SendPieInfo, extendRenaming, makeApp, rename } from '../typechecker/utils';
import { Location, notForInfo } from '../utils/locations';
import {
  bindFree,
  bindVal,
  Context,
  readBackContext,
  valInContext,
  getInductiveType,
  InductiveDatatypeBinder,
  ConstructorTypeBinder,
  contextToEnvironment
} from '../utils/context';
import { extendEnvironment } from '../utils/environment';

import { go, stop, goOn, occurringBinderNames, Perhaps,
  PerhapsM, SiteBinder, TypedBinder, Message, freshBinder,
  isVarName, extractVarNamesFromValue} from './utils';
import { convert, sameType } from '../typechecker/utils';
import { readBack } from '../evaluator/utils';
import { synthesizer as Synth } from '../typechecker/synthesizer';
import { fresh } from './utils';
import { varType } from '../utils/context';

export abstract class Source {

  constructor(
    public location: Location,
  ) { }

  /*
    Find all the names that occur in an expression. For correctness, we
    need only find the free identifiers, but finding the bound
    identifiers as well means that the bindings introduced by
    desugaring expressions are more different from the program as
    written, which can help readability of internals.
  */
  public abstract findNames(): string[];

  public abstract prettyPrint(): string;

  public isType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const ok = new PerhapsM<C.Core>("ok");
    const theType = this.getType(ctx, renames);
    return goOn(
      [[ok, () => theType]],
      () => {
        SendPieInfo(this.location, ['is-type', ok.value]);
        return new go(ok.value);
      }
    );
  }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const checkType = this.check(ctx, renames, new V.Universe());
    if (checkType instanceof go) {
      return checkType;
    } else if (checkType instanceof stop) {
      if (this instanceof Name && isVarName(this.name)) {
        const otherTv = new PerhapsM<V.Value>("other-tv");
        return goOn(
          [
            [otherTv,
              () => varType(ctx, this.location, this.name)]
          ],
          () => {
            return new stop(this.location, new Message([`Expected U, but given ${otherTv.value.readBackType(ctx)}`]));
          }
        );
      } else {
        return new stop(this.location, new Message([`not a type`]));
      }
    } else {
      throw new Error('Invalid checkType');
    }
  }

  public check(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const ok = new PerhapsM<C.Core>("ok");
    const out = this.checkOut(ctx, renames, type);
    // SendPieInfo(srcLoc(input), ['has-type', readBackType(Γ, tv)!]);
    return goOn(
      [[ok, () => out]],
      () => new go(ok.value)
    );
  }

  public synth(ctx: Context, renames: Renaming): Perhaps<C.The> {
    const ok = new PerhapsM<C.The>("ok");

    return goOn(
      [[ok, () => this.synthHelper(ctx, renames)]],
      () => {
        SendPieInfo(this.location, ['is-type', ok.value.type]);
        return new go(ok.value)
      }
    );
  }

  protected abstract synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The>;

  protected checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const theT = new PerhapsM<C.The>("theT");
    return goOn(
      [
        [theT, () => this.synth(ctx, renames)],
        [
          new PerhapsM<undefined>("_"),
          () => sameType(ctx, this.location, valInContext(ctx, theT.value.type), type)
        ],
      ],
      () => new go(theT.value.expr)
    );
  }
}


export class The extends Source {

  constructor(
    public location: Location,
    public type: Source,
    public value: Source,
  ) {
    super(location);
  }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthThe(ctx, renames, this.type, this.value);
  }

  public findNames(): string[] {
    return this.type.findNames()
      .concat(this.value.findNames());
  }

  public prettyPrint(): string {
    return `(the ${this.type.prettyPrint()} ${this.value.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Universe extends Source {

  constructor(
    public location: Location,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthUniverse(ctx, renames, this.location);
  }

  public findNames(): string[] {
    return [];
  }

  public getType(_ctx: Context, _renames: Renaming): Perhaps<C.Core> {
    return new go(new C.Universe());
  }

  public prettyPrint(): string {
    return 'U';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Nat extends Source {

  constructor(
    public location: Location,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthNat(ctx, renames);
  }

  public findNames(): string[] {
    return [];
  }

  public getType(_ctx: Context, _renames: Renaming): Perhaps<C.Core> {
    return new go(new C.Nat());
  }

  public prettyPrint(): string {
    return 'Nat';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Zero extends Source {

  constructor(
    public location: Location,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthZero(ctx, renames);
  }

  public findNames(): string[] {
    return [];
  }

  public prettyPrint(): string {
    return 'zero';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}


export class Add1 extends Source {

  constructor(
    public location: Location,
    public base: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthAdd1(ctx, renames, this.base);
  }

  public findNames(): string[] {
    return this.base.findNames();
  }

  public prettyPrint(): string {
    return `(add1 ${this.base.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class WhichNat extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public base: Source,
    public step: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthWhichNat(ctx, renames, this.target, this.base, this.step);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.base.findNames())
      .concat(this.step.findNames());
  }

  public prettyPrint(): string {
    return `(which-nat ${this.target.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IterNat extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public base: Source,
    public step: Source,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthIterNat(ctx, renames, this.target, this.base, this.step);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.base.findNames())
      .concat(this.step.findNames());
  }

  public prettyPrint(): string {
    return `(iter-nat ${this.target.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class RecNat extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public base: Source,
    public step: Source,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthRecNat(ctx, renames, this.target, this.base, this.step);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.base.findNames())
      .concat(this.step.findNames());
  }

  public prettyPrint(): string {
    return `(rec-nat ${this.target.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndNat extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public motive: Source,
    public base: Source,
    public step: Source,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthIndNat(ctx, renames, this.target, this.motive, this.base, this.step);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.motive.findNames())
      .concat(this.base.findNames())
      .concat(this.step.findNames());
  }

  public prettyPrint(): string {
    return `(ind-nat ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

// Function types and operations
export class Arrow extends Source {

  constructor(
    public location: Location,
    public arg1: Source,
    public arg2: Source,
    public args: Source[],
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthArrow(ctx, renames, this.location, this.arg1, this.arg2, this.args);
  }

  public findNames(): string[] {
    return this.arg1.findNames()
      .concat(this.arg2.findNames())
      .concat(this.args.flatMap(arg => arg.findNames()));
  }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const [A, B, args] = [this.arg1, this.arg2, this.args];
    if (args.length === 0) {
      const x = freshBinder(ctx, B, 'x');
      const Aout = new PerhapsM<C.Core>("Aout");
      const Bout = new PerhapsM<C.Core>('Bout');
      return goOn(
        [
          [Aout, () => A.isType(ctx, renames)],
          [Bout,
            () =>
              B.isType(
                bindFree(ctx, x, valInContext(ctx, Aout.value)),
                renames)
          ]
        ],
        () => {
          return new go(
            new C.Pi(x, Aout.value, Bout.value)
          );
        }
      );
    } else {
      const [rest0, ...rest] = args;
      const x = freshBinder(ctx, makeApp(B, rest0, rest), 'x');
      const Aout = new PerhapsM<C.Core>("Aout");
      const tout = new PerhapsM<C.Core>('tout');
      return goOn(
        [
          [Aout, () => A.isType(ctx, renames)],
          [tout,
            () =>
              new Arrow(
                notForInfo(this.location),
                B,
                rest0,
                rest
              ).isType(
                bindFree(ctx, x, valInContext(ctx, Aout.value)),
                renames
              )
          ]
        ],
        () => new go(new C.Pi(x, Aout.value, tout.value))
      );
    }
  }

  public prettyPrint(): string {
    return `(-> ${this.arg1.prettyPrint()} ${this.arg2.prettyPrint()} ${this.args.map(arg => arg.prettyPrint()).join(' ')})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Pi extends Source {

  constructor(
    public location: Location,
    public binders: TypedBinder[],
    public body: Source,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthPi(ctx, renames, this.location, this.binders, this.body);
  }

  public findNames(): string[] {
    // TEST THIS
    return this.binders.flatMap(binder => occurringBinderNames(binder))
      .concat(this.body.findNames());
  }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const [binders, B] = [this.binders, this.body];
    if (binders.length === 1) {
      const [bd, A] = [binders[0].binder, binders[0].type];
      const y = fresh(ctx, bd.varName);
      const xloc = bd.location;
      const Aout = new PerhapsM<C.Core>('Aout');
      const Aoutv = new PerhapsM<V.Value>('Aoutv');
      const Bout = new PerhapsM<C.Core>('Bout');
      return goOn(
        [
          [Aout, () => A.isType(ctx, renames)],
          [Aoutv, () =>
            new go(valInContext(ctx, Aout.value))
          ],
          [Bout, () =>
            B.isType(
              bindFree(ctx, y, Aoutv.value),
              extendRenaming(renames, bd.varName, y)
            )
          ],
        ],
        () => {
          PieInfoHook(xloc, ['binding-site', Aout.value]);
          return new go(
            new C.Pi(
              y,
              Aout.value,
              Bout.value
            )
          )
        }
      );
    } else if (binders.length > 1) {
      const [bd, ...rest] = binders;
      const [x, A] = [bd.binder.varName, bd.type];
      const z = fresh(ctx, x);
      const xloc = bd.binder.location;
      const Aout = new PerhapsM<C.Core>('Aout');
      const Aoutv = new PerhapsM<V.Value>('Aoutv');
      const Bout = new PerhapsM<C.Core>('Bout');
      return goOn(
        [
          [Aout, () => A.isType(ctx, renames)],
          [Aoutv, () =>
            new go(valInContext(ctx, Aout.value))
          ],
          [Bout, () =>
            new Pi(
              notForInfo(this.location),
              rest,
              B
            ).isType(
              bindFree(ctx, z, Aoutv.value),
              extendRenaming(renames, bd.binder.varName, z)
            )
          ]
        ],
        () => {
          PieInfoHook(xloc, ['binding-site', Aout.value]);
          return new go(
            new C.Pi(
              z,
              Aout.value,
              Bout.value
            )
          );
        }
      );
    } else {
      throw new Error('Invalid number of binders in Pi type');
    }
  }

  public prettyPrint(): string {
    return `(Π ${this.binders.map(binder => `(${binder.binder.varName} ${binder.type.prettyPrint()})`).join(' ')} 
            ${this.body.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}


export class Lambda extends Source {

  constructor(
    public location: Location,
    public binders: SiteBinder[],
    public body: Source,
  ) { super(location); }


  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

  public findNames(): string[] {
    return this.binders.map(binder => binder.varName)
      .concat(this.body.findNames());
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    if (this.binders.length === 1) {
      const body = this.body;
      const binder = this.binders[0];
      const x = binder.varName;
      const xLoc = binder.location;
      const typeNow = type.now();
      if (typeNow instanceof V.Pi) {
        const A = typeNow.argType;
        const closure = typeNow.resultType;
        const xRenamed = rename(renames, x);
        const bout = new PerhapsM<C.Core>("bout");
        return goOn(
          [
            [
              bout,
              () => body.check(
                bindFree(ctx, xRenamed, A),
                extendRenaming(renames, x, xRenamed),
                closure.valOfClosure(
                  new V.Neutral(
                    A,
                    new N.Variable(xRenamed)
                  )
                )
              )
            ]
          ],
          () => {
            PieInfoHook(xLoc, ['binding-site', A.readBackType(ctx)]);
            return new go(new C.Lambda(xRenamed, bout.value));
          }
        );
      } else {
        return new stop(
          xLoc,
          new Message([`Not a function type: ${typeNow.readBackType(ctx)}.`])
        );
      }
    } else { // xBinding.length > 1
      return (new S.Lambda(
        this.location,
        [this.binders[0]],
        (new S.Lambda(
          notForInfo(this.location),
          this.binders.slice(1),
          this.body))
      )).check(ctx, renames, type);
    }
  }

  public prettyPrint(): string {
    return `(lambda ${this.binders.map(binder => binder.varName).join(' ')} ${this.body.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

// Product types and operations
export class Sigma extends Source {

  constructor(
    public location: Location,
    public binders: TypedBinder[],
    public body: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthSigma(ctx, renames, this.location, this.binders, this.body);
  }

  public findNames(): string[] {
    return this.binders.flatMap(binder => occurringBinderNames(binder))
      .concat(this.body.findNames());
  }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const [binders, D] = [this.binders, this.body];
    if (binders.length === 1) {
      const [bd, A] = [binders[0].binder, binders[0].type];
      const x = bd.varName;
      const y = fresh(ctx, x);
      const xloc = bd.location;
      const Aout = new PerhapsM<C.Core>('Aout');
      const Aoutv = new PerhapsM<V.Value>('Aoutv');
      const Dout = new PerhapsM<C.Core>('Dout');
      return goOn(
        [
          [Aout, () => A.isType(ctx, renames)],
          [Aoutv, () => new go(valInContext(ctx, Aout.value))],
          [Dout, () =>
            D.isType(
              bindFree(ctx, y, Aoutv.value),
              extendRenaming(renames, x, y)
            )
          ]
        ],
        () => {
          PieInfoHook(xloc, ['binding-site', Aout.value]);
          return new go(
            new C.Sigma(y, Aout.value, Dout.value)
          );
        }
      );
    } else if (binders.length > 1) {
      const [[bd, A], ...rest]
        = [[binders[0].binder, binders[0].type], binders[1], ...binders.slice(2)];
      const x = bd.varName;
      const z = fresh(ctx, x);
      const xloc = bd.location;
      const Aout = new PerhapsM<C.Core>('Aout');
      const Aoutv = new PerhapsM<V.Value>('Aoutv');
      const Dout = new PerhapsM<C.Core>('Dout');
      return goOn(
        [
          [Aout, () => A.isType(ctx, renames)],
          [Aoutv, () => new go(valInContext(ctx, Aout.value))],
          [Dout, () =>
            new Sigma(this.location, rest, D)
              .isType(
                bindFree(ctx, x, Aoutv.value),
                extendRenaming(renames, x, z)
              )
          ]
        ],
        () => {
          PieInfoHook(xloc, ['binding-site', Aout.value]);
          return new go(
            new C.Sigma(z, Aout.value, Dout.value)
          );
        }
      );
    } else {
      throw new Error('Invalid number of binders in Sigma type');
    }
  }

  public prettyPrint(): string {
    return `(Σ ${this.binders.map(binder => `(${binder.binder.varName} ${binder.type.prettyPrint()})`).join(' ')} 
            ${this.body.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Name extends Source {

  constructor(
    public location: Location,
    public name: string,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthName(ctx, renames, this.location, this.name);
  }

  public findNames(): string[] {
    return [this.name];
  }

  public prettyPrint(): string {
    return this.name;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Atom extends Source {

  constructor(
    public location: Location,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthAtom(ctx, renames);
  }

  public findNames(): string[] {
    return [];
  }

  public getType(_ctx: Context, _renames: Renaming): Perhaps<C.Core> {
    return new go(new C.Atom());
  }

  public prettyPrint(): string {
    return 'Atom';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Quote extends Source {

  constructor(
    public location: Location,
    public name: string,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthQuote(ctx, renames, this.location, this.name);
  }

  public findNames(): string[] {
    return [];
  }

  public prettyPrint(): string {
    return `'${this.name}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Pair extends Source {

  constructor(
    public location: Location,
    public first: Source,
    public second: Source,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthPair(ctx, renames, this.first, this.second);
  }

  public findNames(): string[] {
    return this.first.findNames()
      .concat(this.second.findNames());
  }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const Aout = new PerhapsM<C.Core>('Aout');
    const Dout = new PerhapsM<C.Core>('Dout');
    const x = freshBinder(ctx, this.second, 'x');
    return goOn(
      [
        [Aout, () => this.first.isType(ctx, renames)],
        [Dout, () => this.second.isType(
          bindFree(ctx, x, valInContext(ctx, Aout.value)),
          renames)],
      ],
      () => new go(new C.Sigma(x, Aout.value, Dout.value))
    );
  }

  public prettyPrint(): string {
    return `(Pair ${this.first.prettyPrint()} ${this.second.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Cons extends Source {

  constructor(
    public location: Location,
    public first: Source,
    public second: Source,
  ) { super(location); }

  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }


  public findNames(): string[] {
    return this.first.findNames()
      .concat(this.second.findNames());
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const typeNow = type.now();
    if (typeNow instanceof V.Sigma) {
      const A = typeNow.carType;
      const closure = typeNow.cdrType;
      const aout = new PerhapsM<C.Core>("aout");
      const dout = new PerhapsM<C.Core>("dout");
      return goOn(
        [
          [aout, () => this.first.check(ctx, renames, A)],
          [
            dout,
            () =>
              this.second.check(
                ctx,
                renames,
                closure.valOfClosure(valInContext(ctx, aout.value))
              )
          ]
        ],
        () => new go(
          new C.Cons(aout.value, dout.value)
        )
      );
    } else {
      return new stop(
        this.location,
        new Message([`cons requires a Pair or Σ type, but was used as a: ${typeNow.readBackType(ctx)}.`])
      );
    }
  }

  public prettyPrint(): string {
    return `(cons ${this.first.prettyPrint()} ${this.second.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Car extends Source {

  constructor(
    public location: Location,
    public pair: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthCar(ctx, renames, this.location, this.pair);
  }

  public findNames(): string[] {
    return this.pair.findNames();
  }

  public prettyPrint(): string {
    return `(car ${this.pair.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Cdr extends Source {

  constructor(
    public location: Location,
    public pair: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthCdr(ctx, renames, this.location, this.pair);
  }

  public findNames(): string[] {
    return this.pair.findNames();
  }

  public prettyPrint(): string {
    return `(cdr ${this.pair.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

// Basic constructors
export class Trivial extends Source {

  constructor(
    public location: Location,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthTrivial(ctx, renames);
  }

  public findNames(): string[] {
    return [];
  }

  public getType(_ctx: Context, _renames: Renaming): Perhaps<C.Core> {
    return new go(new C.Trivial());
  }

  public prettyPrint(): string {
    return 'Trivial';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Sole extends Source {

  constructor(
    public location: Location,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthSole(ctx, renames);
  }

  public findNames(): string[] {
    return [];
  }

  public prettyPrint(): string {
    return 'Sole';
  }

}

export class Nil extends Source {

  constructor(
    public location: Location
  ) { super(location); }

  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

  public findNames(): string[] {
    return [];
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const typeNow = type.now();
    if (typeNow instanceof V.List) {
      return new go(new C.Nil());
    } else {
      return new stop(
        this.location,
        new Message([`nil requires a List type, but was used as a: ${typeNow.readBackType(ctx)}.`])
      );
    }
  }

  public prettyPrint(): string {
    return 'nil';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Number extends Source {

  constructor(
    public location: Location,
    public value: number,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthNumber(ctx, renames, this.location, this.value);
  }

  public findNames(): string[] {
    return [];
  }

  public prettyPrint(): string {
    return `${this.value}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class List extends Source {

  constructor(
    public location: Location,
    public entryType: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthList(ctx, renames, this);
  }

  public findNames(): string[] {
    return this.entryType.findNames();
  }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const Eout = new PerhapsM<C.Core>('Eout');
    return goOn(
      [[Eout, () => this.entryType.isType(ctx, renames)]],
      () => new go(new C.List(Eout.value))
    );
  }

  public prettyPrint(): string {
    return `(List ${this.entryType.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}



export class ListCons extends Source {

  constructor(
    public location: Location,
    public x: Source,
    public xs: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthListCons(ctx, renames, this.x, this.xs);
  }

  public findNames(): string[] {
    return this.x.findNames()
      .concat(this.xs.findNames());
  }

  public prettyPrint(): string {
    return `(:: ${this.x.prettyPrint()} ${this.xs.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class RecList extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public base: Source,
    public step: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthRecList(ctx, renames, this.location, this.target, this.base, this.step);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.base.findNames())
      .concat(this.step.findNames());
  }

  public prettyPrint(): string {
    return `(rec-list ${this.target.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndList extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public motive: Source,
    public base: Source,
    public step: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthIndList(ctx, renames, this.location, this.target, this.motive, this.base, this.step);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.motive.findNames())
      .concat(this.base.findNames())
      .concat(this.step.findNames());
  }

  public prettyPrint(): string {
    return `(ind-list ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.base.prettyPrint()} 
              ${this.step.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

// Absurd and its operations
export class Absurd extends Source {

  constructor(
    public location: Location,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthAbsurd(ctx, renames, this);
  }

  public findNames(): string[] {
    return [];
  }
  public getType(_ctx: Context, _renames: Renaming): Perhaps<C.Core> {
    return new go(new C.Absurd());
  }

  public prettyPrint(): string {
    return 'Absurd';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndAbsurd extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public motive: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthIndAbsurd(ctx, renames, this);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.motive.findNames());
  }

  public prettyPrint(): string {
    return `(ind-Absurd 
              ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

// Equality types and operations
export class Equal extends Source {

  constructor(
    public location: Location,
    public type: Source,
    public left: Source,
    public right: Source,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthEqual(ctx, renames, this.type, this.left, this.right);
  }


  public findNames(): string[] {
    return this.type.findNames()
      .concat(this.left.findNames())
      .concat(this.right.findNames());
  }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const [A, from, to] = [this.type, this.left, this.right];
    const Aout = new PerhapsM<C.Core>('Aout');
    const Av = new PerhapsM<V.Value>('Av');
    const from_out = new PerhapsM<C.Core>('from_out');
    const to_out = new PerhapsM<C.Core>('to_out');
    return goOn(
      [
        [Aout, () => A.isType(ctx, renames)],
        [Av, () => new go(valInContext(ctx, Aout.value))],
        [from_out, () => from.check(ctx, renames, Av.value)],
        [to_out, () => to.check(ctx, renames, Av.value)],
      ],
      () => new go(
        new C.Equal(Aout.value, from_out.value, to_out.value)
      )
    );
  }

  public prettyPrint(): string {
    return `(= ${this.type.prettyPrint()} 
              ${this.left.prettyPrint()} 
              ${this.right.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Same extends Source {

  constructor(
    public location: Location,
    public type: Source,
  ) { super(location); }


  public findNames(): string[] {
    return this.type.findNames();
  }

  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const typeNow = type.now()
    if (typeNow instanceof V.Equal) {
      const A = typeNow.type;
      const from = typeNow.from;
      const to = typeNow.to;
      const cout = new PerhapsM<C.Core>("cout");
      const val = new PerhapsM<V.Value>("val");
      return goOn(
        [
          [cout, () => this.type.check(ctx, renames, A)],
          [val, () => new go(valInContext(ctx, cout.value))],
          [
            new PerhapsM<undefined>("_"),
            () => convert(ctx, this.type.location, A, from, val.value)
          ],
          [
            new PerhapsM<undefined>("_"),
            () => convert(ctx, this.type.location, A, to, val.value)
          ],
        ],
        () => new go(new C.Same(cout.value))
      );
    } else {
      return new stop(
        this.location,
        new Message([`same requires an Equal type, but encounter: ${typeNow.readBackType(ctx)}.`])
      );
    }
  }

  public prettyPrint(): string {
    return `(same ${this.type.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Replace extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public motive: Source,
    public base: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthReplace(ctx, renames, this.location, this.target, this.motive, this.base);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.motive.findNames())
      .concat(this.base.findNames());
  }

  public prettyPrint(): string {
    return `(replace ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.base.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Trans extends Source {
  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthTrans(ctx, renames, this.location, this.left, this.right);
  }
  constructor(
    public location: Location,
    public left: Source,
    public right: Source,
  ) { super(location); }

  public findNames(): string[] {
    return this.left.findNames()
      .concat(this.right.findNames());
  }

  public prettyPrint(): string {
    return `(trans ${this.left.prettyPrint()} ${this.right.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Cong extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public fun: Source,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthCong(ctx, renames, this.location, this.target, this.fun);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.fun.findNames());
  }

  public prettyPrint(): string {
    return `(cong ${this.target.prettyPrint()} ${this.fun.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Symm extends Source {

  constructor(
    public location: Location,
    public equality: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthSymm(ctx, renames, this.location, this.equality);
  }


  public findNames(): string[] {
    return this.equality.findNames();
  }

  public prettyPrint(): string {
    return `(symm ${this.equality.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndEqual extends Source {

  constructor(
    public location: Location,
    public target: Source,
    public motive: Source,
    public base: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthIndEqual(ctx, renames, this.location, this.target, this.motive, this.base);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.motive.findNames())
      .concat(this.base.findNames());
  }

  public prettyPrint(): string {
    return `(ind-= ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.base.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

// Vector types and operations
export class Vec extends Source {

  constructor(
    public location: Location,
    public type: Source,
    public length: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthVec(ctx, renames, this.type, this.length);
  }

  public findNames(): string[] {
    return this.type.findNames()
      .concat(this.length.findNames());
  }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const Eout = new PerhapsM<C.Core>("Eout");
    const lenout = new PerhapsM<C.Core>('lenout');
    return goOn(
      [[Eout, () => this.type.isType(ctx, renames)],
      [lenout, () => this.length.check(ctx, renames, new V.Nat())]],
      () => new go(new C.Vec(Eout.value, lenout.value))
    );
  }

  public prettyPrint(): string {
    return `(Vec ${this.type.prettyPrint()} ${this.length.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class VecNil extends Source {

  constructor(
    public location: Location,
  ) { super(location); }

  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

  public findNames(): string[] {
    return [];
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const typeNow = type.now();
    if (typeNow instanceof V.Vec) {
      const lenNow = typeNow.length.now();
      if (lenNow instanceof V.Zero) {
        return new go(new C.VecNil());
      } else {
        return new stop(this.location,
          new Message([`vecnil requires a Vec type with length ZERO, but was used as a: 
          ${readBack(ctx, new V.Nat(), typeNow.length)}.`]));
      }
    } else {
      return new stop(
        this.location,
        new Message([`vecnil requires a Vec type, but was used as a: ${typeNow.readBackType(ctx)}.`])
      );
    }
  }

  public prettyPrint(): string {
    return 'vecnil';
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class VecCons extends Source {
  constructor(
    public location: Location,
    public x: Source,
    public xs: Source,
  ) { super(location); }

  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

  public findNames(): string[] {
    return this.x.findNames()
      .concat(this.xs.findNames());
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const typeNow = type.now();
    if (typeNow instanceof V.Vec) {
      const lenNow = typeNow.length.now();
      if (lenNow instanceof V.Add1) {
        const hout = new PerhapsM<C.Core>("hout");
        const tout = new PerhapsM<C.Core>("tout");
        const n_minus_1 = lenNow.smaller;
        return goOn(
          [
            [hout, () => this.x.check(ctx, renames, typeNow.entryType)],
            [tout, () =>
              this.xs.check(ctx, renames, new V.Vec(typeNow.entryType, n_minus_1))
            ]
          ],
          () => new go(new C.VecCons(hout.value, tout.value))
        );
      } else {
        return new stop(
          this.location,
          new Message([`vec:: requires a Vec type with length Add1, but was used with a: 
          ${readBack(ctx, new V.Nat(), typeNow.length)}.`])
        );
      }
    } else {
      return new stop(
        this.location,
        new Message([`vec:: requires a Vec type, but was used as a: ${typeNow.readBackType(ctx)}.`])
      );
    }
  }

  public prettyPrint(): string {
    return `(vec:: ${this.x.prettyPrint()} ${this.xs.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Head extends Source {

  constructor(
    public location: Location,
    public vec: Source,
  ) { super(location); }


  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthHead(ctx, renames, this.location, this.vec);
  }

  public findNames(): string[] {
    return this.vec.findNames();
  }

  public prettyPrint(): string {
    return `(head ${this.vec.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Tail extends Source {

  constructor(
    public location: Location,
    public vec: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthTail(ctx, renames, this.location, this.vec);
  }

  public findNames(): string[] {
    return this.vec.findNames();
  }

  public prettyPrint(): string {
    return `(tail ${this.vec.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndVec extends Source {

  constructor(
    public location: Location,
    public length: Source,
    public target: Source,
    public motive: Source,
    public base: Source,
    public step: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthIndVec(ctx, renames, this.location,
      this.length, this.target, this.motive, this.base, this.step);
  }

  public findNames(): string[] {
    return this.length.findNames()
      .concat(this.target.findNames())
      .concat(this.motive.findNames())
      .concat(this.base.findNames())
      .concat(this.step.findNames());
  }

  public prettyPrint(): string {
    return `ind-Vec ${this.length.prettyPrint()}
              ${this.target.prettyPrint()}
              ${this.motive.prettyPrint()}
              ${this.base.prettyPrint()}
              ${this.step.prettyPrint()}`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

// Either type and operations
export class Either extends Source {

  constructor(
    public location: Location,
    public left: Source,
    public right: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthEither(ctx, renames, this.left, this.right);
  }

  public findNames(): string[] {
    return this.left.findNames()
      .concat(this.right.findNames());
  }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    const Lout = new PerhapsM<C.Core>("Lout");
    const Rout = new PerhapsM<C.Core>("Rout");
    return goOn(
      [
        [Lout, () => this.left.isType(ctx, renames)],
        [Rout, () => this.right.isType(ctx, renames)]
      ],
      () => new go(new C.Either(Lout.value, Rout.value))
    );
  }

  public prettyPrint(): string {
    return `(Either ${this.left.prettyPrint()} ${this.right.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Left extends Source {
  constructor(
    public location: Location,
    public value: Source,
  ) { super(location); }

  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

  public findNames(): string[] {
    return this.value.findNames();
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const typeNow = type.now();
    if (typeNow instanceof V.Either) {
      const lout = new PerhapsM<C.Core>("lout");
      return goOn(
        [
          [lout, () => this.value.check(ctx, renames, typeNow.leftType)]
        ],
        () => new go(new C.Left(lout.value))
      );
    } else {
      return new stop(
        this.location,
        new Message([`left requires an Either type, but was used as a: ${typeNow.readBackType(ctx)}.`])
      );
    }
  }

  public prettyPrint(): string {
    return `(left ${this.value.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class Right extends Source {
  constructor(
    public location: Location,
    public value: Source,
  ) { super(location); }

  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

  public findNames(): string[] {
    return this.value.findNames();
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const typeNow = type.now();
    if (typeNow instanceof V.Either) {
      const rout = new PerhapsM<C.Core>("rout");
      return goOn(
        [
          [rout, () => this.value.check(ctx, renames, typeNow.rightType)]
        ],
        () => new go(new C.Right(rout.value))
      );
    } else {
      return new stop(
        this.location,
        new Message([`right requires an Either type, but was used as a: ${typeNow.readBackType(ctx)}.`])
      );
    }
  }

  public prettyPrint(): string {
    return `(right ${this.value.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

export class IndEither extends Source {
  constructor(
    public location: Location,
    public target: Source,
    public motive: Source,
    public baseLeft: Source,
    public baseRight: Source,
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthIndEither(ctx, renames, this.location, this.target, this.motive, this.baseLeft, this.baseRight);
  }

  public findNames(): string[] {
    return this.target.findNames()
      .concat(this.motive.findNames())
      .concat(this.baseLeft.findNames())
      .concat(this.baseRight.findNames());
  }

  public prettyPrint(): string {
    return `(ind-Either ${this.target.prettyPrint()} 
              ${this.motive.prettyPrint()} 
              ${this.baseLeft.prettyPrint()} 
              ${this.baseRight.prettyPrint()})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

// Utility
export class TODO extends Source {
  constructor(
    public location: Location,
  ) { super(location); }

  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

  public findNames(): string[] {
    return [];
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const typeVal = type.readBackType(ctx);
    SendPieInfo(this.location, ['TODO', readBackContext(ctx), typeVal, renames]);
    return new go(new C.TODO(this.location.locationToSrcLoc(), typeVal));
  }

  public prettyPrint(): string {
    return `TODO`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

}

// Application
export class Application extends Source {
  constructor(
    public location: Location,
    public func: Source,
    public arg: Source,
    public args: Source[],
  ) { super(location); }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthApplication(ctx, renames, this.location, this.func, this.arg, this.args);
  }

  public findNames(): string[] {
    return this.func.findNames()
      .concat(this.arg.findNames())
      .concat(this.args.flatMap(arg => arg.findNames()));
  }

  public prettyPrint(): string {
    return `(${this.func.prettyPrint()} ${this.arg.prettyPrint()} ${this.args.map(arg => arg.prettyPrint()).join(' ')})`;
  }

  public toString(): string {
    return this.prettyPrint();
  }

  // Override getType to handle inductive type applications
  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    // Check if func is a Name referring to an inductive type
    if (this.func instanceof Name) {
      const funcName = this.func.name;
      const binder = ctx.get(funcName);

      // If it's an inductive type, treat this as a GeneralTypeConstructor application
      if (binder instanceof InductiveDatatypeBinder) {
        // Create a GeneralTypeConstructor with the indices from args
        const allArgs = [this.arg, ...this.args];
        const generalTypeCtor = new GeneralTypeConstructor(
          this.location,
          funcName,
          [], // parameters - will be inferred from context
          allArgs
        );
        return generalTypeCtor.getType(ctx, renames);
      }
    }

    // Otherwise, use default behavior (check against Universe)
    return super.getType(ctx, renames);
  }

  // Override checkOut to handle constructor applications
  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    // Check if func is a Name referring to a constructor
    if (this.func instanceof Name) {
      const funcName = this.func.name;
      const binder = ctx.get(funcName);

      // If it's a constructor, treat this as a ConstructorApplication
      if (binder instanceof ConstructorTypeBinder) {
        const constructorApp = new ConstructorApplication(
          this.location,
          funcName,
          [this.arg, ...this.args]
        );
        return constructorApp.checkOut(ctx, renames, type);
      }
    }

    // Otherwise, use default behavior
    return super.checkOut(ctx, renames, type);
  }
}

export class GeneralType extends Source {
  constructor(
    public location: Location,
    public name: string,
    public paramType: TypedBinder[],
    public indicesType: TypedBinder[]
  ) {super(location)}

  public findNames(): string[] {
    throw new Error('Method not implemented.');
  }
  public prettyPrint(): string {
    throw new Error('Method not implemented.');
  }
  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

  public getType(ctx: Context, rename: Renaming): Perhaps<C.Core> {

    let cur_ctx = ctx
    let cur_rename = rename
    const normalizedParamType: C.Core[] = []
    const normalizedIndicesType: C.Core[] = []
    for (let i = 0; i < this.paramType.length; i++) {
      const fresh_name = fresh(cur_ctx, this.paramType[i].binder.varName)
      const resultTemp = this.paramType[i].type.isType(cur_ctx, cur_rename)
      cur_rename = extendRenaming(cur_rename, this.paramType[i].binder.varName, fresh_name)
      if (resultTemp instanceof stop) {
        return resultTemp
      } 
      cur_ctx = bindFree(cur_ctx, fresh_name,
        valInContext(cur_ctx, (resultTemp as go<C.Core>).result)
      )
      normalizedParamType.push((resultTemp as go<C.Core>).result)
    }
    for (let i = 0; i < this.indicesType.length; i++) {
      const fresh_name = fresh(cur_ctx, this.indicesType[i].binder.varName)
      const resultTemp = this.indicesType[i].type.isType(cur_ctx, cur_rename)
      cur_rename = extendRenaming(cur_rename, this.indicesType[i].binder.varName, fresh_name)
      if (resultTemp instanceof stop) {
        return resultTemp
      } 
      cur_ctx = bindFree(cur_ctx, fresh_name,
        valInContext(cur_ctx, (resultTemp as go<C.Core>).result)
      )
      normalizedIndicesType.push((resultTemp as go<C.Core>).result)
    }

    return new go(new C.InductiveType(this.name, normalizedParamType, normalizedIndicesType))


  }

}

export class GeneralTypeConstructor extends Source {
  public findNames(): string[] {
    throw new Error('Method not implemented.');
  }
  public prettyPrint(): string {
    throw new Error('Method not implemented.');
  }
  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }
  constructor(
    public location: Location,
    public name: string,
    public params: S.Source[],
    public indices: S.Source[]
  ) { super(location) }

  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {
    // GeneralTypeConstructor represents an applied inductive type, which has type Universe
    // First verify that the inductive type exists and check parameters/indices
    const inductiveResult = getInductiveType(ctx, this.location, this.name);
    if (inductiveResult instanceof stop) return inductiveResult;

    const inductiveBinder = (inductiveResult as go<InductiveDatatypeBinder>).result;
    const inductiveType = inductiveBinder.type;

    // Check that parameter and index counts match
    if (this.params.length !== inductiveType.parameterTypes.length ||
        this.indices.length !== inductiveType.indexTypes.length) {
      return new stop(this.location,
        new Message(['Parameter/index count mismatch for type ' + this.name]));
    }

    // Check each parameter and index and collect their Core representations
    const normalizedParams: C.Core[] = [];
    for (let i = 0; i < this.params.length; i++) {
      const paramCheck = this.params[i].check(ctx, renames, inductiveType.parameterTypes[i].now());
      if (paramCheck instanceof stop) return paramCheck;
      normalizedParams.push((paramCheck as go<C.Core>).result);
    }

    const normalizedIndices: C.Core[] = [];
    for (let i = 0; i < this.indices.length; i++) {
      const indexCheck = this.indices[i].check(ctx, renames, inductiveType.indexTypes[i].now());
      if (indexCheck instanceof stop) return indexCheck;
      normalizedIndices.push((indexCheck as go<C.Core>).result);
    }

    // Return the InductiveTypeConstructor expression itself
    return new go(new C.InductiveTypeConstructor(this.name, normalizedParams, normalizedIndices));
  }

  public checkOut(ctx: Context, renames: Renaming, target: V.Value): Perhaps<C.Core> {
    const cur_val = target.now()

    // If checking against Universe, this is a type expression (e.g., (Even () (n)) : U)
    // Verify it's well-formed and return its Core representation
    if (cur_val instanceof V.Universe) {
      return this.getType(ctx, renames);
    }

    const normalized_params: C.Core[] = []
    const normalized_indices: C.Core[] = []

    //TODO: verify name sameness check is not necessary

    if(!(cur_val instanceof V.InductiveType)) {
      return new stop(this.location, new Message(['target type is not user defined inductive type, or use the wrong type']))
    }

    const targetType: V.InductiveType = cur_val as V.InductiveType
    const paramTypes = targetType.parameterTypes
    const idxTypes = targetType.indexTypes

    if((this.params.length != paramTypes.length) || (this.indices.length != idxTypes.length)) {
      return new stop(this.location, new Message(['the number of parameters/indices is inconsistent in constructor']))
    }

    for (let i = 0; i < this.params.length; i++) {
      const result = this.params[i].check(ctx, renames, paramTypes[i].now())
      if (result instanceof stop) {
        return stop
      }
      normalized_params.push((result as go<C.Core>).result)
    }

    for (let i = 0; i < this.indices.length; i++) {
      const result = this.indices[i].check(ctx, renames, idxTypes[i].now())
      if (result instanceof stop) {
        return stop
      }
      normalized_indices.push((result as go<C.Core>).result)
    }

    return new go(new C.InductiveTypeConstructor(this.name, normalized_params, normalized_indices))

  }
}

export class GeneralEliminator extends Source {
  public findNames(): string[] {
    throw new Error('Method not implemented.');
  }
  public prettyPrint(): string {
    throw new Error('Method not implemented.');
  }
  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    throw new Error('Method not implemented.');
  }

}

// Generic eliminator application for user-defined inductive types
export class EliminatorApplication extends Source {
  constructor(
    public location: Location,
    public typeName: string,      // e.g., "MyList", "Bool"
    public target: Source,         // The value to eliminate
    public motive: Source,         // The motive function
    public methods: Source[]       // One method per constructor
  ) { super(location); }

  public findNames(): string[] {
    return [this.typeName]
      .concat(this.target.findNames())
      .concat(this.motive.findNames())
      .concat(this.methods.flatMap(m => m.findNames()));
  }

  public prettyPrint(): string {
    const methods = this.methods.map(m => m.prettyPrint()).join(' ');
    return `(ind-${this.typeName} ${this.target.prettyPrint()} ${this.motive.prettyPrint()} ${methods})`;
  }

  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {
    return Synth.synthGeneralEliminator(ctx, renames, this);
  }
}

// Constructor application for user-defined inductive types
export class ConstructorApplication extends Source {
  constructor(
    public location: Location,
    public constructorName: string,
    public args: Source[]
  ) { super(location); }

  public findNames(): string[] {
    return [this.constructorName]
      .concat(this.args.flatMap(a => a.findNames()));
  }

  public prettyPrint(): string {
    const args = this.args.map(a => a.prettyPrint()).join(' ');
    return `(${this.constructorName}${args.length > 0 ? ' ' + args : ''})`;
  }

  protected synthHelper(_ctx: Context, _renames: Renaming): Perhaps<C.The> {
    // return Synth.synthConstructorApplication(ctx, renames, this);
    throw new Error('Method not implemented.');
  }

  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {
    const constructorBinder = ctx.get(this.constructorName);
    if (!constructorBinder || !(constructorBinder instanceof ConstructorTypeBinder)) {
      return new stop(this.location, new Message([`Unknown constructor: ${this.constructorName}`]));
    }

    const ctorType = constructorBinder.constructorType;
    const expectedTypeNow = type.now();

    if (!(expectedTypeNow instanceof V.InductiveTypeConstructor)) {
      return new stop(this.location, new Message(['Expected inductive type constructor']));
    }

    // Get the inductive type definition to access parameter information
    const inductiveBinder = ctx.get(ctorType.type);
    if (!inductiveBinder || !(inductiveBinder instanceof InductiveDatatypeBinder)) {
      return new stop(this.location, new Message([`Unknown inductive type: ${ctorType.type}`]));
    }

    // Build an extended context with parameter and index bindings
    // This follows the type checking design: work with Context, not Environment
    // Get parameter names from constructor's return type (Core)
    const resultTypeCore = ctorType.resultType as C.InductiveTypeConstructor;

    let currentCtx = ctx;

    // Extract parameter names from constructor return type and bind to concrete values
    // expectedTypeNow.parameters[i] contains the concrete value (e.g., Nat)
    // resultTypeCore.parameters[i] contains the variable name (e.g., VarName("E"))
    for (let i = 0; i < resultTypeCore.parameters.length; i++) {
      const paramCore = resultTypeCore.parameters[i];
      if (paramCore instanceof C.VarName) {
        const paramName = paramCore.name;
        const concreteValue = expectedTypeNow.parameters[i].now();
        // Bind the parameter in the context as a definition
        // The type is Universe since parameters are types
        currentCtx = bindVal(currentCtx, paramName, new V.Universe(), concreteValue);
      }
    }

    // Similarly for indices (if any)
    // resultTypeCore.indices[i] contains variable names (e.g., VarName("n"))
    for (let i = 0; i < resultTypeCore.indices.length; i++) {
      const indexCore = resultTypeCore.indices[i];
      if (indexCore instanceof C.VarName) {
        const indexName = indexCore.name;
        const concreteValue = expectedTypeNow.indices[i].now();
        // For indices, we need to determine the type - typically Nat for length indices
        // We can read back the type from the inductive type definition
        const indexType = inductiveBinder.type.indexTypes[i].now();
        currentCtx = bindVal(currentCtx, indexName, indexType, concreteValue);
      }
    }

    // Extract constructor argument names from the return type Value (indices only!)
    // For indexed constructors like add1-smaller with return type (Less-Than () ((add1 j) (add1 k))),
    // this extracts ["j", "k"] from the indices (NOT parameters, which are types)
    // We only need to track INDEX arguments for incremental substitution
    const returnTypeValue = constructorBinder.type; // V.InductiveTypeConstructor
    const indexArgNames: string[] = [];
    returnTypeValue.indices.forEach(i => {
      indexArgNames.push(...extractVarNamesFromValue(i));
    });

    // Now check arguments using the current context
    const normalized_args: C.Core[] = [];
    const normalized_rec_args: C.Core[] = [];

    const allArgTypes = [...ctorType.argTypes, ...ctorType.rec_argTypes];

    if (this.args.length !== allArgTypes.length) {
      return new stop(this.location, new Message([
        `Constructor ${this.constructorName} expects ${allArgTypes.length} arguments, but got ${this.args.length}`
      ]));
    }

    // Check non-recursive arguments with incremental substitution
    for (let i = 0; i < ctorType.argTypes.length; i++) {
      // Evaluate the argument type in the current context
      const argTypeCore = ctorType.argTypes[i];
      const argTypeValue = valInContext(currentCtx, argTypeCore);

      const result = this.args[i].check(currentCtx, renames, argTypeValue);
      if (result instanceof stop) {
        return result;
      }

      const checkedArgCore = (result as go<C.Core>).result;
      normalized_args.push(checkedArgCore);

      // Extend context with this argument's value for use in subsequent arguments
      if (i < indexArgNames.length) {
        const argName = indexArgNames[i];
        const checkedArgValue = valInContext(currentCtx, checkedArgCore);
        const argType = argTypeValue;
        currentCtx = bindVal(currentCtx, argName, argType, checkedArgValue);
      }
    }

    // Check recursive arguments with incremental substitution
    const recArgStartIdx = ctorType.argTypes.length;
    for (let i = 0; i < ctorType.rec_argTypes.length; i++) {
      const recArgTypeCore = ctorType.rec_argTypes[i];
      const recArgTypeValue = valInContext(currentCtx, recArgTypeCore);

      const result = this.args[i + recArgStartIdx].check(currentCtx, renames, recArgTypeValue);
      if (result instanceof stop) {
        return result;
      }

      const checkedRecArgCore = (result as go<C.Core>).result;
      normalized_rec_args.push(checkedRecArgCore);

      // Extend context with this recursive argument's value
      const argNameIdx = recArgStartIdx + i;
      if (argNameIdx < indexArgNames.length) {
        const argName = indexArgNames[argNameIdx];
        const checkedRecArgValue = valInContext(currentCtx, checkedRecArgCore);
        currentCtx = bindVal(currentCtx, argName, recArgTypeValue, checkedRecArgValue);
      }
    }

    return new go(new C.Constructor(
      this.constructorName,
      ctorType.index,
      ctorType.type,
      normalized_args,
      normalized_rec_args
    ));
  }
}
</file>

<file path="package.json">
{
  "name": "@sourceacademy/pie-slang",
  "version": "1.0.0",
  "description": "Implementation of Pie in TypeScript, following the book: The Little Typer",
  "keywords": [
    "Pie",
    "interpreter",
    "compiler",
    "Source",
    "The Little Typer"
  ],
  "author": {
    "name": "Source Academy",
    "url": "https://github.com/source-academy/"
  },
  "license": "Apache-2.0",
  "main": "dist/index.ts",
  "files": [
    "dist/index.js"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/source-academy/pie-slang.git"
  },
  "devDependencies": {
    "@babel/core": "^7.26.0",
    "@babel/highlight": "^7.25.9",
    "@babel/preset-env": "^7.26.0",
    "@babel/preset-typescript": "^7.27.1",
    "@eslint/js": "^9.15.0",
    "@rollup/plugin-node-resolve": "^16.0.0",
    "@rollup/plugin-terser": "^0.4.4",
    "@rollup/plugin-typescript": "^12.1.4",
    "@types/estree": "^1.0.6",
    "@types/jest": "^29.5.14",
    "@types/mocha": "^10.0.10",
    "@types/node": "^24.8.1",
    "babel-jest": "^30.2.0",
    "esbuild": "^0.27.0",
    "eslint": "^9.15.0",
    "eslint-plugin-react": "^7.37.2",
    "globals": "^16.4.0",
    "jest": "^30.2.0",
    "monaco-editor": "^0.54.0",
    "monaco-languageclient": "^10.2.0",
    "resolve-cwd": "^3.0.0",
    "rollup": "^4.46.2",
    "to-fast-properties": "^4.0.0",
    "ts-jest": "^29.2.5",
    "tslib": "^2.8.1",
    "typescript": "^5.6.3",
    "typescript-eslint": "^8.15.0",
    "vscode-languageclient": "^9.0.1",
    "vscode-languageserver-protocol": "^3.17.5"
  },
  "dependencies": {
    "@google/genai": "^1.25.0",
    "@google/generative-ai": "^0.24.1",
    "conductor": "https://github.com/source-academy/conductor.git#0.3.0",
    "dotenv": "^17.2.3",
    "js-base64": "^3.7.8"
  },
  "scripts": {
    "build": "rollup -c",
    "test": "jest",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix"
  },
  "type": "module"
}
</file>

</files>
